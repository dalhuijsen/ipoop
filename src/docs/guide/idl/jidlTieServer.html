<HTML>

<HEAD>

   <TITLE>Java IDL: The "Hello World" Example With The POA-Tie Server-Side Model</TITLE>

<!-- Changed by: carson 5/2001 for j2se 1.4 -->

   <X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>

</HEAD>

<BODY BGCOLOR="#FFFFFF">



<H1 ALIGN=CENTER>Java IDL: The "Hello World" Example With The POA-Tie Server-Side 
Model</H1>

<HR>

<P>This document is a high-level overview of how to create a complete CORBA (Common Object 
Request Broker Architecture) application using IDL (Interface Definiton Language) to 
define interfaces and the Java IDL compiler to generate stubs and skeletons.  This 
document
describes using the POA-Tie Server-Side Model.  You might want to use the Tie model 
instead of the typical Inheritance model if your implementation must inherit from some 
other
implementation. Java allows any number of interface inheritance, but
there is only one slot for class inheritance. If you use the inheritance
model, that slot is used up. By using the Tie Model, that slot is freed
up for your own use. The drawback is that it introduces a level of
indirection: one extra method call occurs when invoking a method.

<P>The other part of this programming model is the <a href="POA.html">Portable Object 
Adapter</a>,
 or <em>POA</em>, which is designed to meet the following goals:
<P>
<UL>
<LI>Allow programmers to construct object implementations that are portable between 
different 
ORB 
products.
<LI>Provide support for objects with persistent identities.
<LI>Provide support for transparent activation of objects.
<LI>Allow a single servant to support multiple object identities simultaneously.
</UL> 

<P>CORBA supports at least two different server-side mappings for implementing an IDL 
interface:
<P>
<UL>
<LI>The Inheritance Model

<P>Using the Inheritance Model, you implement the IDL interface using an implementation 
class
that also extends the compiler-generated skeleton.  

<P>Inheritance models include:
<P>
	<UL>
	<LI>The OMG-standard, <em>POA</em>. Given an interface <tt>My</tt> defined in 
	<tt>My.idl</tt>, the file <tt>MyPOA.java</tt> is generated by the <tt>idlj</tt>
	 compiler. You must provide the implementation for <tt>My</tt> and it must inherit
	 from <tt>MyPOA</tt>, a stream-based skeleton that extends 
	 <a href="../../api/org/omg/PortableServer/Servant.html">
	 <tt>org.omg.PortableServer.Servant</tt></A>, which serves as the base 
	 class for all POA servant implementations.  

	<P>
	<LI><em>ImplBase</em>.  Given an interface <tt>My</tt> defined in <tt>My.idl</tt>, 
	the file <tt>_MyImplBase.java</tt> is generated. You must provide the 
implementation
	for <tt>My</tt> and it must inherit from <tt>_MyImplBase</tt>.
	
	<P><strong>NOTE: </strong>ImplBase is deprecated in favor of the POA model, but is 
provided to allow 
	compatibility with servers written in J2SE 1.3 and prior.  We do not recommend 
	creating new servers using this nonstandard model.
	
	</UL>
<P>
<LI>The Delegation Model

<P>Using the Delegation Model, you implement the IDL interface using two classes:
<P>
<UL>
<LI>An IDL-generated Tie class that inherits from the compiler-generated skeleton, but 
delegates all calls to an implementation class.
<LI>A class that implements the IDL-generated operations interface (such as 
<tt>HelloOperations</tt>), which defines the IDL function.<P>
</UL>

<P>The Delegation model is also known as the <em>Tie</em> model, or the Tie Delegation 
model. 
It inherits from either the POA or ImplBase compiler-generated skeleton, so the models 
will be 
described as POA/Tie or ImplBase/Tie models in this document.
</UL>

<P>This tutorial presents the Tie Delegation/POA model for server-side implementation.  
For 
tutorials using the other server-side implementations, see the following documents:

<UL>
<P>
<LI><a href="jidlExample.html">Java IDL: The "Hello World" Example</a>
<P>
This document presents a tutorial describing creating a complete CORBA application using 
IDL to define the interfaces and using the Java IDL compiler to  generate the default 
IDL-to-Java language mapping, which follows the POA Inheritance Model.   For compatibility 
with servers written using J2SDK 1.3 and earlier, you may want to use to the ImplBase 
Inheritance Model.



<P>
<LI><a href="jidlImplBaseServer.html">Java IDL: The "Hello World" Example with the 
ImplBase 
Server-Side Model</a>
<P>The ImplBase server-side model is an Inheritance Model, as is the POA model.  Use 
the <tt>idlj</tt> compiler with the <tt>-oldImplBase</TT> flag to generate server-side 
bindings 
that are compatible with older version of Java IDL (prior to J2SE 1.4).  Given an 
interface 
<tt>Hello</tt> defined in <tt>Hello.idl</tt>, the file <tt>_HelloImplBase.java</tt> is 
generated. You must provide the implementation for <tt>Hello</tt> and it must inherit from 
<tt>_HelloImplBase</tt>.

<P><STRONG>Note that using the <tt>-oldImplBase</TT> flag is 
non-standard: these APIs are being deprecated.  You would use this flag ONLY for 
compatibility 
with existing servers written in J2SE 1.3 or earlier.  In that case, you would need to 
modify 
an existing MAKEFILE to add the <tt>-oldImplBase</TT> flag to the <tt>idlj</tt> compiler, 
otherwise POA-based server-side mappings will be generated.  </STRONG>

</UL>





<P>This document contains:
<UL>

   <LI>The <A href="#IDL">IDL</A> for a simple "Hello World" program

   

   <LI>A <A href="#server">server</A> that creates an object and 
publishes it with a naming service using the POA-Tie server-side
  implementation

   

   <LI>An <A HREF="#application">application client</A>  that knows the 
object's name, retrieves a reference for it from the naming service, and invokes the 
object

   
   <LI><A href="#instructions">Instructions</A> for compiling and running 

the example

   </UL>



<P>






<!--************IDL*************-->



<A name="IDL">

<H2>Defining the Interface (<code>Hello.idl</code>)</H2></A>

<P>The first step to creating a CORBA application is to specify all of
your objects and their interfaces using the OMG's Interface
Definition Language (IDL). IDL has a syntax similar to C++ and
can be used to define modules, interfaces, data structures, and
more. The IDL can be mapped to a variety of programming
languages. The IDL mapping for Java is summarized in 
<a href="mapping/jidlMapping.html">IDL to Java Language Mapping Summary</a>.

<P>The following code is written in the OMG IDL, and describes a CORBA
 object whose <TT>sayHello()</TT> operation returns a string and whose <TT>shutdown()</TT> 
method
 shuts down the ORB.  
 To learn more about OMG IDL Syntax and Semantics, link to the OMG Web site, 
 and read Chapter 3 of the 
 <a href="http://www.omg.org/docs/formal/99-10-07".pdf>CORBA Specification</a>.</P>

<P><EM><STRONG>Hello.idl</STRONG></EM>

<PRE>
module HelloApp
{
  interface Hello
  {
  string sayHello();
  oneway void shutdown();
  };
};
</PRE>


<A name="interop">
<B>NOTE:</B> When writing code in OMG IDL,
  do not use an interface name as the name of a module. 
  Doing so runs the risk of getting inconsistent results when 
  compiling with tools from different vendors, thereby jeopardizing
  the code's portability.  For example, 
  code containing the same names could be compiled with the IDL to Java 
  compiler from Sun Microsystems and get one result. 
  The same code compiled with another vendor's IDL to Java 
  compiler could produce a different result. 
<p>

To complete the application, you simply provide the server (<code>HelloServer.java</code>) 
and client (<code>HelloClient.java</code>)
implementations.



<!--************SERVER*************-->



<A NAME="server">

<H2>Implementing the Server (<code>HelloServer.java</code>)</H2></A>



<P>The example server consists of two classes, the servant and the

server. The servant, <TT>HelloImpl</TT>, is the implementation of

the <TT>Hello</TT> IDL interface; each <TT>Hello</TT> instance is implemented

by a <TT>HelloImpl</TT> instance. The servant is a subclass of

<TT>HelloPOA</TT>, which 

is generated by the <TT>idlj</TT> compiler from the example IDL.

The servant contains one method for each IDL operation, in this

example, the <TT>sayHello()</TT>  and <tt>shutdown()</tt> methods. Servant methods are

just like ordinary Java methods; the extra code to deal with the ORB,

with marshaling arguments and results, and so on, is provided by the

skeleton.</P>



<P>The <tt>HelloServer</tt> class has the server's <TT>main()</TT> method, which:

</P>
<UL>

   <LI>Creates and initializes an ORB instance
   
   <LI>Gets a reference to the root POA and activates the <tt>POAManager</tt>

   <LI>Creates a servant instance (the implementation of one CORBA

   <TT>Hello</TT> object) and tells the ORB about it
   
   <LI>Creates a tie with the servant being the delegate


   <LI>Gets a CORBA object reference  for a naming context in which to

   register the tie. This step also implicitly activates the object. See the 
   <a href="POA.html">POA</a> topic for more information on POA policies and 
   activations.
   
   <LI>Gets the root naming context


   <LI>Registers the new object in the naming context under the name "Hello"


   <LI>Waits for invocations of the new object from the client
</UL>

<P>The code that is different from that in the <a href="jidlExample.html">default 
tutorial</A>
 is highlighted in <STRONG>bold</STRONG>.

<P><EM><STRONG>HelloServer.java</STRONG></EM>

<PRE>// <A HREF="examplelicense.html">Copyright and License</A> 
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

import java.util.Properties;

class HelloImpl extends HelloPOA{
  private ORB orb;

  public void setORB(ORB orb_val){
    orb = orb_val;
  }
  
  public String sayHello(){
    return "\nHello world !!\n";
  }
  
  public void shutdown(){
    orb.shutdown(false);
  }
}

public class HelloServer{

  public static void main(String args[]){
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // Get reference to rootpoa & activate the POAManager
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();

      // create servant and register it with the ORB
      HelloImpl helloImpl = new HelloImpl();
      helloImpl.setORB(orb); 
<STRONG>
      // create a tie, with servant being the delegate.
      HelloPOATie tie = new HelloPOATie(helloImpl, rootpoa);

      // obtain the objectRef for the tie
      // this step also implicitly activates the 
      // the object
      Hello href = tie._this(orb);
</STRONG>	    
      // get the root naming context
      org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
      
      // Use NamingContextExt which is part of the Interoperable
      // Naming Service specification.
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);

      // bind the Object Reference in Naming
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
      ncRef.rebind(path, href);

      System.out.println("HelloServer ready and waiting ...");

      // wait for invocations from clients
      orb.run();
      } 
      
    catch (Exception e){
      System.err.println("ERROR: " + e);
      e.printStackTrace(System.out);
    }
    
    System.out.println("HelloServer Exiting ...");
	
  }
}
&nbsp;</PRE>





<!--************APPLICATION*************-->



<A name="application">

<H2>Implementing the Client Application (<code>HelloClient.java</code>)</H2></A>



<P>The example application client that follows is the same as the one presented in the <a 
href="jidlExample.html">default tutorial</A>.  The server implementation is the only 
<em>file</em> 
that is changed from that example.  The example client application:</P>



<UL>

   <LI>Creates and initializes an ORB

   

   <LI>Obtains a reference to the root naming context

   

   <LI>Looks up "Hello" in the naming context and receives a reference to that CORBA 
object

   

   <LI>Invokes the object's <TT>sayHello()</TT> and <tt>shutdown()</tt> operations and 
prints

   the result

</UL>

<P><EM><STRONG>HelloClient.java</STRONG></EM>


<PRE>// <A HREF="examplelicense.html">Copyright and License</A> 
&nbsp;
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

public class HelloClient{

  public static void main(String args[]){
  
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // get the root naming context
      org.omg.CORBA.Object objRef = 
	  orb.resolve_initial_references("NameService");
	  
      // Use NamingContextExt instead of NamingContext. This is 
      // part of the Interoperable naming Service.  
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
 
      // resolve the Object Reference in Naming
      String name = "Hello";
      Hello helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));

      System.out.println("Obtained a handle on server object: " + helloImpl);
      System.out.println(helloImpl.sayHello());
      helloImpl.shutdown();
      }
      
    catch (Exception e) {
      System.out.println("ERROR : " + e) ;
      e.printStackTrace(System.out);
    }
  }
}
&nbsp;</PRE>


<!--************COMPILING THE EXAMPLES************-->



<A name="instructions">

<H2>Building and Running Hello World</H2></A>

<P>Despite its simple design, the Hello World program lets you learn and
experiment with all the tasks required to develop almost any CORBA program
that uses <A href="jidlGlossary.html#invocation">static invocation</A>.  

<P>This example requires a naming service, which is a CORBA service that allows <A 
href="jidlGlossary.html#CORBA object">CORBA objects</A>
to be named by means of binding a name to an object reference.
The <A HREF="jidlGlossary.html#name binding">name binding</A> may be stored
in the naming service, and a client may supply the name
to obtain the desired object reference.  The two options for Naming Services shipped with 
J2SE v.1.4 are <tt><a href="tnameserv.html">tnameserv</a></tt>, a transient naming 
service,  and <tt><a href="orbd.html">orbd</a></tt>, which contain a Naming Service. This 
example uses <tt>orbd</tt>.

<P>When running this example, remember that, when using 
Solaris software, you must become root to start a process on a port under 1024.  For this 
reason, we recommend that you use a port number greater than or equal to 1024. The 
<TT>-ORBInitialPort</TT> option is used to override the default port number in this 
example.  The following instructions assume you can use port 1050
for the Java&nbsp;IDL Object Request Broker Daemon, <tt>orbd</tt>. You can substitute a 
different
port if necessary.  When running these examples on a Windows machine, 
subtitute a backslash (\) in path names.</P>


<P> To run this client-server application on your development machine: 
<OL>

<LI>Change to the directory that contains the file <TT>Hello.idl</TT>.
<P>
<LI>Run the IDL-to-Java compiler, <TT>idlj</TT>, <strong>twice</strong> on the IDL file to
create stubs and skeletons.  This step assumes that you have included
the path to the java/bin directory in your path. <BR>

<PRE>
  idlj -fall  Hello.idl
  idlj -fallTie Hello.idl
</PRE>

<P>You must use the <TT>-fall</TT> option with the <TT>idlj</TT> compiler to generate both 
client and server-side bindings.  This command line will generate the default server-side 
bindings, 
which assumes the POA programming model. The <tt>-fallTie</tt> option generates another 
file,
 <tt>HelloPOATie</tt>, which is used to create a Tie. For more information on the 
<TT>idlj</TT> 
options, link 
to <A HREF = "../rmi-iiop/toJavaPortableUG.html">IDL-to-Java compiler options</A>.  

<P>The <TT>idlj</TT> compiler generates a number of files.  The actual number of files 
generated depends on the options
selected when the IDL file is compiled.  The generated files provide standard
functionality, so you can
ignore them until it is time to deploy and run your program.
The files generated by the <TT>idlj</TT> compiler for <TT>Hello.idl</TT>, with the 
<TT>-fall</TT> command 
line option, are: 
<P>
<UL>
<LI><TT>HelloPOA.java</TT>
<P>This abstract class is the stream-based
<A href="jidlGlossary.html#server skeleton">server skeleton</A>, 
providing basic CORBA 
functionality for the server. It extends <a href="../../api/org/omg/PortableServer/Servant.html">
<tt>org.omg.PortableServer.Servant</tt></A>,  
and implements the <tt>InvokeHandler</tt> interface and the <tt>HelloOperations</tt> 
interface.  
The 
server class <TT>HelloImpl</TT> extends <TT>HelloPOA</TT>.  
<P>
<LI><TT>_HelloStub.java</TT>
<P>This class is the 
<A href="jidlGlossary.html#client stub">client stub</A>, 
providing CORBA functionality for the
client. It extends <tt>org.omg.CORBA.portable.ObjectImpl</tt> and implements the 
<TT>Hello.java</TT> 
interface.
<P>
<LI><TT>Hello.java</TT>
<P>This interface contains the Java version of our IDL interface. The <TT>Hello.java</TT> 
interface extends
<TT>org.omg.CORBA.Object</TT>, providing standard CORBA object functionality.  It also 
extends 
the 
<tt>HelloOperations</tt> interface and <tt>org.omg.CORBA.portable.IDLEntity</tt>.
<P>
<LI><TT>HelloHelper.java</TT>
<P>This class provides auxiliary functionality, notably the 
<TT>narrow()</TT> method required to cast CORBA 
<A href="jidlGlossary.html#object reference">object references</A> to their 
proper types.The Helper class is 
responsible for reading and writing the data type to CORBA streams, and inserting and 
extracting the data type from <tt>Any</tt>s.  The Holder class delegates to the methods in 
the 
Helper class for reading and writing.
<P>
<LI><TT>HelloHolder.java</TT>
<P>This final class holds a public instance member of type <TT>Hello</TT>.  Whenever
the IDL type is an <tt>out</tt> or an <tt>inout</tt> parameter, the Holder class is used.  
It 
provides operations for <TT>org.omg.CORBA.portable.OutputStream</TT> and 
<TT>org.omg.CORBA.portable.InputStream</TT> arguments, which CORBA allows, but 
which do not map easily to Java's semantics. The Holder class delegates to the methods in 
the 
Helper class for reading and writing. It implements 
<tt>org.omg.CORBA.portable.Streamable</tt>. 
<P>
<LI><TT>HelloOperations.java</TT>
<P>This interface contains the methods <TT>sayHello()</TT> and <tt>shutdown()</tt>. The 
IDL-to-Java 
mapping 
puts all of the operations 
defined on the IDL interface into this file, which is shared by both the stubs and 
skeletons.
</UL>
<P>
The files generated by the <TT>idlj</TT> compiler for <TT>Hello.idl</TT>, with the 
<TT>-fallTie</TT> command 
line option, are: 
<P>
<UL>
<LI><TT>HelloPOATie.java</TT>
<P>The
constructor to <tt>MyPOATie</tt> takes a <tt>delegate</tt> and/or a <tt>poa</tt>.
 You must provide the implementations for <tt>delegate</tt> and/or <tt>poa</tt>, but the 
delegate does not 
have to inherit from any other class, only the interface <tt>HelloOperations</tt>. For
more information, refer to the <a href="mapping/jidlMapping.html"><em>IDL to Java Language 
Mapping Specification</em></a>.
</UL>

<P>
<LI>Compile the <TT>.java</TT> files, including the stubs and skeletons
(which are in the directory <TT>HelloApp</TT>).  This step assumes the java/bin 
directory is included in your path.
<PRE>
   javac *.java HelloApp/*.java
</PRE>

<LI>Start <tt>orbd</tt>.  

<P>To start <tt>orbd</tt> from a UNIX command shell, enter:
   <P>   
<PRE>
  orbd -ORBInitialPort 1050 -ORBInitialHost localhost&
</PRE>
<P>From an MS-DOS system prompt (Windows), enter:
<PRE>
  start orbd -ORBInitialPort 1050 -ORBInitialHost localhost
</PRE>
   
 <P>Note that <TT>1050</TT> is the port on which you want the name server to run.   
<tt>-ORBInitialPort</tt> is a required command-line argument.  Note that when using 
Solaris  software, you must become root to start a process on a port under 1024.  For this 
reason, 
we recommend that you use a port number greater than or equal to 1024.

<P><tt>-ORBInitialHost</tt> is also a required command-line argument. For this example, 
since 
both 
client and server on running on the development machine,
we have set the host to <tt>localhost</tt>.  When developing on more than one machine, you
will replace this with the name of the host.  For an example of how to run this program on
two machines, see <a href="tutorial/jidl2machines.html">Running the Hello World Program on 
2 machines</a>.<P>
 
<LI>Start the Hello server.
<P>To start the Hello server from a UNIX command shell, enter:
   <P>   
<PRE>
  java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost&
</PRE>
<P>From an MS-DOS system prompt (Windows), enter:
<PRE>
  start java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost
</PRE>
<P>For this example, you can omit <TT>-ORBInitialHost localhost</TT> since the 
name server is  running on the same host as the Hello server.   If the name server is 
running 
on a 
different host, use  <TT>-ORBInitialHost</TT> <em>nameserverhost</em> to specify the host 
on 
which 
the IDL name server is running.

<P>Specify the name server (<tt>orbd</tt>) port as done in the previous step, for example, 
<TT>-ORBInitialPort  1050</TT>.  <P>

   
<LI>Run the client application:<P>
<PRE>
  java HelloClient -ORBInitialPort 1050 -ORBInitialHost localhost
</PRE>

<P>For this example, you can omit <TT>-ORBInitialHost localhost</TT> since the 
name server is  running on the same host as the Hello client.  If the name server is 
running 
on a 
different host, use  <TT>-ORBInitialHost</TT> <em>nameserverhost</em> to specify the host 
on 
which 
the IDL name server is running.

<P>Specify the name server (<tt>orbd</tt>) port as done in the previous step, for example, 
<TT>-ORBInitialPort  1050</TT>.  <P>
<P>
  
</OL>
   
   
   <P>When you have finished this tutorial, be sure to shut down or kill the name server 
(<tt>orbd</tt>).  To do this from a DOS prompt, select 
the window 
that is running <tt>orbd</tt> and enter <TT>Ctrl+C</TT>  to shut it down.  
To do this from a Unix shell, find the process, and kill it.  The name server will 
continue to 
wait for 
invocations until it is explicitly stopped.


<P><STRONG><a href="tutorial/jidl2machines.html">Running the Hello World Application on 
Two 
Machines</a></STRONG> describes one way of distributing the simple application across two 
machines - a client and a server.



<CENTER><P><HR>

<TABLE summary="layout" cellpadding=8 cellspacing=4>
<TR>
  <TD ALIGN=CENTER><A href="index.html">Home</A></TD>
</TR></TABLE>


<HR><P><FONT SIZE="-2">

   <A HREF="../../relnotes/SMICopyright.html">Copyright &#169;</A> 1995-2001

   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>

  All Rights Reserved.</FONT></P>

</CENTER>



</BODY>

</HTML>
