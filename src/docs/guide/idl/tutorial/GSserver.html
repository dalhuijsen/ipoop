<HTML>
<HEAD>
   <TITLE>Getting Started with Java IDL: Developing the Hello World 
Server</TITLE>
<!-- Changed by: dbc 4/2001 -->
   <X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>
</HEAD>
<BODY BGCOLOR="#FFFFFF">


<H1 ALIGN=CENTER>Getting Started with Java IDL:<BR> Developing the Hello World 
Server</H1>
<HR>

<P>The example server consists of two classes, the servant and the server. The 
servant, <TT>HelloImpl</TT>, is the implementation of the <TT>Hello</TT> IDL 
interface; each <TT>Hello</TT> instance is implemented by a <TT>HelloImpl</TT> 
instance. The servant is a subclass of <TT>HelloPOA</TT>, which is 
generated by the <TT>idlj</TT> compiler from the example IDL.

<P>The servant contains one method for each IDL operation, in this example,  
the <TT>sayHello()</TT> and <TT>shutdown()</TT> methods. Servant methods are just 
like 
ordinary Java methods; the extra code to deal with the ORB, with marshaling 
arguments and results, and so on, is provided by the skeleton.</P>

<P>The server class has the server's <TT>main()</TT> method, which:

</P>
<UL>

   <LI>Creates and initializes an ORB instance   
   <LI>Gets a reference to the root POA and activates the <tt>POAManager</tt>
   <LI>Creates a servant instance (the implementation of one CORBA
     <TT>Hello</TT> object) and tells the ORB about it
   <LI>Gets a CORBA object reference for a naming context in which to
      register the new CORBA object   
   <LI>Gets the root naming context
   <LI>Registers the new object in the naming context under the name "Hello"
   <LI>Waits for invocations of the new object from the client
</UL>

<P>This lesson introduces the basics of writing a  CORBA server.  For an 
example of the "Hello World" program with a persistent object server, see <a 
href="../jidlExample2.html"><em>Example 2: Hello World with Persistent State</em></a>.  For 
more discussion of CORBA servers, see <a href="../jidlServers.html"><em>Developing 
Servers</em></a>.  

<P>The steps in this lesson cover:

<OL>
<LI><A href="#create">Creating HelloServer.java</A>
<LI><A href="#understand">Understanding HelloServer.java</A>
<LI><A href="#compile">Compiling the Hello World Server</A>
</OL>

<P>

<HR>
<A NAME="create">
<H2>Creating HelloServer.java</H2></A>
<P>To create <TT>HelloServer.java</TT>,
<P>
<OL>
<LI>Start your text editor and create a file named <TT>HelloServer.java</TT> in 
your main project directory, <TT>Hello</TT>.
<P>
<LI>Enter the following code for <TT>HelloServer.java</TT> in the text file.  The 
following section, <A HREF="#understand">Understanding HelloServer.java</A>, 
explains each line of code in some detail.
<P>
<PRE>
// <STRONG>HelloServer.java</STRONG>
// <A HREF="../examplelicense.html">Copyright and License</A> 
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

import java.util.Properties;

class HelloImpl extends HelloPOA {
  private ORB orb;

  public void setORB(ORB orb_val) {
    orb = orb_val; 
  }
    
  // implement sayHello() method
  public String sayHello() {
    return "\nHello world !!\n";
  }
    
  // implement shutdown() method
  public void shutdown() {
    orb.shutdown(false);
  }
}


public class HelloServer {

  public static void main(String args[]) {
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // get reference to rootpoa & activate the POAManager
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();

      // create servant and register it with the ORB
      HelloImpl helloImpl = new HelloImpl();
      helloImpl.setORB(orb); 

      // get object reference from the servant
      org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
      Hello href = HelloHelper.narrow(ref);
	  
      // get the root naming context
      org.omg.CORBA.Object objRef =
          orb.resolve_initial_references("NameService");
      // Use NamingContextExt which is part of the Interoperable
      // Naming Service (INS) specification.
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);

      // bind the Object Reference in Naming
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
      ncRef.rebind(path, href);

      System.out.println("HelloServer ready and waiting ...");

      // wait for invocations from clients
      orb.run();
    } 
	
      catch (Exception e) {
        System.err.println("ERROR: " + e);
        e.printStackTrace(System.out);
      }
	  
      System.out.println("HelloServer Exiting ...");
	
  }
}
&nbsp;</PRE>

<P>
<LI>Save and close <TT>HelloServer.java</TT>.
</OL>

<!--**********************************-->
<HR>
<A NAME="understand">
<H2>Understanding HelloServer.java</H2></A>
<P>This section explains each line of <TT>HelloServer.java</TT>, describing what 
the code does, as well as why it is needed for this application.



<A name="setup">
<H3>Performing Basic Setup</H3></A>

<P>The structure of a CORBA server program is the same as most Java 
applications:&nbsp;You import required library packages, declare the server 
class, define a <TT>main()</TT> method, and handle exceptions.

<A name="import">
<H4>Importing Required Packages</H4></A>

<P>First, we import the packages required for the server class:
<PRE>
// The package containing our stubs
import HelloApp.*;

// HelloServer will use the naming service
import org.omg.CosNaming.*;

// The package containing special exceptions thrown by the name service
import org.omg.CosNaming.NamingContextPackage.*;

// All CORBA applications need these classes
import org.omg.CORBA.*;

// Classes needed for the Portable Server Inheritance Model
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

// Properties to initiate the ORB
import java.util.Properties;
</PRE>

<A name="helloservant">
<H4>Defining the Servant Class</H4></A>

<P>In this example, we are defining the class for the servant object within 
<TT>HelloServer.java</TT>, but outside the  <TT>HelloServer</TT> class. 

<P>
<PRE>
class HelloImpl extends HelloPOA
{
  // The sayHello() and shutdown() methods go here.
}
</PRE>
<P>The servant is a subclass of <TT>HelloPOA</TT> so that it inherits the general 
CORBA functionality generated for it by the compiler.<P>

<P>First, we create a private variable, <code>orb</code> that is used in the 
<code>setORB(ORB)</code> method.  The <tt>setORB</tt> method is a private method 
defined by the application developer so that they can set the ORB value with the 
servant.  This ORB value is used to invoke <tt>shutdown()</tt> on that specific ORB 
in
response to the <tt>shutdown()</tt> method invocation from the client.
<P>
<PRE>
  private ORB orb;
  
  public void setORB(ORB orb_val) {
    orb = orb_val; 
  }
</PRE>

<P>Next, we declare and implement the required <TT>sayHello()</TT> method:<P>
<PRE>
  public String sayHello()
  {
    return "\nHello world!!\n";   
  }
</PRE>



<P>And last of all, we implement the <code>shutdown()</code> method in a similar 
way.  The <code>shutdown()</code> method calls the 
<code>org.omg.CORBA.ORB.shutdown(boolean)</code> method for the ORB.  The 
<code>shutdown(false)</code> operation indicate that the ORB should shut down 
immediately, without waiting for processing to complete.
<P>
<PRE>
  public void shutdown() {
    orb.shutdown(false);
  }
</PRE>



<A name="class">
<H4>Declaring the Server Class</H4></A>

<P>The next step is to declare the server class:
<PRE>
public class HelloServer 
{
  // The main() method goes here.
}
</PRE>


<A name="main">
<H4>Defining the main() Method</H4></A>

<P>Every Java application needs a <TT>main</TT> method.  It is declared within 
the scope of the <TT>HelloServer</TT> class:
<PRE>
  public static void main(String args[])
  {
    // The try-catch block goes here.
  }
</PRE>

<A name="except">
<H4>Handling CORBA System Exceptions</H4></A>

<P>Because all CORBA programs can throw CORBA system exceptions at
runtime, all of the <TT>main()</TT> functionality is placed within a 
try-catch block. CORBA programs throw runtime exceptions whenever trouble
occurs during any of the processes (marshaling, unmarshaling, upcall) 
involved in invocation. The exception handler simply prints the exception and its 
stack trace to standard output so you can see what kind of thing has gone wrong. 

<P>The try-catch block is set up inside <TT>main()</TT>, as shown:
<PRE>
    try{
    
      // The rest of the HelloServer code goes here.
    
    } catch(Exception e) {
        System.err.println("ERROR: " + e);
        e.printStackTrace(System.out);
      }
</PRE>


<!--************************************************-->
<A name="orb">
<H3>Creating and Initializing an ORB Object</H3></A>


<P>A CORBA server needs a local ORB object, as does the CORBA client. Every
server instantiates an ORB and registers its <A 
href="../jidlGlossary.html#servant object">servant objects</A> so that the ORB 
can find the server when it receives an invocation for it.

<P>The ORB variable is declared and initialized inside the try-catch block.
<PRE>
      ORB orb = ORB.init(args, null);
</PRE>

<P>The call to the ORB's <TT>init()</TT> method passes in the server's command 
line arguments, allowing you to set certain <A 
href="../jidlInitialization.html#systempropertiesobject">properties</A> at 
runtime. 

<!--************************************************-->
<A name="poaref">
<H3>Get a Reference to the Root POA and Activate the <tt>POAManager</tt></H3></A>

<P>The ORB obtains the initial object references to services such as
the Name Service using the method <code>resolve_initial_references</code>.

<P>The reference to the root POA is retrieved and the <tt>POAManager</tt> is 
activated from within the try-catch block.
<PRE>
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();
</PRE>

<P> The <code>activate()</code> operation changes the state of the POA manager 
to active, causing associated POAs to start processing requests.  The POA manager 
encapsulates the processing  state of the POAs with which it is associated.  Each 
<code>POA</code> object has an associated <code>POAManager</code> object.  A POA 
manager may be associated with one or more  POA objects.



<!--**********************************-->
<A name="servantobject">
<H3>Managing the Servant Object</H3></A>

A <A href="../jidlGlossary.html#server">server</A> is a process that instantiates 
one or more servant objects. The <A href="../jidlGlossary.html#servant 
object">servant</A> inherits from the interface generated by <TT>idlj</TT> and 
actually performs the work of the operations on that interface. Our 
<TT>HelloServer</TT> needs a <TT>HelloImpl</TT>.

<A name="servant">
<H4>Instantiating the Servant Object</H4></A>


<P>We instantiate the servant object inside the try-catch block, just after 
activating the POA manager, as shown:
<PRE>
      HelloImpl helloImpl = new HelloImpl();
</PRE>
<P>The section of code describing the servant class was explained previously.

<P>In the next line of code, <tt>setORB(orb)</tt> is defined on the servant so that 
<tt>ORB.shutdown()</tt> can be called as part of the shutdown operation.  This step 
is required because of the <tt>shutdown()</tt> method defined in <tt>Hello.idl</tt>.
<PRE>
      helloImpl.setORB(orb); 
</PRE>

<P>There are other options for implementing the shutdown operation.  In this example,
the <tt>shutdown()</tt> method called on the <tt>Object</tt> takes care of shutting
down an ORB.  In another implementation, the shutdown method implementation could 
have simply set a flag, which the server could have checked and called 
<tt>shutdown()</tt>.  

<P>The next set of code is used to get the object reference associated with the 
servant.  The <TT>narrow()</TT> method is required to cast CORBA 
<A href="../jidlGlossary.html#object reference">object references</A> to their 
proper types.

<P>
<PRE>
      org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
      Hello href = HelloHelper.narrow(ref);
</PRE>





<!--*********************************************-->

<A name="namingservice">
<H3>Working with COS Naming</H3></A>

<P>The <TT>HelloServer</TT> works with the Common Object Services (COS) Naming 
Service to make the servant object's operations available to clients.  The server
needs an object reference to the naming service so that it can publish the references
to the objects implementing various interfaces.  These object references are used by 
the
clients for invoking methods.  Another way a servant can make the objects available 
to 
clients for invocations is by stringifying the object 
references to a file.

<P>The two options for Naming Services shipped with J2SE v.1.4 are:
<P>
<UL>
	<LI><tt><a href="../orbd.html">orbd</a></tt>, which includes both a
	Transient Naming Service and a Persistent Naming Service, in addition
	to a Server Manager.
	<LI><tt><a href="../tnameserv.html">tnameserv</a></tt> - a Transient 
	Naming Service.
	</UL>
	
<P>This example uses <tt>orbd</tt>.


<A name="rootnc">
<H4>Obtaining the Initial Naming Context</H4></A>

<P>In the try-catch block, below getting the object reference for the servant, we 
call <TT>orb.resolve_initial_references()</TT> to get an object reference to the 
name server:

<PRE>
      org.omg.CORBA.Object objRef =
          orb.resolve_initial_references("NameService");
</PRE>

<P>The string "NameService" is defined for all CORBA ORBs. When you pass in 
that string, the ORB returns a naming context object that is an object reference
for the name service.  The string "NameService" indicates:
<P>
<UL>
<LI>The naming service will be persistent when using ORBD's naming service, as we
do in this example.
<LI>The naming service will be transient when using <tt>tnameserv</tt>.
</UL>
 
<P>The proprietary string "TNameService" indicates that the naming service will be
 transient when using ORBD's naming service.  

<A name="narrow">
<H4>Narrowing the Object Reference</H4></A>

<P>As with all CORBA object references, <TT>objRef</TT> is a generic CORBA 
object. To use it as a <TT>NamingContextExt object</TT>, you must narrow it to its 
proper type. The call to <TT>narrow()</TT> is just below the previous statement:

<PRE>
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
</PRE>

<P>Here you see the use of an <TT>idlj</TT>-generated helper class, similar in
function to <TT>HelloHelper</TT>. The <TT>ncRef</TT> object is now an 
<TT>org.omg.CosNaming.NamingContextExt</TT> and you can use it to access the naming 
service and register the server, as shown in the next topic.

<P>The <TT>NamingContextExt object</TT> is new to J2SE v.1.4, and is part of the <a 
href="../jidlNaming.html#INS">Interoperable 
Naming Service</a> specification.  


<A name="naming">
<H4>Registering the Servant with the Name Server</H4></A>


<P>Just below the call to <TT>narrow()</TT>, we  
create a new <TT>NameComponent</TT> array. Because the path to <TT>Hello</TT> has a 
single element, we create the single-element array that 
<TT>NamingContext.resolve</TT>
requires for its work:
<PRE>
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
</PRE>


<P>Finally, we pass <TT>path</TT> and the servant object to the naming service, 
binding the servant object to the "Hello" id:
<PRE>
      ncRef.rebind(path, href);
</PRE>

<P>Now, when the client calls <TT>resolve("Hello")</TT> on the initial naming
context, the naming service returns an object reference to the <TT>Hello</TT> 
servant.<P>




<!--**************************************-->
<A name="invoke">
<H3>Waiting for Invocation</H3></A>

<P>The previous sections describe the code that makes the server ready; the next 
section explains the code that enables it to simply wait around for a client to 
request its service.  The following code, which is at the end of (but within) the 
try-catch block, shows how to accomplish this.
<PRE>
      orb.run();
</PRE>

<P>When called by the main thread, <TT>ORB.run()</TT> enables the ORB to perform 
work using the main thread, waiting until an invocation comes from the ORB. 
Because of its placement in <TT>main()</TT>, after an invocation completes and 
<TT>sayHello()</TT> returns, the server will wait again.  This is the reason that 
the <code>HelloClient</code> explicitly shuts down the ORB after completing its 
task.


<HR>
<!--**************************************************-->
<A name="compile">
<H2>Compiling the Hello World Server</H2></A>

<P>Now we will compile the <TT>HelloServer.java</TT> so that we can correct any 
errors before continuing with this tutorial.

<P>Windows users note that you should substitute backslashes (\) for
the slashes (/) in all paths in this document.

<P>To compile <TT>HelloServer.java</TT>,
<OL>
<LI>Change to the <TT>Hello</TT> directory.<P>
<LI>Run the Java compiler on <TT>HelloServer.java</TT>:
<PRE>
javac HelloServer.java HelloApp/*.java
</PRE>
<LI>Correct any errors in your file and recompile if necessary. <p>

<LI>The files <TT>HelloServer.class</TT> and
<TT>HelloImpl.class</TT> are generated in the <TT>Hello</TT> directory.
</OL>

<A name="running">
<H3>Running the Hello World Server</H3></A>

<P>The document <A HREF="GScompile.html">Running the Hello World Application</A> 
discusses running <tt>HelloServer</tt> and the rest of the application.

<P>
<HR>
<P>
<!--**************************************-->
<A name="models">
<H1>Understanding The Server-Side Implementation Models</H1></a>




<P>CORBA supports at least two different server-side mappings for implementing an IDL 
interface:
<P>
<UL>
<LI>The Inheritance Model

<P>Using the Inheritance Model, you implement the IDL interface using an 
implementation class
that also extends the compiler-generated skeleton.  

<P>Inheritance models include:
<P>
	<UL>
	<LI>The OMG-standard, <em>POA</em>. Given an interface <tt>My</tt> defined in 
	<tt>My.idl</tt>, the file <tt>MyPOA.java</tt> is generated by the 
<tt>idlj</tt>
	 compiler. You must provide the implementation for <tt>My</tt> and it must 
inherit
	 from <tt>MyPOA</tt>, a stream-based skeleton that extends <a 
href="../../../api/org/omg/PortableServer/Servant.html">
<tt>org.omg.PortableServer.Servant</tt></A>, 
which serves as the base class for all POA servant implementations. 
	  
        <P><EM>New in J2SE v.1.4:</EM> The default 
server-side 
mapping generated when either the <tt>-fall</tt> or <tt>-fserver</tt>  
arguments are used conform to Chapter 11, <em>Portable Object Adapter</em> (POA) of 
the CORBA 2.3.1 Specification (<a 
href="http://cgi.omg.org/cgi-bin/doc?formal/99-10-07">formal/99-10-07</a>).  For
more information on the POA, link to <a href="../POA.html"><em>Portable Object 
Adapter</em></a>.


<P>The advantages of using the Portable Object Adaptor (POA) are:
<P>
<UL>
<LI>Allow programmers to construct object implementations that are portable between 
different ORB products.
<LI>Provide support for objects with persistent identities.
<LI>Provide support for transparent activation of objects.
<LI>Allow a single servant to support multiple object identities simultaneously.
</UL>
	<P>
	<LI><em>ImplBase</em>.  Given an interface <tt>My</tt> defined in 
<tt>My.idl</tt>, 
	the file <tt>_MyImplBase.java</tt> is generated. You must provide the 
implementation
	for <tt>My</tt> and it must inherit from <tt>_MyImplBase</tt>.
	
	<P><strong>NOTE: ImplBase is deprecated in favor of the POA model, but is 
provided to allow 
	compatibility with servers written in J2SE 1.3 and prior.  We do not 
recommend 
	creating new servers using this nonstandard model.</strong>
	
	</UL>
<P>
<LI>The Delegation Model

<P>Using the Delegation Model, you implement the IDL interface using two classes:
<P>
<UL>
<LI>An IDL-generated Tie class that inherits from the compiler-generated skeleton, 
but 
delegates all calls to an implementation class.
<LI>A class that implements the IDL-generated operations interface (such as 
<tt>HelloOperations</tt>), which defines the IDL function.<P>
</UL>

<P>The Delegation model is also known as the <em>Tie</em> model, or the Tie 
Delegation model. 
It inherits from either the POA or ImplBase compiler-generated skeleton, so the 
models will be 
described as POA/Tie or ImplBase/Tie models in this document.
</UL>

<P>This tutorial presents the POA Inheritance model for server-side implementation.  
For 
tutorials using the other server-side implementations, see the following documents:


<UL>
<P>

<LI><a href="../jidlTieServer.html"><em>Java IDL: The "Hello World" Example with
 the POA/Tie Server-Side Model</em></a>


<P>You might want to use the Tie model instead of the typical
Inheritance model if your implementation must inherit from some other
implementation. Java allows any number of interface inheritance, but
there is only one slot for class inheritance. If you use the inheritance
model, that slot is used up . By using the Tie Model, that slot is freed
up for your own use. The drawback is that it introduces a level of
indirection: one extra method call occurs when invoking a method.
<P>
<LI><a href="../jidlImplBaseServer.html"><em>Java IDL: The "Hello World" Example with the 
ImplBase 
Server-Side Model</em></a>
<P>The ImplBase server-side model is an Inheritance Model, as is the POA model.  Use 
the <tt>idlj</tt> compiler with the <tt>-oldImplBase</TT> flag to generate 
server-side 
bindings 
that 
are compatible with older version of Java IDL (prior to J2SE 1.4). 
<P><STRONG>Note that using the <tt>-oldImplBase</TT> flag is 
non-standard: these APIs are being deprecated.  You would use this flag ONLY for 
compatibility 
with existing servers written in J2SE 1.3 or earlier.  In that case, you would need 
to modify 
an existing MAKEFILE to add the <tt>-oldImplBase</TT> flag to the <tt>idlj</tt> 
compiler, 
otherwise POA-based server-side mappings will be generated.  </STRONG>
<P>

</UL>







<HR>
<!--**************************************-->
<A name="information">
<H2>For More Information</H2></A>

<DL>
<DT><A href="../jidlExceptions.html#systemexceptions"><em>Exceptions: System 
Exceptions</em></A>
<DD>Explains how CORBA system exceptions work and provides details on the
minor codes of Java&nbsp;IDL's system exceptions

<DT><A href="../jidlServers.html"><em>Developing Servers</em></A>
<DD>Covers topics of interest to CORBA server programmers

<DT><A href="../jidlNaming.html"><em>Java IDL Naming Service</em></A>
<DD>Covers the COS Naming Service in greater detail

</DL>

<P><HR>
<CENTER><P><A href="GSIDL.html">Previous: <em>Writing the Interface Definition</em></A> 
<BR>
<A href="GSapp.html">Next: <em>Developing a Client Application</em></A> <BR> 
<A href="../GShome.html">Tutorial home</A>

<TABLE summary="layout" cellpadding=8 cellspacing=4>
<TR>
  <TD ALIGN=CENTER><A href="../index.html">
Java IDL Home</A></TD>
</TR></TABLE>

<HR>
<FONT
SIZE="-2"><A HREF="http://www.sun.com/share/text/SMICopyright.html">Copyright
&copy;</A> 1996-2001 Sun Microsystems, Inc.,
2550 Garcia Ave., Mtn. View, CA. 94043-1100 USA., All rights
reserved.</FONT></P></CENTER>

</BODY>
</HTML>


