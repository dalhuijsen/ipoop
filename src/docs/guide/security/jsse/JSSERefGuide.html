<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta name="Author" content="Jeff Nisewanger, Mary Dageforde, Brad Wetmore">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (Win98; U) [Netscape]">
   <title>JSSE Reference Guide for the J2SDK, v 1.4.2</title>
   <!-- Changed by: Alison Huml, 11-Feb-03-->
   <!-- Changed by: Alison Huml, 05-Nov-02-->
   <!-- Changed by: Alison Huml, 07-May-02 -->
   <!-- Changed by: Mary Dageforde, 11-Oct-01 -->
   <!-- Changed by: Brad Wetmore, 20-Jul-00 -->
   <!-- Changed by: Ann Wollrath - SMI Software Development, 15-Jan-2002 -->
</head>
<BODY BGCOLOR="#ffffff">

<hr WIDTH="100%">

<center>

<H1>Java<SUP><FONT SIZE=-2>TM</FONT></SUP> Secure Socket Extension
(JSSE)</H1>

<H1>Reference Guide</H1>

<H2>for the Java<SUP><FONT SIZE=-2>TM</FONT></SUP> 2 SDK, Standard Edition, 
v 1.4.2</H2>

</center>


<hr WIDTH="100%">

<p><dl>

<dt><dd><a href="#Introduction">
<font size="+1"><b>Introduction</b></font></a>
<dl>

<dt><dd><a href="#Features">
<font size="+1"><b>Features and Benefits</b></font></a>

<dt><dd><a href="#StandardAPI">
<font size="+1"><b>JSSE Standard API</b></font></a>

<dt><dd><a href="#SunJSSE">
<font size="+1"><b>SunJSSE Provider </b></font></a>

<dt><dd><a href="#WhatsNew">
<font size="+1"><b>What's New</b></font></a>
<dl>
  <dt><dd><a href="#WhatsNew1.4.2">
  <B>What's New in JSSE in the Java 2 SDK, v 1.4.2</B></a>
  <dt><dd><a href="#WhatsNew1.4">
  <B>What's New in JSSE in the Java 2 SDK, v 1.4</B></a>
</dl>

<dt><dd><a href="#RelatedDocs">
<font size="+1"><b>Related Documentation</b></font></a>

</dl>
<br>

<dt><dd><a href="#Terms">
<font size="+1"><b>Terms and Definitions</b></font></a>

<br>
<br>

<dt><dd><a href="#SSLOverview">
<font size="+1"><b>Secure Sockets Layer (SSL) Protocol Overview</b></font></a>
<dl>

<dt><dd><a href="#WhySSL">
<font size="+1"><b>Why Use SSL?</b></font></a>

<dt><dd><a href="#HowSSLWorks">
<font size="+1"><b>How SSL Works</b></font></a>

</dl>
<br>

<dt><dd><a href="#KeyClasses">
<font size="+1"><b>Key Classes</b></font></a>
<dl>

<dt><dd><a href="#ClassRelationship">
<font size="+1"><b>Relationship Between Classes</b></font></a>


<dt><dd><a href="#CoreClasses">
<font size="+1"><b>Core Classes and Interfaces</b></font></a>
<dl>

<dt><dd><a href="#SocketFactory">
<b>SocketFactory and ServerSocketFactory Classes</b></a>
<dt><dd><a href="#SSLSocket">
<b>SSLSocket and SSLServerSocket Classes</b></a>
<dt><dd><a href="#SSLSocketFactory">
<b>SSLSocketFactory and SSLServerSocketFactory Classes</b></a>
<dt><dd><a href="#SSLSession">
<b>SSLSession Interface</b></a>
<dt><dd><a href="#HttpsURLConnection">
<b>HttpsURLConnection Class</b></a>
</dl>

<dt><dd><a href="#SupportClasses">
<font size="+1"><b>Support Classes and Interfaces</b></font></a>
<dl>

<dt><dd><a href="#SSLContext">
<b>SSLContext Class</b></a>
<dt><dd><a href="#TrustManager">
<b>TrustManager Class</b></a>

<dt><dd><a href="#TrustManagerFactory">
<b>TrustManagerFactory Class</b></a>
<dt><dd><a href="#X509TrustManager">
<b>X509TrustManager Interface</b></a>
<dt><dd><a href="#KeyManager">
<b>KeyManager Class</b></a>
<dt><dd><a href="#KeyManagerFactory">
<b>KeyManagerFactory Class</b></a>
<dt><dd><a href="#X509KeyManager">
<b>X509KeyManager Interface</b></a>
<dt><dd><A HREF="#RelsTM_KM">
<b>Relationships between TrustManagers and KeyManagers</b></a>
</dl>


<dt><dd><a href="#SecondarySupportClasses">
<font size="+1"><b>Secondary Support Classes and Interfaces</b></font></a>
<dl>

<dt><dd><a href="#SSLSessionContext">
<b>SSLSessionContext Interface</b></a>
<dt><dd><a href="#SSLSessionBindingListener">
<b>SSLSessionBindingListener Interface</b></a>
<dt><dd><a href="#SSLSessionBindingEvent">
<b>SSLSessionBindingEvent Class</b></a>
<dt><dd><a href="#HandShakeCompletedListener">
<b>HandShakeCompletedListener Interface</b></a>
<dt><dd><a href="#HandShakeCompletedEvent">
<b>HandShakeCompletedEvent Class</b></a>
<dt><dd><a href="#HostnameVerifier">
<b>HostnameVerifier Interface</b></a>
<dt><dd><a href="#X509Certificate">
<b>X509Certificate Class</b></a>
</dl>

<dt><dd><a href="#ConfigurationClasses">
<font size="+1"><b>Previous (JSSE 1.0.x) Implementation Classes and 
Interfaces</b></font></a>
</dl>

<br>


<dt><dd><a href="#InstallationAndCustomization">
<font size="+1"><b>Customizing JSSE </b></font></a>
<dl>

<dt><dd><a href="#javaHome">
<font size="+1"><b>The Installation Directory &lt;java-home&gt;</b></font></a>

<dt><dd><a href="#Customization">
<font size="+1"><b>Customization</b></font></a>
</dl>

<br>


<dt><dd><a href="#KeystoreFormats">
<font size="+1"><b>Additional Keystore Formats</b></font></a>
<br>
<br>


<dt><dd><a href="#Troubleshooting">
<font size="+1"><b>Troubleshooting</b></font></a>
<dl>

<dt><dd><a href="#InstallProbs">
<font size="+1"><b>Configuration Problems</b></font></a>
<dt><dd><a href="#Debug">
<font size="+1"><b>Debugging Utilities</b></font></a>
</dl>

<br>


<dt><dd><a href="#CodeExamples">
<font size="+1"><b>Code Examples</b></font></a>
<dl>
<dt><dd><a href="#UnsecureSecure">
<font size="+1"><b>Converting an Unsecure Socket to a Secure Socket</b></font></a>
<dt><dd><a href="#SampleCode">
<font size="+1"><b>Running the JSSE Sample Code</b></font></a>
<dt><dd><a href="#CreateKeystore">
<font size="+1"><b>Creating a Keystore to Use with JSSE</b></font></a>
</dl>


<br>


<dt><dd><a href="#AppA">
<font size="+1"><b>Appendix A: Standard Names</b></font></a>
</dl>



<hr WIDTH="100%">
<a name="Introduction"></a>
<h1>Introduction</h1>

<blockquote>

Data that travels across a network can easily be accessed by someone who
is not the intended recipient. When the data includes private information,
such as passwords and credit card numbers, steps must be taken to make
the data unintelligible to unauthorized parties. It is also important to
ensure the data has not been modified, either intentionally
or unintentionally, during transport. The Secure Sockets
Layer (SSL) and Transport Layer Security (TLS) protocols were designed
to help protect the privacy and integrity of data while it is
transferred across a network.

<P> The Java Secure Socket Extension (JSSE)
enables secure Internet communications. It provides a framework
and an implementation for a Java version of the SSL and TLS
protocols and includes functionality for data encryption, server
authentication, message integrity, and optional client authentication.
Using JSSE, developers can provide for the secure passage of data
between a client and a server running any application protocol,
such as Hypertext Transfer Protocol (HTTP), Telnet, or FTP,
over TCP/IP. (For an introduction to SSL, see
<A HREF="#SSLOverview">Secure Sockets Layer (SSL) Protocol Overview</A>.)

<P> By abstracting the complex underlying
security algorithms and &quot;handshaking&quot; mechanisms, JSSE
minimizes the risk of creating subtle, but dangerous security
vulnerabilities. Furthermore, it simplifies application development
by serving as a building block which developers can integrate
directly into their applications.

<p>JSSE was previously an optional package (standard extension) to the
Java<SUP><FONT SIZE=-2>TM</FONT></SUP> 2 SDK, Standard Edition
(J2SDK) versions 1.2 and 1.3. JSSE has now been integrated into 
the J2SDK, v 1.4.

<P> JSSE provides both an application programming interface (API)
framework and an implementation of that API.
The JSSE API supplements the "core" cryptographic services defined in 
the Java 2 SDK, v 1.4 <code>java.security</code> and <code>java.net</code> 
packages by providing extended networking socket classes, 
trust managers, key managers, SSLContexts, and a socket 
factory framework for encapsulating socket creation behavior. (It also provides 
a limited public key certificate API that is compatible with  
Java Development Kit (JDK) 1.1-based platforms. However, please note that 
this limited <code>javax.security.cert</code> certificate API 
is provided only for backward compatibility with 
JSSE 1.0.x and should not be used. Instead, use the standard 
<code>java.security.cert</code> certificate API.)

<P> The JSSE API is
capable of supporting SSL versions 2.0 and 3.0 and Transport Layer
Security (TLS) 1.0. These security protocols encapsulate a normal
bidirectional stream socket and the JSSE API adds
transparent support for authentication, encryption, and
integrity protection. The JSSE implementation in the J2SDK, v 1.4 implements
SSL 3.0 and TLS 1.0. It does not implement SSL 2.0.

<P> As mentioned above, JSSE is a security component of the
Java 2 platform, and is based on the same <a
href="../CryptoSpec.html#Design">design principles</a> found
elsewhere in the Java Cryptography Architecture (JCA)
framework.  This framework for cryptography-related 
security components allows them to have implementation independence and,
whenever possible, algorithm independence. JSSE uses the same "<a
href="../CryptoSpec.html#ProviderArch">provider</a>"
architecture defined in the JCA.

<P> Other security components in the Java 2 platform include the
Java Cryptography Extension (<A
href="http://java.sun.com/products/jce/">JCE</A>), the Java
Authentication and Authorization Service (<A
href="http://java.sun.com/products/jaas/">JAAS</A>), and the <A
href="../../../tooldocs/tools.html#security">
Java Security Tools</A>.  JSSE encompasses many of the same
concepts and algorithms as those in JCE but automatically applies them
underneath a simple stream socket API.

<P>The JSSE APIs were designed to allow other SSL/TLS protocol 
and Public Key Infrastructure (PKI) implementations to be 
plugged in seamlessly. Developers can also provide alternate 
logic for determining if remote hosts should be trusted 
or what authentication key material should be sent to a remote host. 


<A NAME="pluggabilityNote"></A>
<blockquote>
<HR>
<b>
Note:</B>
 While the JSSE APIs allow  
the replacement of the underlying implementations (also known as "pluggability"), 
due to U.S. export restrictions this release does not permit you to replace the SSL/TLS 
algorithms. The <code>TrustManagerFactory</code> and <code>KeyManagerFactory</code> are 
still fully pluggable. 
</b>
<HR>
</blockquote>

<a name="Features"></a>
<H2>Features and Benefits</H2>

<blockquote>

<P> JSSE includes the following important features:

<ul>
<li>Implemented in 100% Pure Java<P>

<li>Can be exported to most countries<P>

<li>Provides API support for SSL versions 2.0 and 3.0, and
implementation of SSL version 3.0<P>

<li>Provides API support and an implementation for TLS version 1.0<P>

<li>Includes classes that can be instantiated to create secure
channels (<code>SSLSocket</code> and <code>SSLServerSocket</code>)<P>

<li>Provides support for <a href="#CipherSuite">cipher suite</a> negotiation,
which is part of the SSL handshaking used to initiate or verify
secure communications<P>

<li>Provides support for client and server authentication,
which is part of the normal SSL handshaking
<P>

<li>Provides support for Hypertext Transfer Protocol (HTTP)
encapsulated in the SSL protocol (HTTPS), which allows
access to data such as web pages using HTTPS
<P>

<li>Provides server session management APIs to manage
memory-resident SSL sessions
<P>

<li>Includes code licensed from RSA Data Security Inc. 
such as RSA and RC4
<P>

<li>Provides support for several cryptographic algorithms commonly
used in cipher suites, including those
listed in the following table:

</ul>
<p>

<TABLE BORDER CELLSPACING=1 CELLPADDING=7>
<CAPTION>
<H3 CLASS="TableTitle">
Cryptographic Functionality Available With JSSE</H3>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
Cryptographic Algorithm *
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
Cryptographic Process
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
Key Lengths (Bits)
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>RSA
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Authentication and key exchange
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>2048 (authentication)<BR>
2048 (key exchange)<BR>
&nbsp;&nbsp;512 (key exchange)
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>RC4
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Bulk encryption
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>128<BR>
128 (40 effective)
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>DES
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Bulk encryption
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>64 (56 effective)<BR>
64 (40 effective)
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Triple DES
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Bulk encryption
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>192 (112 effective)
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Diffie-Hellman
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Key agreement
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>1024<BR>
&nbsp;&nbsp;512
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>DSA
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>Authentication
</TD>
<TD ROWSPAN="1" COLSPAN="1" VALIGN="TOP">
<P>1024
</TD>
</TR>
</TABLE>


<P>* Note: The cryptographic algorithms shipped in the SunJSSE provider
are not registered with the Java Cryptography Architecture
(JCA) provider framework, and are not available for use by
other applications.

<P>** Note: The SunJSSE implementation uses the 
Java<SUP><FONT SIZE ="-2">TM</FONT></SUP> 
Cryptography Extension (JCE) AES cipher
for AES-based ciphersuites.  

<br>
<br>
<br>

</blockquote>


<a name="StandardAPI"></a>
<H2>JSSE Standard API</H2>

<blockquote>

<P> The JSSE standard API, available in the
<code>javax.net</code>, <code>javax.net.ssl</code> and
<code>javax.security.cert</code> packages, covers:

<ul>

<li>Secure (SSL) sockets and server sockets.<P>

<li>Factories for creating sockets, server sockets,
SSL sockets, and SSL server sockets.
Using socket factories you can encapsulate socket creation
and configuration behavior.<P>

<li>A class representing a secure socket context 
that acts as a factory for secure socket factories.<p>

<li>Key and trust manager interfaces
(including X.509-specific key and trust managers), and
factories for creating them.<p>

<li>A class for secure HTTP URL connections.<p>

<li>A public key certificate API compatible with
JDK 1.1-based platforms.

</ul>

</blockquote>



<a name="SunJSSE"></a>
<H2><code>SunJSSE</code> Provider </H2>

<blockquote>

<p>The J2SDK, v 1.4 release comes with a JSSE 
provider named "<code>SunJSSE</code>", which comes pre-installed and
pre-registered with the JCA. This provider supplies the following 
cryptographic services:

<ul>
<li>
RSA support for the signature-related JCA features
of the Java 2 platform.</li><P>

<li>
An implementation of the SSL 3.0 and TLS 1.0 security protocols.</li><P>

<li>
An implementation of the most common SSL and TLS cipher suites
which encompass a combination of authentication, key agreement,
encryption and integrity protection.</li><P>

<li>
An implementation of an X.509-based key manager which chooses appropriate
authentication keys from a standard JCA KeyStore.</li><P>

<li>
An implementation of an X.509-based trust manager which implements 
rules for certificate chain path validation.</li><P>

<li>
A read-only implementation of PKCS12 as JCA keystore type "pkcs12".</li>

</ul>

The following table lists the cipher suites that <code>SunJSSE</code> supports 
and those that are enabled by default.

<P><TABLE summary="Supported Cipher Suites in Default Preference Order" WIDTH="600" BORDER="1" CELLSPACING="2" CELLPADDING="0" HEIGHT="760">
  <TR>
    <TD COLSPAN="3" BGCOLOR="#dedeef" HEIGHT="34">
    <B>Supported Cipher Suites in Default Preference Order</B></TD>
     
  </TR>
  <TR>
    <TH WIDTH="71%" HEIGHT="42">
    &nbsp;<B>Name</B></TH> 
    <TH WIDTH="14%" HEIGHT="42">
    <B>Enabled by Default</B></TH> 
    <TH WIDTH="15%" HEIGHT="42">
    <B>New in <BR>
    J2SE 1.4.2</B></TH> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_RC4_128_MD5</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_RC4_128_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_RSA_WITH_AES_128_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DHE_RSA_WITH_AES_128_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DHE_DSS_WITH_AES_128_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_3DES_EDE_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_DES_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_RSA_WITH_DES_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_DSS_WITH_DES_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_EXPORT_WITH_RC4_40_MD5</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_EXPORT_WITH_DES40_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_RSA_WITH_AES_256_CBC_SHA <A
    HREF="#requirements">*</A></FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DHE_RSA_WITH_AES_256_CBC_SHA
    <A HREF="#requirements">*</A></FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DHE_DSS_WITH_AES_256_CBC_SHA
    <A HREF="#requirements">*</A></FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    X&nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_NULL_MD5</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_RSA_WITH_NULL_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DH_anon_WITH_RC4_128_MD5</FONT></TT></TD> 
    <TD WIDTH="14%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
    <TD WIDTH="15%" ALIGN="CENTER" HEIGHT="23">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DH_anon_WITH_AES_128_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">TLS_DH_anon_WITH_AES_256_CBC_SHA
    <A HREF="#requirements">*</A></FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;X</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DH_anon_WITH_3DES_EDE_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DH_anon_WITH_DES_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DH_anon_EXPORT_WITH_RC4_40_MD5</FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
  </TR>
  <TR>
    <TD WIDTH="71%" HEIGHT="23">
    &nbsp;<TT><FONT FACE="Courier">SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA</FONT></TT></TD> 
    <TD WIDTH="14%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
    <TD WIDTH="15%" HEIGHT="23" ALIGN="CENTER">
    &nbsp;</TD> 
  </TR>
</TABLE>

<a name="requirements"></a>
<BLOCKQUOTE>
  <P><B>* </B>Requires installation of the JCE Unlimited Strength
  Jurisdiction Policy Files. 
  See <A HREF="http://java.sun.com/j2se/1.4.2/download.html">http://java.sun.com/j2se/1.4.2/download.html</A>
</BLOCKQUOTE>
</BLOCKQUOTE>

<a name="WhatsNew"></a>
<H2>What's New</H2>
<blockquote>

This section highlights the differences between the JSSE
in releases 1.4.2 and 1.4 of the Java 2 Platform and earlier
releases.  

<blockquote>
<a name="WhatsNew1.4.2"></a>
<H3>What's New in JSSE in the J2SDK, v 1.4.2</H3>

<blockquote>
The following changes were introduced in the JSSE in 
version 1.4.2 of the Java 2 platform:
<UL>
<LI>The SunJSSE implementation now supports a number of 
additional ciphersuites. They include ciphersuites 
using AES as a symmetric cipher and ephemeral 
Diffie-Hellman with RSA authentication (DHE_RSA). 
For more information, see the table of "Supported
Cipher Suites" in the section 
<A HREF="#SunJSSE"><code>SunJSSE</code> Provider</A>.
</LI>
<P>
<LI>In addition to the simple X.509 based trustmanager 
previously available in the SunJSSE provider, it now 
supports a second, PKIX-compliant trust manager. 
It is implemented using the default CertPath PKIX 
implementation. For more information, see the section 
<A HREF="#TrustManagerFactory"><code>TrustManagerFactory</code> Class</A>.
</LI>
</UL>

</blockquote>

<a name="WhatsNew1.4"></a>
<H3>What's New in JSSE in the J2SDK, v 1.4</H3>

<blockquote>

<P> Here are the differences between JSSE 1.0.2 and the JSSE in 
the J2SDK, v 1.4:

<ul>
<li><a href="#InJ2">JSSE Is Now in J2SDK</a><P>
<li><a href="#DontUsejxCert"><code>javax.security.cert</code> Should Not 
Be Used</a><P>
<li><a href="#UseJCEPr">SunJSSE Provider Can Use JCE Providers for 
Encryption</a><P>
<li><a href="#comTojavax">Classes Formerly in <code>com.sun.net.ssl</code> Are Now in 
javax.net.ssl</a><P>
<li><a href="#NewMethods">New Methods and Interface</a><P>
<li><a href="#ChangedMethods">Changed Classes and Methods</a><P>
<li><a href="#DocChanges">Documentation Improvements</a>
</ul>


<H3><a name="InJ2">JSSE Is Now in J2SDK</a></H3>

<blockquote>

<p>JSSE was previously an optional package (extension) to the
Java<SUP><FONT SIZE=-2>TM</FONT></SUP> 2 SDK, Standard Edition
(J2SDK), versions 1.2 and 1.3. JSSE has now been integrated into the 
J2SDK, v 1.4. The SunJSSE provider is also included and is 
pre-registered in the <code>java.security</code> security properties file
included with the J2SDK, v 1.4.

</blockquote>


<H3><a name="DontUsejxCert"><code>javax.security.cert</code> Should Not 
Be Used</a></H3>

<blockquote>

<p>JSSE was developed before the <code>java.security.cert</code> package
was widely available, so a supplemental certificate package was
introduced in earlier versions of JSSE called <code>javax.security.cert</code>.
JSSE is now bundled into the J2SDK itself and takes advantage
of the more complete certificate API available in the
<code>java.security.cert</code> package.
All new applications should use <code>java.security.cert</code>.
The <code>javax.security.cert</code> package exists only for backward
compatibility with previous JSSE releases, and should no longer be used.

</blockquote>


<a name="UseJCEPr"></a>
<H3>SunJSSE Provider Can Use JCE Providers for Encryption</H3>

<blockquote>

<p>The SunJSSE provider can now make use of JCE providers for encryption algorithms. Previously, SunJSSE always made use of internal implementations for encryption algorithms. Now implementations from providers with a higher preference order than SunJSSE are used if available. See
<a href="#JCECust">Customizing the Encryption Algorithm Providers</a>
for more information. 

</blockquote>


<H3><a name="comTojavax">Classes Formerly in com.sun.net.ssl Are Now in 
javax.net.ssl</a></H3>

<blockquote>

<p>All of the classes and interfaces formerly (in JSSE 1.0.x) in the
<code>com.sun.net.ssl</code> package have been promoted to the 
<code>javax.net.ssl</code> package.
The old <code>com.sun.net.ssl</code> classes and interfaces still
exist and are unchanged, but are included in the SunJSSE provider
only for backward compatibility. What is provided is actually
"wrappers" that reference the new <code>javax.net.ssl</code> classes/interfaces.

<p>The implementation now uses <code>javax.net.ssl.SSLPermissions</code> 
rather than <code>com.sun.net.ssl.SSLPermission</code>, so any policy files 
that used to mention <code>com.sun.net.ssl.SSLPermission</code> should now use
<code>javax.net.ssl.SSLPermissions</code> instead.

</blockquote>


<H3><a name="NewMethods">New Methods and Interfaces</a></H3>

<blockquote>

New methods <code>setWantClientAuth</code> and 
<code>getWantClientAuth</code> were added to <code>SSLSocket</code> 
and <code>SSLServerSocket</code> (in <code>javax.net.ssl</code>) 
to enable optional client authentication.  

<P>
The method <code>SSLContext.getInstance(protocol)</code> returns 
socket factories which support <i>at least</i> the specified protocol.  
New methods <code>setEnabledProtocols</code> and 
<code>getEnabledProtocols</code> were added to 
<code>SSLSocket</code> and <code>SSLServerSocket</code> to further 
refine which protocols are enabled for use on this connection.  
Another new method <code>getSupportedProtocols</code> was added to 
<code>SSLSocket</code> and <code>SSLServerSocket</code>; 
<code>getSupportedProtocols</code> can be used to obtain the 
protocol versions that can be enabled for use on an SSL connection.  
The new method <code>getProtocol</code> was added to 
<code>SSLSession</code> for retrieving the standard name of the 
protocol used in the session.

<p><code>SocketFactory</code> and <code>ServerSocketFactory</code> 
have new methods <code>createSocket</code> and <code>createServerSocket</code>,
respectively, for creating unconnected sockets.

<p>New methods <code>getServerSessionContext</code> and 
<code>getClientSessionContext</code> were added to <code>SSLContext</code>.
They allow the developer to obtain the set of SSL client or server sessions 
available for reuse during handshaking.

<p>New methods <code>setSessionTimeout</code> and <code>getSessionTimeout</code>
were added to <code>SSLSessionContext</code>. They allow the developer to 
control when sessions timeout and become invalid.  New methods
<code>setSessionCacheSize</code> and <code>getSessionCacheSize</code> were 
also added to control how many sessions should be cached for reuse
by future connections.

<p>New methods were added 
to <code>HttpsURLConnection</code>, <code>SSLSession</code>, and 
<code>HandshakeCompletedEvent</code> (all in <code>javax.net.ssl</code>)
that allow you to get generic Java 2
<code>java.security.cert.Certificate</code> certificates in addition to the 
<code>javax.security.cert.X509Certificate</code> certificates returned by 
previously-existing methods. 
The new methods are 

<blockquote>
<pre>
SSLSession.getPeerCertificates
HandshakeCompletedEvent.getPeerCertificates
HttpsURLConnection.getServerCertificates
</pre>
</blockquote>

<p>A <code>getLocalCertificates</code> method was added to  
<code>SSLSession</code>, <code>HandshakeCompletedEvent</code>, and 
<code>HttpsURLConnection</code>.
This method returns the certificate(s) that were sent to the peer
during handshaking. This provides a way to determine what
certificate chain was actually used to authenticate the local
side of a given SSL session.

<p>A new interface <code>ManagerFactoryParameters</code> was
added as a base interface that providers can extend
if they need <code>KeyManagerFactory</code> and/or 
<code>TrustManagerFactory</code> initialization parameters 
other than the ones that can be passed to the KeyStore-based <code>init</code> 
methods of those classes. The <code>KeyManagerFactory</code> and 
<code>TrustManagerFactory</code> classes each have a new
<code>init</code> method that takes a <code>ManagerFactoryParameters</code> 
argument. Users of a particular provider are expected to pass an
implementation of the appropriate <code>ManagerFactoryParameters</code> 
as defined by the provider. 

</blockquote>


<H3><a name="ChangedMethods">Changed Classes and Methods</a></H3>

<blockquote>

<P>When the <code>com.sun</code> APIs were prepared 
for inclusion in the <code>javax</code> namespace, some API 
limitations were corrected in the <code>javax</code> 
version.  The old <code>com.sun.*</code> APIs found in the previous JSSE
optional packages are still the same and have not changed. <B>The
changes described in the paragraphs below only apply to the new
<code>javax.*</code> classes of the same name.</B>

<p>The <code>HttpsURLConnection</code> constructor has been changed to be 
protected. This was done for consistency with other similar classes such as 
<code>URLConnection</code>, <code>JarURLConnection</code>, and 
<code>HttpURLConnection</code>, all in the <code>java.net</code> package.
Another change to the <code>HttpsURLConnection</code> class is that
the method that returned
<code>javax.security.cert</code> certificates was removed. 

<p>Hostname verification has been redone to be more generic.
The negotiated <code>SSLSession</code> is now passed to the verifier's 
<code>verify</code> method instead of the hostname contained in the received 
certificates. The <code>SSLSession</code> can then be queried for the negotiated
ciphersuite, the exchanged certificates, and so on.

<p>The <code>X509TrustManager isClientTrusted</code> and 
<code>isServerTrusted</code> methods were renamed 
<code>checkClientTrusted</code> and <code>checkServerTrusted</code>, 
respectively. If the certificate chain is not trusted by this 
<code>TrustManager</code>, the <code>checkClientTrusted</code> and 
<code>checkServerTrusted</code> methods throw an exception rather than 
return a <code>boolean</code> (like the former methods did).  
This allows implementations to ascertain the underlying cause for 
failure of the trust decision. 
The checks done by <code>checkClientTrusted</code> and 
<code>checkServerTrusted</code>
include verifying that the certificate is used for an operation that
complies with the certificate's key usage extension. To properly
perform this check, it is necessary to pass the authentication type to
these methods, and so a <code>String authType</code> argument has been added.

<p>One parameter has been added and one changed for the
<code>X509KeyManager chooseClientAlias</code> 
and <code>chooseServerAlias</code> methods. A <code>Socket socket</code>
parameter was added to both methods for specifying the socket to be used 
for the connection.
The <code>keytype</code> parameter for the <code>chooseClientAlias</code> method
was changed from a single String
to an array of Strings specifying the key algorithm type name(s), 
ordered with the most-preferred type first.
For example, the <code>chooseClientAlias</code> method signature
used to be

<blockquote>
<pre>
  chooseClientAlias(String keyType, Principal[] issuers)
</pre>
</blockquote>

and now it is

<blockquote>
<pre>
  chooseClientAlias(String[] keyType, Principal[] issuers, 
                    Socket socket)
</pre>
</blockquote>

The parameters help decide which certificate(s) to use when
connecting to a remote host.

<p>The default key manager factory algorithm name has been changed
from <code>sun.ssl.keymanager.type</code> to 
<code>ssl.KeyManagerFactory.algorithm</code>. Similarly, the
default trust manager factory algorithm name has been changed
from <code>sun.ssl.trustmanager.type</code> to 
<code>ssl.TrustManagerFactory.algorithm</code>.

</blockquote>


<H3><a name="DocChanges">Documentation Improvements</a></H3>

<blockquote>

<P> This JSSE Reference Guide was updated and expanded.

<p>There were a number of minor clarifications made to the
JSSE javadocs, primarily when discussing illegal arguments
and implied behavior.

</blockquote>
</blockquote>
</blockquote>
</blockquote>

<a name="RelatedDocs"></a>
<H2>Related Documentation </H2>

<blockquote>

<H3>Java Secure Socket Extension Documentation</H3>

<ul>

<LI>The JSSE home page, with links to JavaOne<SUP><FONT SIZE=-2>SM</FONT></SUP>
conference slides, the JSSE FAQ, legal issues, etc.: <BR>
<EM>
<A HREF="http://java.sun.com/products/jsse/">
http://java.sun.com/products/jsse/</A>
</EM>
</LI><P>

<LI>Archive of API-related questions and answers posted to Sun's Java Security
team through <EM> java-security@sun.com</EM>:<BR>
<EM>
<A HREF="http://archives.java.sun.com/archives/java-security.html">
http://archives.java.sun.com/archives/java-security.html</A>
</EM>

<p>Note: The above mailing list is not a subscription list
or a support mechanism. It is simply a one-way channel that you
can use to send comments to the Java 2 Standard Edition security team.
</LI><P>

<LI>JSSE API documentation:<BR>

<EM>
   <ul>
   <li><a href="../../../api/javax/net/package-summary.html">javax.net
package</a>
   <li><a href="../../../api/javax/net/ssl/package-summary.html">
javax.net.ssl package</a>
   <li><a href="../../../api/javax/security/cert/package-summary.html">
javax.security.cert package</a>
   </ul><p>
</EM>
</LI><P>

</UL>


<H3>
Java 2 Platform Security Documentation</H3>

<UL>

<LI>Java 2 security homepage:<BR>
<EM>
<A HREF="http://java.sun.com/security/">
http://java.sun.com/security/</A>
</EM>
</LI><P>

<LI> The Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 
Certification Path API Programmer's Guide:<BR>
<EM>
<a href="../certpath/CertPathProgGuide.html">
http://java.sun.com/j2se/1.4.2/docs/guide/security/certpath/CertPathProgGuide.html</A>
</EM>
</LI>
<P>

<LI>Links to more Java 2 platform security documents:<BR>
<EM>
<A HREF="../index.html">
http://java.sun.com/j2se/1.4.2/docs/guide/security/</A>
</EM>
</LI>
<P>

<LI>Tutorial for Java 2 platform security:<BR>
<EM>
<A HREF="http://java.sun.com/docs/books/tutorial/security1.2/">
http://java.sun.com/docs/books/tutorial/security1.2/</A>
</EM>
</LI><P>

<LI>Book on Java 2 platform security:<BR>
<EM>
Inside Java 2 Platform Security: Architecture, API Design, and
Implementation</EM>
 by Li Gong. Addison Wesley Longman, Inc., 1999. ISBN: 0201310007.
</LI>

</UL>


<H3>Export Issues Related to Cryptography</H3>

<blockquote>

<P>
For information on U.S. encryption policies, refer to these Web sites:

<UL>

<LI>U.S. Department of Commerce: <BR>
<EM>
<A HREF="http://www.doc.gov/">
http://www.doc.gov/</A>
</EM>
</LI><P>

<LI>Export Policy Resource Page: <BR>
<EM>
<A HREF="http://www.crypto.com/">
http://www.crypto.com/</A>
</EM>
</LI><P>

<LI>Computer Systems Public Policy: <BR>
<EM>
<A HREF="http://www.cspp.org/">
http://www.cspp.org/</A>
</EM>
</LI><P>

<LI>Federal Information Processing Standards Publications (FIPS PUBS)
homepage, which has links to the Data Encryption Standard (DES):<BR>
<EM>
<A HREF="http://www.itl.nist.gov/fipspubs/">
http://www.itl.nist.gov/fipspubs/</A>
</EM>
</LI><P>

<LI>Revised U.S. Encryption Export Control Regulations:<BR>
<EM>
<A HREF="http://www.epic.org/crypto/export_controls/regs_1_00.html">
http://www.epic.org/crypto/export_controls/regs_1_00.html</A>
</EM>
</LI>

</UL>

</blockquote>


<a name="CryptDocs"></a>
<H3>Cryptography Documentation</H3>

<blockquote>
<P>Online resources:

<UL>
<LI>Dr. Rivest's Cryptography and Security page: <BR>
<EM>
<A HREF="http://theory.lcs.mit.edu/~rivest/crypto-security.html">
http://theory.lcs.mit.edu/~rivest/crypto-security.html</A>
</EM>
</LI>
</UL>

<P>
Books:
<UL>
<LI>
<EM>Applied Cryptography, Second Edition</EM> by Bruce Schneier.
John Wiley and Sons, Inc., 1996.</LI>
<P>

<LI>
<EM>Cryptography Theory and Practice</EM> by Doug Stinson.
CRC Press, Inc., 1995.</LI>
<P>

<LI>
<EM>Cryptography & Network Security: Principles & Practice</EM> by William Stallings.
Prentice Hall, 1998.</LI>
<P>

</UL>

</blockquote>

<a name="SSLDocs"></a>
<H3>Secure Sockets Layer Documentation</H3>

<blockquote>

<P>Online resources:

<UL>

<LI>Documentation from Netscape about SSL: <BR>
<EM>
<A HREF="http://developer.netscape.com/docs/manuals/security.html#SSL">
http://developer.netscape.com/docs/manuals/security.html#SSL</A>
</EM>
</LI><P>

<LI>Introduction to SSL from Sun&#153; ONE Software (formerly 
known as iPlanet): <BR>
<EM>
<A HREF="http://www.iplanet.com/developer/docs/articles/security/ssl.html">
http://www.iplanet.com/developer/docs/articles/security/<BR>
ssl.html</A>
</EM>
</LI><P>

<LI>The SSL Protocol version 3.0 Internet Draft:<BR>
<EM>
<A HREF="http://home.netscape.com/eng/ssl3/ssl-toc.html">
http://home.netscape.com/eng/ssl3/ssl-toc.html</A>
</EM>
</LI><P>

<LI>The TLS Protocol version 1.0 Internet Draft: <BR>
<EM>
<A HREF="http://www.ietf.org/rfc/rfc2246.txt">
http://www.ietf.org/rfc/rfc2246.txt</A>
</EM>
</LI><p>

<LI>"HTTP Over TLS" Information RFC: <BR>
<EM>
<A HREF="http://www.ietf.org/rfc/rfc2818.txt">
http://www.ietf.org/rfc/rfc2818.txt</A>
</EM>
</LI>


</UL>


<P>Books:

<UL>

<LI><EM>
SSL and TLS: Designing and Building Secure Systems</EM> by Eric Rescorla. 
Addison Wesley Professional, 2000. </LI><P>

<LI><EM>
SSL and TLS Essentials: Securing the Web</EM>
by Stephen Thomas. John Wiley and Sons, Inc., 2000.</LI><P>

<LI><EM> Java 2 Network Security</EM>, Second Edition, by Marco
Pistoia, Duane F Reller, Deepak Gupta, Milind Nagnur, and Ashok K
Ramani. Prentice Hall, 1999. Copyright 1999 International Business
Machines.</LI>

</UL>

</blockquote>
</blockquote>
</blockquote>


<a name="Terms"></a>
<H1>Terms and Definitions</H1>

<blockquote>

<P> There are several terms relating to cryptography that are used
within this document. This section defines some of these
terms.

<H2>Authentication</H2>
<i>Authentication</i> is the process of confirming the identity of a
party with whom one is communicating.

<H2><a name="CipherSuite">Cipher Suite</a></H2>
A <i>cipher suite</i> is a combination of cryptographic parameters
that define the security algorithms and key sizes used for
authentication, key agreement, encryption, and integrity protection.

<H2>Certificate</H2>
A <i>certificate</i> is a digitally signed statement vouching for
the identity and public key of an entity (person, company, etc.).
Certificates can either be self-signed or issued by a Certification
Authority (CA).  Certification Authorities are entities that are
trusted to issue valid certificates for other entities.  Well-known CAs
include VeriSign, Entrust, and GTE CyberTrust.  X509 is a common
certificate format, and they can be managed by the JDK's keytool.

<H2>Cryptographic Hash Function</H2>
A <i>cryptographic hash function</i> is similar to a checksum. Data is
processed with an algorithm that produces a relatively small string of
bits called a hash. A cryptographic hash function has three primary
characteristics: it is a one-way function, meaning that it is not
possible to produce the original data from the hash; a small change in
the original data produces a large change in the resulting hash; and it
does not require a cryptographic key.

<H2>Cryptographic Service Provider</H2>
In the JCA, implementations for various cryptographic algorithms are
provided by <i>cryptographic service providers</i>, or "<a
href="../CryptoSpec.html#ProviderArch">providers</a>"
for short. Providers are essentially packages that implement one or
more engine classes for specific algorithms.  An engine class defines a
cryptographic service in an abstract fashion without a concrete
implementation.

<H2>Digital Signature</H2>
A <i>digital signature</i> is the digital equivalent of a handwritten
signature. It is used to ensure that data transmitted over a network
was sent by whoever claims to have sent it and that the data has not
been modified in transit. For example, an RSA-based digital signature
is calculated by first computing a cryptographic hash of the data and
then encrypting the hash with the sender's private key.

<H2>Encryption and Decryption</H2>
<i>Encryption</i> is the process of using a complex algorithm to
convert an original message, or <i>cleartext</i>, to an encoded
message, called <i>ciphertext</i>, that is unintelligible unless it is
decrypted. <i>Decryption</i> is the inverse process of producing
cleartext from ciphertext. The algorithms used to encrypt and decrypt
data typically come in two categories:  secret key (symmetric)
cryptography and public key (asymmetric) cryptography.

<H2>Handshake Protocol</H2>
The negotiation phase during which the two socket peers agree to use a
new or existing session. The <i>handshake protocol</i> is a series of
messages exchanged over the record protocol. At the end of the
handshake new connection-specific encryption and integrity protection
keys are generated based on the key agreement secrets in the session.

<H2>Key Agreement</H2>
<i>Key agreement</i> is a protocol by which 2 or more parties can
establish the same cryptographic keys, without having to exchange any
secret information in the clear.  Examples include RSA and
Diffie-Hellman.<p>

<a name="KMandTMdef"></a>
<H2>Key Managers and Trust Managers</H2>
<P> <i>Key managers</i> (see <a href=""
"#KeyManagerFactory"><code>KeyManagerFactory</code></a>) and <i>trust
managers</i> (see <a href=""
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>) use
keystores for their key material.  A key manager manages a keystore and
supplies public keys to others as needed, e.g., for use in
authenticating the user to others.  A trust manager makes decisions
about who to trust based on information in the truststore it manages.

<a name="Stores"></a>
<H2>Keystores and Truststores</H2>

<P> A <i>keystore</i> is a database of key material.  Key material is
used for a variety of purposes, including authentication and data
integrity.  There are various types of keystores available, including
"PKCS12" and Sun's "JKS." 

<P> Generally speaking, keystore information can be grouped into two
different categories:  key entries and trusted certificate entries.  A
key entry consists of an entity's identity and its private key,
and can be used for a variety of cryptographic purposes.  In contrast,
a trusted certificate entry only contains a public key in addition to
the entity's identity.  Thus, a trusted certificate entry can not be
used where a private key is required, such as in a
<code>javax.net.ssl.KeyManager</code>.  In the J2SDK implementation of
"JKS", a keystore may contain both key entries and trusted certificate entries.

<P> A <i>truststore</i> is a keystore which is used when making decisions
about what to trust.  If you receive some data from an entity that
you already trust, and if you can verify that the entity is the one it
claims to be, then you can assume that the data really came from that
entity.

<P> An entry should only be added to a truststore if the user makes a
decision to trust that entity.  By either generating a keypair or by
importing a certificate, the user has given trust to that entry, and
thus any entry in the keystore is considered a trusted entry.

<P> It may be useful to have two different keystore files:  one
containing just your key entries, and the other containing your trusted
certificate entries, including Certification Authority (CA)
certificates.  The former contains private information, while the
latter does not.  Using two different files instead of a single
keystore file provides for a cleaner separation of the logical
distinction between your own certificates (and corresponding private
keys) and others' certificates.  You could provide more protection for
your private keys if you store them in a keystore with restricted
access, while providing the trusted certificates in a more publicly
accessible keystore if needed.


<H2>Message Authentication Code</H2>
A <i>Message Authentication Code</i> (MAC) provides a way to check the
integrity of information transmitted over or stored in an unreliable
medium, based on a secret key. Typically, MACs are used between two
parties that share a secret key in order to validate information
transmitted between these parties.

<P> A MAC mechanism that is based on cryptographic hash
functions is referred to as HMAC. HMAC can be used with
any cryptographic hash function, such as Message Digest 5
(MD5) and Secure Hash Algorithm (SHA), in combination
with a secret shared key. HMAC is
specified in RFC 2104.


<H2>Public Key Cryptography</H2>
<i>Public key cryptography</i> uses an encryption algorithm in
which two keys are produced. One key is made public while
the other is kept private. The public key and the private key
are cryptographic inverses; what one key encrypts only the
other key can decrypt. Public key cryptography is also called
asymmetric cryptography.

<H2> Record Protocol</H2>
The <i>record protocol</i> packages all data whether application-level
or as part of the handshake process into discrete records of data much
like a TCP stream socket converts an application byte stream into
network packets.  The individual records are then protected by the
current encryption and integrity protection keys.

<H2>Secret Key Cryptography</H2>
<i>Secret key cryptography</i> uses an encryption algorithm in
which the same key is used both to encrypt and decrypt the
data. Secret key cryptography is also called symmetric cryptography.

<H2>Session</H2>
A <i>session</i> is a named collection of state information including
authenticated peer identity, cipher suite, and key agreement
secrets which are negotiated through a secure socket
handshake and which can be shared among multiple secure
socket instances.

<H2>Trust Managers</H2>
See <a href="#KMandTMdef">Key Managers and Trust Managers</a>.

<H2>Truststore </H2>
See <a href="#Stores">Keystores and Truststores</a>.
</blockquote>

<br>

<a name="SSLOverview"></a>
<H1>Secure Sockets Layer (SSL) Protocol Overview</H1>

<blockquote>

<P> Secure Sockets Layer (SSL) is the most widely used protocol
for implementing cryptography on the Web. SSL uses a combination
of cryptographic processes to provide secure communication
over a network. This section provides an
introduction to SSL and the cryptographic processes it uses.

<P> SSL provides a secure enhancement to the standard TCP/IP
sockets protocol used for Internet communications. As
shown in the "TCP/IP Protocol Stack With SSL" figure below, the
secure sockets layer is added between the transport layer and
the application layer in the standard TCP/IP protocol stack.
The application most commonly used with SSL is Hypertext
Transfer Protocol (HTTP), the protocol for Internet Web
pages. Other applications, such as Net News Transfer Protocol
(NNTP), Telnet, Lightweight Directory Access Protocol
(LDAP), Interactive Message Access Protocol (IMAP), and
File Transfer Protocol (FTP), can be used with SSL as well.

<P> Note: There is currently no standard for secure FTP.

<br>
<br>
<P>

<center>

<TABLE>
<CAPTION>
<H3>TCP/IP Protocol Stack With SSL</H3>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
TCP/IP Layer
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
Protocol
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>Application Layer
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>&nbsp;&nbsp;&nbsp;&nbsp;HTTP, NNTP, Telnet, FTP, etc.
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>Secure Sockets Layer
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>&nbsp;&nbsp;&nbsp;&nbsp;SSL
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>Transport Layer
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>&nbsp;&nbsp;&nbsp;&nbsp;TCP
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>Internet Layer
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>&nbsp;&nbsp;&nbsp;&nbsp;IP
</TD>
</TR>
</TABLE>

</center>


<P> SSL was developed by Netscape in 1994, and with input
from the Internet community, has evolved to become a standard.
It is now under the control of the international standards
organization, the Internet Engineering Task Force
(IETF). The IETF has renamed SSL to Transport Layer
Security (TLS), and released the first specification, version
1.0, in January 1999. TLS 1.0 is a modest upgrade to the
most recent version of SSL, version 3.0. The differences
between SSL 3.0 and TLS 1.0 are minor.


<a name="WhySSL"></a>
<H2>Why Use SSL?</H2>

<blockquote>

Transferring sensitive information over a network can be
risky due to the following three issues:

<ul>

<li>You cannot always be sure that the entity with whom you
are communicating is really who you think it is.<P>

<li>Network data can be intercepted, so it is possible that it
can be read by an unauthorized third party, sometimes
known as an attacker. <P>

<li>If an attacker can intercept the data, the attacker may be
able to modify the data before sending it on to the receiver.

</ul>

<P> SSL addresses each of these issues. It addresses the first issue by
optionally allowing each of two communicating parties to ensure the
identity of the other party in a process called authentication. Once
the parties are authenticated, SSL provides an encrypted connection
between the two parties for secure message transmission. Encrypting the
communication between the two parties provides privacy and therefore
addresses the second issue. The encryption algorithms used with SSL
include a secure hash function, which is similar to a checksum. This
ensures that data is not modified in transit. The secure hash function
addresses the third issue of data integrity.

<P> Note, both authentication and encryption are optional, and depend
on the the negotiated cipher suites between the two entities.

<P> The most obvious example of when you would use SSL is in
an e-commerce transaction. In an e-commerce transaction, it
would be foolish to assume that you can guarantee the identity
of the server with whom you are communicating. It
would be easy enough for someone to create a phony Web
site promising great services if only you enter your credit
card number. SSL allows you, the client, to authenticate the
identity of the server. It also allows the server to authenticate
the identity of the client, although in Internet transactions,
this is seldom done.

<P> Once the client and the server are comfortable with each
other's identity, SSL provides privacy and data integrity
through the encryption algorithms it uses. This allows sensitive
information, such as credit card numbers, to be transmitted
securely over the Internet.

<P> While SSL provides authentication, privacy, and data integrity,
it does not provide non-repudiation services. Non-repudiation
means that an entity that sends a message cannot later
deny that they sent it. When the digital equivalent of a signature
is associated with a message, the communication can
later be proved. SSL alone does not provide non-repudiation.

</blockquote>


<a name="HowSSLWorks"></a>
<H2>How SSL Works</H2>

<blockquote>

One of the reasons SSL is effective is that it uses several different
cryptographic processes. SSL uses public key cryptography to provide
authentication, and secret key cryptography and digital signatures to
provide for privacy and data integrity. Before you can understand SSL,
it is helpful to understand these cryptographic processes.

<H3>Cryptographic Processes</H3>

<blockquote>

The primary purpose of cryptography is to make it difficult
for an unauthorized third party to access and understand private
communication between two parties. It is not always
possible to restrict all unauthorized access to data, but private
data can be made unintelligible to unauthorized parties
through the process of encryption. Encryption uses complex
algorithms to convert the original message, or cleartext, to an
encoded message, called ciphertext. The algorithms used to
encrypt and decrypt data that is transferred over a network
typically come in two categories: secret key cryptography
and public key cryptography. These forms of cryptography
are explained in the following subsections.

<P> Both secret key cryptography and public key cryptography
depend on the use of an agreed-upon cryptographic key or
pair of keys. A key is a string of bits that is used by the cryptographic
algorithm or algorithms during the process of
encrypting and decrypting the data. A cryptographic key is
like a key for a lock: only with the right key can you open the
lock.

<P> Safely transmitting a key between two communicating parties
is not a trivial matter. A public key certificate allows a
party to safely transmit its public key, while ensuring the
receiver of the authenticity of the public key. Public key certificates
are described in a later section.

<P> In the descriptions of the cryptographic processes that follow,
we use the conventions used by the security community:
we label the two communicating parties with the names
Alice and Bob. We call the unauthorized third party, also
known as the attacker, Charlie.


<H4>Secret Key Cryptography</H4>

<blockquote>

<P> With secret key cryptography, both communicating parties,
Alice and Bob, use the same key to encrypt and decrypt the
messages. Before any encrypted data can be sent over the
network, both Alice and Bob must have the key and must
agree on the cryptographic algorithm that they will use for
encryption and decryption.

<P> One of the major problems with secret key cryptography is
the logistical issue of how to get the key from one party to
the other without allowing access to an attacker. If Alice and
Bob are securing their data with secret key cryptography, and
if Charlie gains access to their key, Charlie can understand
any secret messages he intercepts between Alice and Bob.
Not only can Charlie decrypt Alice's and Bob's messages,
but he can also pretend that he is Alice and send encrypted
data to Bob. Bob will not know that the message came from
Charlie, not Alice.

<P> Once the problem of secret key distribution is solved, secret key
cryptography can be a valuable tool. The algorithms provide excellent
security and encrypt data relatively quickly.  The majority of the
sensitive data sent in an SSL session is sent using secret key
cryptography.

<P> Secret key cryptography is also called <i>symmetric cryptography</i>
because the same key is used to both encrypt and
decrypt the data. Well-known secret key cryptographic algorithms
include the Data Encryption Standard (DES), triple-strength
DES (3DES), Rivest Cipher 2 (RC2), and Rivest
Cipher 4 (RC4).

</blockquote>


<H4>Public Key Cryptography</H4>

<blockquote>

<P> Public key cryptography solves the logistical problem of key
distribution by using both a public key and a private key. The
public key can be sent openly through the network while the
private key is kept private by one of the communicating parties.
The public and the private keys are cryptographic
inverses of each other; what one key encrypts, the other key
will decrypt.

<P> Let's assume that Bob wants to send a secret message to
Alice using public key cryptography. Alice has both a public
key and a private key, so she keeps her private key in a safe
place and sends her public key to Bob. Bob encrypts the
secret message to Alice using Alice's public key. Alice can
later decrypt the message with her private key.

<P> If Alice encrypts a message using her private key and sends
the encrypted message to Bob, Bob can be sure that the data
he receives comes from Alice; if Bob can decrypt the data
with Alice's public key, the message must have been
encrypted by Alice with her private key, and only Alice has
Alice's private key. The problem is that anybody else can
read the message as well because Alice's public key is public.
While this scenario does not allow for secure data communication,
it does provide the basis for digital signatures. A
digital signature is one of the components of a public key
certificate, and is used in SSL to authenticate a client or a
server. Public key certificates and digital signatures are
described in later sections.

<P> Public key cryptography is also called <i>asymmetric
cryptography</i> because different keys are used to encrypt and decrypt
the data. A well known public key cryptographic algorithm often used
with SSL is the Rivest Shamir Adleman (RSA) algorithm. Another public
key algorithm used with SSL that is designed specifically for secret
key exchange is the Diffie-Hellman (DH) algorithm. Public key
cryptography requires extensive computations, making it very slow. It
is therefore typically used only for encrypting small pieces of data,
such as secret keys, rather than for the bulk of encrypted data
communications.

</blockquote>


<H4>A
Comparison Between Secret Key and Public Key Cryptography</H4>

<blockquote>

<P> Both secret key cryptography and public key cryptography
have strengths and weaknesses. With secret key cryptography,
data can be encrypted and decrypted quickly, but since
both communicating parties must share the same secret key
information, the logistics of exchanging the key can be a
problem. With public key cryptography, key exchange is not
a problem since the public key does not need to be kept
secret, but the algorithms used to encrypt and decrypt data
require extensive computations, and are therefore very slow.

</blockquote>


<H4>Public Key Certificates</H4>

<blockquote>

<P> A public key certificate provides a safe way for an entity to
pass on its public key to be used in asymmetric cryptography.
The public key certificate avoids the following situation:
if Charlie creates his own public key and private key, he can
claim that he is Alice and send his public key to Bob. Bob
will be able to communicate with Charlie, but Bob will think
that he is sending his data to Alice.

<P> A public key certificate can be thought of as the digital
equivalent of a passport. It is issued by a trusted organization
and provides identification for the bearer. A trusted organization
that issues public key certificates is known as a certificate
authority (CA). The CA can be likened to a notary
public. To obtain a certificate from a CA, one must provide
proof of identity. Once the CA is confident that the applicant
represents the organization it says it represents, the CA
signs the certificate attesting to the validity of the information
contained within the certificate.

<P> A public key certificate contains several fields, including:

<ul>

<li>Issuer - The issuer is the CA that issued the certificate. If
a user trusts the CA that issues a certificate, and if the
certificate is valid, the user can trust the certificate.<P>

<li>Period of validity - A certificate has an expiration date,
and this date is one piece of information that should be
checked when verifying the validity of a certificate.<P>

<li>Subject - The subject field includes information about
the entity that the certificate represents.<P>

<li>Subject's public key - The primary piece of information
that the certificate provides is the subject's public key. All
the other fields are provided to ensure the validity of this
key.<P>

<li>Signature - The certificate is digitally signed by the CA
that issued the certificate. The signature is created using
the CA's private key and ensures the validity of the certificate.
Because only the certificate is signed, not the data
sent in the SSL transaction, SSL does not provide for
non-repudiation.

</ul>

<P> If Bob only accepts Alice's public key as valid when she
sends it in a public key certificate, Bob will not be fooled
into sending secret information to Charlie when Charlie masquerades
as Alice.

<P> Multiple certificates may be linked in a certificate chain.
When a certificate chain
is used, the first certificate is always that of the sender. The
next is the certificate of the entity that issued the sender's
certificate. If there are more certificates in the chain, each is
that of the authority that issued the previous certificate. The
final certificate in the chain is the certificate for a root CA. A
root CA is a public certificate authority that is widely trusted.
Information for several root CAs is typically stored in the client's
Internet browser. This information includes the CA's
public key. Well-known CAs include VeriSign, Entrust, and
GTE CyberTrust.

</blockquote>


<H4>Cryptographic Hash Functions</H4>

<blockquote>

<P> When sending encrypted data, SSL typically uses a cryptographic
hash function to ensure data integrity. The hash function
prevents Charlie from tampering with data that Alice
sends to Bob.

<P> A cryptographic hash function is similar to a checksum. The
main difference is that while a checksum is designed to
detect accidental alterations in data, a cryptographic hash
function is designed to detect deliberate alterations. When
data is processed by a cryptographic hash function, a small
string of bits, known as a hash, is generated. The slightest
change to the message typically makes a large change in the
resulting hash. A cryptographic hash function does not
require a cryptographic key. Two hash functions often used
with SSL are Message Digest 5 (MD5) and Secure Hash
Algorithm (SHA). SHA was proposed by the
<A HREF="http://www.nist.gov">US National
Institute of Science and Technology (NIST)</A>.

</blockquote>

<H4>Message Authentication Code</H4>

<blockquote>

A message authentication code (MAC) is similar to a cryptographic
hash, except that it is based on a secret key. When
secret key information is included with the data that is processed
by a cryptographic hash function, the resulting hash is
known as an HMAC.

<P> If Alice wants to be sure that Charlie does not tamper with
her message to Bob, she can calculate an HMAC for her
message and append the HMAC to her original message. She
can then encrypt the message plus the HMAC using a secret
key she shares with Bob. When Bob decrypts the message
and calculates the HMAC, he will be able to tell if the message
was modified in transit. With SSL, an HMAC is used
with the transmission of secure data.

</blockquote>


<H4>Digital Signatures</H4>

<blockquote>

<P> Once a cryptographic hash is created for a message, the hash
is encrypted with the sender's private key. This encrypted
hash is called a digital signature.

</blockquote>

</blockquote>


<H3>The SSL Process</H3>

<blockquote>

<P> Communication using SSL begins with an exchange of
information between the client and the server. This exchange
of information is called the SSL handshake.

<P> The three main purposes of the SSL handshake are:

<ul>

<li>Negotiate the cipher suite<P>

<li>Authenticate identity (optional)<P>

<li>Establish information security by agreeing on encryption
mechanisms

</ul>


<H4>Negotiating the Cipher Suite</H4>

<blockquote>

<P> The SSL session begins with a negotiation between the client
and the server as to which cipher suite they will use. A cipher
suite is a set of cryptographic algorithms and key sizes that a
computer can use to encrypt data. The cipher suite includes
information about available public key exchange algorithms,
secret key encryption algorithms, and cryptographic hash
functions. The client tells the server which cipher suites it
has available, and the server chooses the best mutually
acceptable cipher suite.

</blockquote>


<H4>Authenticating the Server</H4>

<blockquote>

<P> In SSL, the authentication step is optional, but in the example
of an e-commerce transaction over the Web, the client
will generally want to authenticate the server. Authenticating
the server allows the client to be sure that the server represents
the entity that the client believes the server represents.

<P> To prove that a server belongs to the organization that it
claims to represent, the server presents its public key certificate
to the client. If this certificate is valid, the client can be
sure of the identity of the server.

<P> The client and server exchange information that allows them
to agree on the same secret key. For example, with RSA, the
client uses the server's public key, obtained from the public
key certificate, to encrypt the secret key information. The client
sends the encrypted secret key information to the server.
Only the server can decrypt this message since the server's
private key is required for this decryption.

</blockquote>


<H4>Sending the Encrypted Data</H4>

<blockquote>

<P> Both the client and the server now have access to the same
secret key. With each message, they use the cryptographic
hash function, chosen in the first step of this process, and
shared secret information, to compute an HMAC that they
append to the message. They then use the secret key and the
secret key algorithm negotiated in the first step of this process
to encrypt the secure data and the HMAC. The client
and server can now communicate securely using their
encrypted and hashed data.

</blockquote>

</blockquote>


<H3>The SSL Protocol</H3>

<blockquote>

<P> The previous section provides a high-level description of the
SSL handshake, which is the exchange of information
between the client and the server prior to sending the
encrypted message. This section provides more detail.

<P> The "SSL Messages" figure below shows the sequence of messages
that are exchanged in the SSL handshake. Messages that are
only sent in certain situations are noted as optional. Each of
the SSL messages is described in the following figure:

<br>
<br>
<center>
<IMG SRC="sslmessages.gif" WIDTH="484" HEIGHT="393" 
ALT="Sequence of messages exchanged in SSL handshake.">
</center>
<br>
<br>

<P> The SSL messages are sent in the following order:

<ol>

<li><b>Client hello</b> - The client sends the server information
including the highest version of SSL it supports and a list
of the cipher suites it supports. (TLS 1.0 is indicated as
SSL 3.1.) The cipher suite information includes cryptographic
algorithms and key sizes.<P>

<li><b>Server hello</b> - The server chooses the highest version of
SSL and the best cipher suite that both the client and
server support and sends this information to the client.<P>

<li><b>Certificate</b> - The server sends the client a certificate or a
certificate chain. A certificate chain typically begins with the
server's public key certificate and ends with the certificate
authority's root certificate. This message is optional, but is used
whenever server authentication is required.<P>

<li><b>Certificate request</b> - If the server needs to authenticate
the client, it sends the client a certificate request. In Internet
applications, this message is rarely sent.<P>

<li><b>Server key exchange</b> - The server sends the client a server
key exchange message when the public key information sent in 3) above
is not sufficient for key exchange.<P>

<li><b>Server hello done</b> - The server tells the client that it is
finished with its initial negotiation messages.<P>

<li><b>Certificate</b> - If the server requests a certificate from the
client in Message 4, the client sends its certificate chain,
just as the server did in Message 3.<P>

<P> Note: Only a few Internet server applications ask for a certificate 
from the client.<P> 


<li><b>Client key exchange</b> - The client generates information
used to create a key to use for symmetric encryption. For
RSA, the client then encrypts this key information with
the server's public key and sends it to the server.<P>

<li><b>Certificate verify</b> - In internet applications, this message
is rarely sent. Its purpose is to allow the server to complete the
process of authenticating the client. When this message is used, the
client sends information that it digitally signs using a cryptographic
hash function. When the server decrypts this information with the
client's public key, the server is able to authenticate the client.<P>

<li><b>Change cipher spec</b> - The client sends a message telling the
server to change to encrypted mode. <P>

<li><b>Finished</b> - The client tells the server that it is ready for
secure data communication to begin.<P>

<li><b>Change cipher spec</b> - The server sends a message telling
the client to change to encrypted mode.<P>

<li><b>Finished</b> - The server tells the client that it is ready for
secure data communication to begin. This is the end of
the SSL handshake.<P>

<li><b>Encrypted data</b> - The client and the server communicate
using the symmetric encryption algorithm and the cryptographic
hash function negotiated in Messages 1 and 2,
and using the secret key that the client sent to the server
in Message 8.

</ol>

<P> If the parameters generated during an SSL session are saved,
these parameters can sometimes be re-used for future SSL
sessions. Saving SSL session parameters allows encrypted
communication to begin much more quickly.

</blockquote>
</blockquote>


<a name="SSLRefs"></a>
<H2>SSL and TLS References</H2>

<blockquote>

<P> For a list of resources containing more information about SSL, see
<a href="#SSLDocs">Secure Sockets Layer Documentation</a> .

</blockquote>


</blockquote>

<br>



<a name="KeyClasses"></a>
<H1>Key Classes</H1>

<blockquote>


<a name="ClassRelationship"></a>
<H2>Relationship Between Classes</H2>

<blockquote>

<P>To communicate securely, both sides of the connection must be
SSL-enabled.  In the JSSE API, the endpoint class of the connection is
the <code>SSLSocket</code>.  In the diagram below, the major classes used 
to create <code>SSLSocket</code>s are laid out in a logical ordering.

<br>
<br>

<center>
<IMG SRC="classes1.gif" WIDTH="591" HEIGHT="421" 
ALT="diagram of classes used to create SSLSockets">
</center>

<br>
<br>

<P>An <code>SSLSocket</code> is created either by an 
<code>SSLSocketFactory</code> or by an
<code>SSLServerSocket</code> accepting an in-bound connection.  (In turn,
an <code>SSLServerSocket</code> is created by an
<code>SSLServerSocketFactory</code>.)  Both
<code>SSLSocketFactory</code> and <code>SSLServerSocketFactory</code> 
objects are created by an <code>SSLContext</code>.

<P>

<P>There are two ways to obtain and initialize an <code>SSLContext</code>:

<ul>
<li>

The simplest is to call the static <code>getDefault</code>
method on either the <code>SSLSocketFactory</code> or 
<code>SSLServerSocketFactory</code> class.
These methods create a default <code>SSLContext</code> with 
a default <code>KeyManager</code>, <code>TrustManager</code>, and 
a secure random number generator.  (A default
<code>KeyManagerFactory</code> and <code>TrustManagerFactory</code> are used 
to create the <code>KeyManager</code> and <code>TrustManager</code>, 
respectively.)  The key material used
is found in the default keystore/truststore, as determined by system
properties described in <a href="#CustomizingStores">Customizing the
Default Key and Trust Stores, Store Types, and Store Passwords</a>. <p>

<li>

The approach that gives the caller the most control over the behavior
of the created context is to call the static method
<code>getInstance</code> on the <code>SSLContext</code> class, then initialize 
the context by calling the instance's proper <code>init</code> method.  One
variant of the <code>init</code> method takes three arguments: an array of
<code>KeyManager</code> objects, an array of <code>TrustManager</code> objects, 
and a <code>SecureRandom</code> random number generator.  (SunJSSE currently
only uses this variant of <code>init</code>.)  The <code>KeyManager</code> and
<code>TrustManager</code> objects are created by either implementing the
appropriate interface(s) or using the <code>KeyManagerFactory</code> and
<code>TrustManagerFactory</code> classes to generate implementations.
The <code>KeyManagerFactory</code> and <code>TrustManagerFactory</code> can 
then each be initialized with key material contained
in the <code>KeyStore</code> passed as an argument to the 
<code>TrustManagerFactory/KeyManagerFactory</code> <code>init</code> 
method. Finally, the <code>getTrustManagers</code> method (in 
<code>TrustManagerFactory</code>) and <code>getKeyManagers</code> method 
(in <code>KeyManagerFactory</code>) can be called to obtain the array of trust 
or key managers, one for each type of trust or key material.

</ul>

<P>Once an SSL connection is established, an <code>SSLSession</code>
is created which contains various information, such as identities established, 
cipher suite used, etc.  The <code>SSLSession</code> is then used to describe 
an ongoing relationship and state information between two entities.  Each SSL
connection involves one session at a time, but that session may be used
on many connections between those entities, simultaneously or
sequentially.

<P>

</blockquote>


<a name="CoreClasses"></a>
<H2>Core Classes and Interfaces</H2>

<blockquote>

<P> The core JSSE classes are part of the <code>javax.net</code> and
<code>javax.net.ssl</code> packages.


<a name="SocketFactory"></a>
<H3><code>SocketFactory</code> and
<code>ServerSocketFactory</code> Classes</H3>

<blockquote>

<P> The abstract <code>javax.net.SocketFactory</code> class is used to
create sockets. It must be subclassed by other factories, which create
particular subclasses of sockets and thus provide a general framework
for the addition of public socket-level functionality.  (See, for
example, <a
href="#SSLSocketFactory"><code>SSLSocketFactory</code></a>.)

<P> The <code>javax.net.ServerSocketFactory</code> class is analogous to the
<code>SocketFactory</code> class, but is used specifically for creating
server sockets.

<P> Socket factories are a simple way to capture a variety of policies
related to the sockets being constructed, producing such sockets in
a way which does not require special configuration of the code which
asks for the sockets:

<UL>

<LI> Due to polymorphism of both factories and sockets, different
kinds of sockets can be used by the same application code just
by passing different kinds of factories.<P>

<LI> Factories can themselves be customized with parameters used
in socket construction. So for example, factories could be
customized to return sockets with different networking timeouts
or security parameters already configured.<P>

<LI> The sockets returned to the application can be subclasses
of <code>java.net.Socket</code> (or <code>javax.net.ssl.SSLSocket</code>),
so that they can directly expose new APIs
for features such as compression, security, record marking,
statistics collection, or firewall tunneling.

</UL>

</blockquote>


<a name="SSLSocket"></a>
<H3><code>SSLSocket</code> and <code>SSLServerSocket</code> Classes</H3>

<blockquote>

<P> The <code>javax.net.ssl.SSLSocket</code> class is a subclass of the
standard Java <code>java.net.Socket</code> class. It supports all of
the standard socket methods and adds additional methods specific to
secure sockets. Instances of this class encapsulate the <a href=""
"#SSLContext"><code>SSLContext</code></a> under which they were
created. There are APIs to control the creation of secure socket
sessions for a socket instance but trust and key management are not
directly exposed.

<P> The <code>javax.net.ssl.SSLServerSocket</code> class is analogous
to the <code>SSLSocket</code> class, but is used specifically for
creating server sockets.

<p>Implementation Note: Due to the complexity of the SSL and TLS protocols, 
it is difficult to predict whether incoming bytes on a connection are
handshake or application data, and how that data might affect
the current connection state (even causing the process to
block).  In the Sun JSSE implementation, the <code>available()</code> method
on the object obtained by <code>SSLSocket.getInputStream()</code> 
returns a count of the number of application data bytes
successfully decrypted from the SSL connection but not yet read
by the application.


<H4>Obtaining an <code>SSLSocket</code></H4>

<blockquote>
Instances of <code>SSLSocket</code> can be obtained in two ways. First,
an <code>SSLSocket</code> can be created by an instance of <a href=""
"#SSLSocketFactory"><code>SSLSocketFactory</code></a> via one of the
several <code>createSocket</code> methods on that class.  The second
way to obtain <code>SSLSocket</code>s is through the
<code>accept</code> method on the <code>SSLServerSocket</code> class.
</blockquote>

</blockquote>


<a name="SSLSocketFactory"></a>
<H3><code>SSLSocketFactory</code> and
<code>SSLServerSocketFactory</code> Classes</H3>

<blockquote>

<P> A <code>javax.net.ssl.SSLSocketFactory</code> acts as a factory for
creating secure sockets. This class is an abstract subclass of 
<a href="" "#SocketFactory"><code>javax.net.SocketFactory</code></a>.

<P> Secure socket factories encapsulate the details of creating
and initially configuring secure sockets. This includes authentication
keys, peer certificate validation, enabled cipher suites
and the like.

<P> The <code>javax.net.ssl.SSLServerSocketFactory</code> class is
analogous to the <code>SSLSocketFactory</code> class, but is used
specifically for creating server sockets.

<H4>Obtaining an <code>SSLSocketFactory</code></H4>

<blockquote>

<P> There are three primary ways of obtaining an
<code>SSLSocketFactory</code>:

<ul>

<li>
Get the default factory by calling the
<code>SSLSocketFactory.getDefault</code> static method.<P> </li>

<li>

Receive a factory as an API parameter. That is, code which needs to
create sockets but which doesn't care about the details of how the
sockets are configured can include a method with an
<code>SSLSocketFactory</code> parameter that can be called by clients
to specify which <code>SSLSocketFactory</code> to use when creating
sockets.  (For example, javax.net.ssl.HttpsURLConnection.)<P> </li>

<li>
Construct a new factory with specifically configured behavior.</li>

</ul>

<P> The default factory is typically configured to support server
authentication only so that sockets created by the default factory do
not leak any more information about the client than a normal TCP socket
would.

<p>Many classes which create and use sockets do not need to know the
details of socket creation behavior. Creating sockets through a socket
factory passed in as a parameter is a good way of isolating the details
of socket configuration, and increases the reusability of classes which
create and use sockets.

<p>You can create new socket factory instances either by implementing
your own socket factory subclass or by using another class which acts
as a factory for socket factories. One example of such a class is
<code>SSLContext</code>, which is provided with the JSSE 
implementation as a provider-based configuration
class.

</blockquote>
</blockquote>


<a name="SSLSession"></a>
<H3><code>SSLSession</code> Interface</H3>

<blockquote>

<P> A <code>javax.net.ssl.SSLSession</code> represents a security context
negotiated between the two peers of an
<a href="#SSLSocket"><code>SSLSocket</code></a> connection. Once a
session has been arranged, it can be shared by future
<code>SSLSocket</code>s connected between the same two peers. The
session contains the cipher suite which will be used for communications
over a secure socket as well as a non-authoritative
hint as to the network address of the remote peer, and
management information such as the time of creation and last
use. A session also contains a shared master secret negotiated
between the peers that is used to create cryptographic
keys for encrypting and guaranteeing the integrity of the
communications over an <code>SSLSocket</code>. The value of this master
secret is known only to the underlying secure socket
implementation and is not exposed through the <code>SSLSession</code>
API.

</blockquote>

<a name="HttpsURLConnection"></a>
<H3><code>HttpsURLConnection</code> Class</H3>

<blockquote>

The https protocol is similar to http, but https first establishes a 
secure channel via SSL/TLS sockets before requesting/receiving data. 
<code>javax.net.ssl.HttpsURLConnection</code> extends the
<code>java.net.HttpsURLConnection</code> class, and adds support 
for https-specific features.  See the 
<A HREF=">../../../../../api/java/net/URL.html"><code>java.net.URL</code></A>, 
<A HREF=">../../../../../api/java/net/URLConnection.html"><code>java.net.URLConnection</code></A>, and
<A HREF=">../../../../../api/java/net/HttpURLConnection.html"><code>java.net.HttpURLConnection</code></A>  
classes for more information about how http
URLs are constructed and used.

<P>

Upon obtaining a <code>HttpsURLConnection</code>, 
you can configure a number of
http/https parameters before actually initiating the network connection
via the method  <code>URLConnection.connect</code>.  
Of particular interest are:
<UL>
<li><A HREF="#SettingSSLSocketFactory">Setting the Assigned <code>SSLSocketFactory</code></A>
<li><A HREF="#SettingHostnameVerifier">Setting the Assigned <code>HostnameVerifier</code></A>
</UL>

<A NAME="SettingSSLSocketFactory"></A>
<H4>Setting the Assigned <code>SSLSocketFactory</code></H4>

<blockquote>

<P>
In some situations, it is desirable to specify the 
<code>SSLSocketFactory</code> that an 
<code>HttpsURLConnection</code> instance uses.  
For example, you may wish to 
tunnel through a proxy type that isn't supported by the default
implementation.  The new <code>SSLSocketFactory</code> 
could return sockets that have already performed all 
necessary tunneling, thus allowing 
<code>HttpsURLConnection</code> to use additional proxies.

<P>

The <code>HttpsURLConnection</code> class has a default 
<code>SSLSocketFactory</code> which is 
assigned when the class is loaded.  
(In particular it is the factory returned by the method 
<code>SSLSocketFactory.getDefault</code>.)  
Future instances of <code>HttpsURLConnection</code> will 
inherit the current default <code>SSLSocketFactory</code>
until a new default <code>SSLSocketFactory</code> is 
assigned to the class via the
static method <code>HttpsURLConnection.setDefaultSSLSocketFactory</code>.  
Once an instance of <code>HttpsURLConnection</code> 
has been created, the inherited <code>SSLSocketFactory</code> 
on this instance can be overriden with a call to the  
<code>setSSLSocketFactory</code> method.

<P>
Note that changing the default static <code>SSLSocketFactory</code> has no effect on
existing instances of <code>HttpsURLConnections</code>, a call to
the <code>setSSLSocketFactory</code> method is necessary to change the existing instance.

<P>

One can obtain the per-instance or per-class <code>SSLSocketFactory</code> by making
a call to the <code>getSSLSocketFactory</code>/<code>getDefaultSSLSocketFactory</code>
 methods, respectively.


</blockquote>


<A NAME="SettingHostnameVerifier"></A>
<H4>Setting the Assigned <code>HostnameVerifier</code></H4>

<blockquote>

If the hostname of the URL does not match the hostname in the
credentials received as part of the SSL/TLS handshake, it's possible
that URL spoofing has occured.  If the implementation cannot determine
a hostname match with reasonable certainty, the SSL implementation will
perform a callback to the instance's assigned <code>HostnameVerifier</code> for
futher checking.  The hostname verifier can perform whatever steps are
necessary to make the determination, such as performing alternate
hostname pattern matching or perhaps popping up an interactive dialog
box.  An unsuccessful verification will close the connection.  (See 
<A HREF="http://www.ietf.org/rfc/rfc2818.txt?number=2818">RFC 2818</A> 
for more information regarding hostname verification.)

<P>

The <code>setHostnameVerifier</code>/<code>setDefaultHostnameVerifier</code> 
methods operate in a
similar manner to the <code>setSSLSocketFactory</code>/<code>setDefaultSSLSocketFactory</code> 
methods, in that there are <code>HostnameVerifiers</code> assigned on a per-instance and
per-class basis, and the current values can be obtained
by a call to the <code>getHostnameVerifier</code>/<code>getDefaultHostnameVerifier</code> methods.
</blockquote>


</blockquote>
</blockquote>


<a name="SupportClasses"></a>
<H2>Support Classes and Interfaces</H2>

<blockquote>

<p>The classes and interfaces in this section are provided to support
the creation and initialization of <code>SSLContext</code> objects, which 
are used to create <code>SSLSocketFactory</code> and 
<code>SSLServerSocketFactory</code> objects.
The support classes and interfaces are part of the
<code>javax.net.ssl</code> package.

<P> Three of the classes described in this section (
<a href="#SSLContext"><code>SSLContext</code></a>, 
<a href="#KeyManagerFactory"><code>KeyManagerFactory</code></a>, 
and 
<a href="#TrustManagerFactory"><code>TrustManagerFactory</code></a>) 
are
<i>engine classes</i>. An engine class is an API class for specific
algorithms (or protocols, in the case of <code>SSLContext</code>), for
which implementations may be provided in one or more
Cryptographic Service Provider (provider) packages.  For more
information on providers and engine classes, see the "Design
Principles" and "Concepts" sections of the 
<a href="../CryptoSpec.html">Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 
Cryptography Architecture API Specification & Reference</a>.

<P> The <code>SunJSSE</code> provider that comes standard with JSSE
provides <code>SSLContext</code>, <code>KeyManagerFactory</code>,
and <code>TrustManagerFactory</code> implementations, as well as
implementations for engine classes in the standard Java security
(<code>java.security</code>) API.  The implementations supplied by
<code>SunJSSE</code> are:


<blockquote>
<pre>
<b>Engine Class        Algorithm or </b>
<b>Implemented           Protocol</b>

KeyFactory            "RSA"

KeyPairGenerator      "RSA"

KeyStore              "PKCS12"

Signature             "MD2withRSA"
Signature             "MD5withRSA"
Signature             "SHA1withRSA"

KeyManagerFactory     "SunX509"
TrustManagerFactory   "SunX509", "SunPKIX"

SSLContext            "SSL"
SSLContext            "SSLv3"
SSLContext            "TLS"
SSLContext            "TLSv1"
</pre>
</blockquote>


<a name="SSLContext"></a>
<H3><code>SSLContext</code> Class</H3>

<blockquote>

<P> <code>javax.net.ssl.SSLContext</code> is an engine class
for an implementation of a
secure socket protocol. An instance of this class acts as a factory
for SSL socket factories. An <code>SSLContext</code> holds all of the state
information shared across all sockets created under that context.
For example, session state is associated with the <code>SSLContext</code>
when it is negotiated through the handshake
protocol by sockets created by socket factories provided by
the context. These cached sessions can be reused and shared
by other sockets created under the same context.

<p>Each instance is configured through its <code>init</code> method with the
keys, certificate chains, and trusted root CA certificates that it needs to
perform authentication. This configuration is provided in the form of key
and trust managers. These managers provide support for the authentication
and key agreement aspects of the cipher suites supported by the context.

<p>Currently, only X.509-based managers are supported.


<H4>Creating an <code>SSLContext</code> Object</H4>

<blockquote>

Like other JCA provider-based "engine" classes, 
<code>SSLContext</code> objects are created using 
the <code>getInstance</code> factory methods of the 
<code>SSLContext</code> class. These static methods each 
return an instance that implements <i>at least</i> the requested
secure socket protocol. 
The returned instance may implement other protocols too. 
For example, <code>getInstance("SSLv3")</code>
may return a instance which implements <code>SSLv3</code> and 
<code>TLSv1</code>. 
The <code>getSupportedProtocols</code> method returns a list of 
supported protocols when an <code>SSLSocket</code> or 
<code>SSLServerSocket</code> is created from a socket factory 
obtained from this context.
You can control which protocols are actually enabled for an SSL connection
by using the method <code>setEnabledProtocols(String[] protocols)</code>. 
(Refer to the API documention for this method in the 
<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])">
<code>SSLSocket</code></A> and the 
<A HREF="http://java.sun.com/j2se/1.4.2/docs/api/javax/net/ssl/SSLServerSocket.html#setEnabledProtocols(java.lang.String[])">
<code>SSLServerSocket</code></A> classes for more information.)


<P> <B>Note:</B> 
An <code>SSLContext</code> object is automatically created, 
initialized, and statically assigned to the <code>SSLSocketFactory</code> 
class when you call <code>SSLSocketFactory.getDefault</code>.  Therefore, you
don't have to directly create and initialize an <code>SSLContext</code> 
object (unless you want to override the default behavior).

<p>To create an <code>SSLContext</code> object by calling a
<code>getInstance</code> factory method, you must specify the protocol
name.  You may also specify which provider you want to supply the
implementation of the requested protocol:

<blockquote>
<pre>
public static SSLContext getInstance(String protocol);

public static SSLContext getInstance(String protocol,
                                     String provider);

public static SSLContext getInstance(String protocol,
                                     Provider provider);
</pre>
</blockquote>

<P> If just a protocol name is specified, the system will determine if there
is an implementation of the requested protocol available in the environment,
and if there is more than one, if there is a preferred one.
<p>If both a protocol name and a provider are specified, the system will
determine if there is an implementation of the requested protocol in the
provider requested, and throw an exception if there is not.

<p>A protocol is a string (such as "SSL") that describes the
secure socket protocol desired.
Common protocol names for <code>SSLContext</code> objects are defined in
<a href="#AppA">Appendix A</a>.

<P> Here is an example of obtaining an <code>SSLContext</code>:

<blockquote>
<pre>
SSLContext sc = SSLContext.getInstance("SSL");
</pre>
</blockquote>


<p>A newly-created <code>SSLContext</code> should be initialized by calling the
<code>init</code> method:

<blockquote>
<pre>
public void init(KeyManager[] km, TrustManager[] tm,
                   SecureRandom random);
</pre>
</blockquote>

<P>  If the <code>KeyManager[]</code> paramater is null, then an empty
<code>KeyManager</code> will be defined for this context.  If the
<code>TrustManager[]</code> parameter is null, the installed security
providers will be searched for the highest-priority implementation of the
<a href="#TrustManagerFactory"><code>TrustManagerFactory</code></a>, from
which an appropriate <code>TrustManager</code> will be obtained.
Likewise, the SecureRandom parameter may be null, in which case a
default implementation will be used.

<P> If the internal default context is used, (e.g. a
<code>SSLContext</code> is created in the internals of JSSE), <a
href="#CustomizingStores"> a default <code>KeyManager</code> and a
<code>TrustManager</code></a> are created.  The default
<code>SecureRandom</code> implementation is also chosen.

</blockquote>
</blockquote>

<a name="TrustManager"></a>
<H3><code>TrustManager</code> Class</H3>

<blockquote>

The primary responsibility of the <code>TrustManager</code> is to determine 
whether the presented authentication credentials should be trusted.  
If the credentials are not trusted, the connection will be terminated. 
To authenticate the remote identity of a secure
socket peer, you need to initialize an <code>SSLContext</code> object
with one or more <code>TrustManager</code>s. You need to pass one
<code>TrustManager</code> for each authentication mechanism that is
supported. If null is passed into the <code>SSLContext</code> initialization,
a trust manager will be created for you. Typically, there
is a single trust manager that supports authentication based
on X.509 public key certificates. Some secure socket implementations
may also support authentication based on shared
secret keys, Kerberos, or other mechanisms.
</blockquote>

<a name="TrustManagerFactory"></a>
<H3><code>TrustManagerFactory</code> Class</H3>

<blockquote>
<p>The <code>javax.net.ssl.TrustManagerFactory</code> is an engine
class for a provider-based service that acts as a factory for one or
more types of <code>TrustManager</code> objects. The
<code>SunJSSE</code> provider implements a factory which can return a
basic X.509 trust manager.  Because it is provider-based, additional
factories can be implemented and configured that provide additional or
alternate trust managers that provide more sophisticated services or
that implement installation-specific authentication policies.
<P>
In the 1.4.2 release of the Java 2 platform, a CertPath-based 
X.509 trust manager called "SunPKIX" <code>TrustManagerFactory</code>
class was added. SunPKIX is available in addition to the previously 
available simple X.509 trust manager. For compatibility, it is not 
active by default. It can be enabled by changing the 
<code>ssl.TrustManagerFactory.algorithm</code> property in the 
<code>java.security</code> file from "SunX509" to "SunPKIX". 
Alternatively, it can be accessed programmatically by calling 
<code>TrustManagerFactory.getInstance("SunPKIX")</code>. 
The same "SunX509" TrustManagerFactory algorithm for cacerts 
(<code>javax.net.ssl.trustStore/jssecacerts/cacerts</code>) 
also initializes the SunPKIX algorithm.

<BLOCKQUOTE><HR>
<B>Note</B>: The algorithm name "SunPKIX" is preliminary and may 
change after standardization in a future release.
<HR></BLOCKQUOTE>


The PKIX trust manager uses the CertPath PKIX implementation from an 
installed security provider. In the currect release, you cannot specify the 
PKIXParameters to be used for validation; a suitable API will be added 
in a future release. Currently, the default PKIXParameters are used with  
the exception that revocation checking is disabled. It can be enabled by 
setting the system property <code>com.sun.net.ssl.checkRevocation</code> to 
<code>true</code>. Note that this setting requires that the CertPath implementation 
can locate revocation information by itself. The PKIX 
implementation in the SUN provider can do this in many cases but 
requires that the system property <code>com.sun.security.enableCRLDP</code> be set 
to <code>true</code>. For details see the 
<A HREF="../certpath/CertPathProgGuide.html">Java<SUP><FONT SIZE ="-2">TM</FONT></SUP> 
Certification Path API Programmer's Guide</a>.

<H4>Creating a <code>TrustManagerFactory</code></H4>

<blockquote>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name string
instead of a protocol name to the <code>getInstance</code> method:

<blockquote>
<pre>
public static TrustManagerFactory
                  getInstance(String algorithm);

public static TrustManagerFactory
                  getInstance(String algorithm,
                              String provider);

public static TrustManagerFactory
                  getInstance(String algorithm,
                              Provider provider);
</pre>
</blockquote>

<P> A sample algorithm name string is:

<blockquote><i><font face="Courier New,Courier">"SunX509"</font></i>
</blockquote>

<P> A sample call is the following:

<blockquote>
<pre>
TrustManagerFactory tmf =
    TrustManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
</blockquote>

<P> The above call will create an instance of the <code>SunJSSE</code> 
provider's default trust manager factory. 
This factory can then be used to create trust managers which 
provide basic X.509-based certification path validity checking. 

<P>
When initializing a <code>SSLContext</code>, you can use 
trust managers created from a trust manager factory, or you can 
write your own trust manager, perhaps using the 
<a href="../../../api/java/security/cert/CertPath.html">
<code>CertPath</code></A> API. (See the 
<a href="../certpath/CertPathProgGuide.html">Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 
Certification Path API Programmer's Guide</A>
for details.) 

You don't need to use a trust manager factory at all if 
you implement a trust manager using the 
<a href="../../../api/javax/net/ssl/X509TrustManager.html">
<code>X509TrustManager</code></a> interface.

<p>A newly-created factory should be initialized by calling 
one of the <code>init</code> methods:

<blockquote>
<pre>
public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</pre>
</blockquote>

<p>You should call whichever <code>init</code> method is appropriate for
the <code>TrustManagerFactory</code> you are using. (Ask the provider vendor.)

<p>For many factories, such as the default "SunX509" 
<code>TrustManagerFactory</code> from the <code>SunJSSE</code> provider, the 
<code>KeyStore</code> is the only information required in order to initialize 
the <code>TrustManagerFactory</code> and thus the first <code>init</code> 
method is the appropriate one to call. The <code>TrustManagerFactory</code>
will query the <code>KeyStore</code> for information on which remote 
certificates should be trusted during authorization checks.

<p>In some cases, initialization parameters other than a <code>KeyStore</code>
may be needed by a provider.  Users of that particular provider
are expected to pass an implementation of the appropriate
<CODE>ManagerFactoryParameters</CODE> as defined by the
provider.  The provider can then call the specified methods in
the <CODE>ManagerFactoryParameters</CODE> implementation to obtain the
needed information.

<p>For example, suppose the <code>TrustManagerFactory</code> 
provider requires initialization
parameters B, R, and S from any application that wishes to use that
provider. Like all providers that require initialization parameters
other than a KeyStore, the provider will require that the application 
provide an instance of a class that implements a particular
<code>ManagerFactoryParameters</code> sub-interface.
In our example, suppose the provider requires that the calling application 
implement and create an instance of <code>MyTrustManagerFactoryParams</code> 
and pass it to the second <code>init</code>. Here is what 
<code>MyTrustManagerFactoryParams</code> may look like:

<blockquote>
<pre>
public interface MyTrustManagerFactoryParams extends 
       ManagerFactoryParameters {
    public boolean getBValue();
    public float getRValue();
    public String getSValue():
}
</pre>
</blockquote>

<p>Some trustmanagers are 
capable of making trust decisions without having
to be explicitly initialized with a KeyStore object or any other parameters. 
For example, they may access
trust material from a local directory service via LDAP, may use a
remote online certificate status checking server, or may access default
trust material from a standard local location.  

</blockquote>
</blockquote>



<a name="X509TrustManager"></a>
<H3><code>X509TrustManager</code> Interface</H3>

<blockquote>

<P> The <code>javax.net.ssl.X509TrustManager</code> interface extends
the general <code>TrustManager</code> interface.
This interface must be implemented by a trust manager when 
using X.509-based authentication.

<P> In order to support X.509 authentication of remote socket peers
through JSSE, an instance of this interface must be passed to the
<code>init</code> method of an <code>SSLContext</code> object.


<H4>Creating an <code>X509TrustManager</code></H4>

<blockquote>
You can either implement this interface directly yourself or
obtain one from a provider-based <code>TrustManagerFactory</code> (such as
that supplied by the <code>SunJSSE</code> provider).  You could also
implement your own that delegates to a factory-generated trust manager.
For example, you might do this in order to filter the resulting trust decisions
and query an end-user through a graphical user interface.

<p><B>Note:</B> If a null KeyStore parameter is passed to the <code>SunJSSE</code> default
"SunX509" <code>TrustManagerFactory</code>, the factory uses the
following steps to try to find trust material:

<ol>

<li>If the <a href="#SystemProps">system property</a>:

<blockquote>
<pre>
javax.net.ssl.trustStore
</pre>
</blockquote>

is defined, then the <code>TrustManagerFactory</code> attempts to find a
file using the filename specified by that system property, and uses that
file for the KeyStore. If the <code>javax.net.ssl.trustStorePassword</code>
system property is also defined, its value is used to check
the integrity of the data in the truststore before opening it.

<p>If <code>javax.net.ssl.trustStore</code> is defined
but the specified file does not exist, then a default
<code>TrustManager</code> using an empty keystore is created.  <P>

<li> If the <code>javax.net.ssl.trustStore</code> system property 
was not specified, then if the file

<blockquote>
<pre>
&lt;java-home&gt;/lib/security/jssecacerts
</pre>
</blockquote>

exists, that file is used. (See
<a href="#javaHome">The Installation Directory &lt;java-home&gt;</a>
for information about what <code>&lt;java-home&gt;</code> refers to.)
Otherwise,<P>

<li>If the file

<blockquote>
<pre>
&lt;java-home&gt;/lib/security/cacerts
</pre>
</blockquote>

exists, that file is used.

</ol>

<P> (If none of these files exists, that may be okay because there
are SSL cipher suites which are anonymous, that is, which don't do
any authentication and thus don't need a truststore.)

<p>The factory looks for a file specified via the security property
<code>javax.net.ssl.trustStore</code> or for the
<code>jssecacerts</code> file before checking for
a <code>cacerts</code>
file so that you can provide a JSSE-specific set of trusted root
certificates separate from ones that might be present in
<code>cacerts</code> for code-signing purposes.

</blockquote>

<A NAME="OwnX509TM"></A>
<H4>Creating Your Own <code>X509TrustManager</code></H4>

<blockquote>
If the default <code>X509TrustManager</code> behavior isn't suitable
for your situation, you can create your own <code>X509TrustManager</code> by
either creating and registering your own <code>TrustManagerFactory</code> or by
implementing the <code>X509TrustManager</code> interface directly.

<P>
The following <code>MyX509TrustManager</code> class enhances the 
default <code>SunJSSE</code> <code>X509</code> <code>TrustManager</code> 
behavior by providing alternative authentication logic when 
the default <code>SunJSSE</code> <code>X509</code> 
<code>TrustManager</code> fails.

<blockquote>
<pre>
class MyX509TrustManager implements X509TrustManager {

    X509TrustManager sunX509TrustManager;

    MyX509TrustManager() {
        // create sunX509TrustManager
        //
        // for example:
        //     Create/load a keystore
        //     Get instance of a "SunX509" TrustManagerFactory "tmf"
        //     init the TrustManagerFactory with the keystore

        sunX509TrustManager = tmf.getTrustManagers()[0]
    }

    ... // checkClientTrusted method omitted

    public void checkServerTrusted(X509Certificate[] chain,
                                   String authType)
                                   throws CertificateException) {
        try {
            sunX509TrustManager.checkServerTrusted(chain, authType);
        } catch (CertificateException excep) {
            // do any special handling, such as popping up
            // dialog boxes, prompting the user, etc.
        }
    }

    public X509Certificate[] getAcceptedIssuers() {
        return sunJSSETrustManager.getAcceptedIssuers();
    }
}
</pre>
</blockquote>
Once you have created such a trust manager, assign it to an
<code>SSLContext</code> via the <code>init</code> method.  Future 
<code>SocketFactories</code> created from this <code>SSLContext</code> 
will use your new <code>TrustManager</code> when making trust decisions.

<blockquote>
<pre>
TrustManager[] myTM = new TrustManager [] { 
                             new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTM, null);
</pre>
</blockquote>
</blockquote>
     
<H4>Updating the <code>keyStore</code> Dynamically</H4>
<blockquote>
     You can enhance <code>MyX509TrustManager</code> to handle dynamic keystore 
     updates. When a <code>checkClientTrusted</code> or 
     <code>checkServerTrusted</code> test fails and does not 
     establish a trusted certificate chain, you can add
     the required trusted certificate to the keystore.
     You need to create a new <code>sunX509TrustManager</code> from the 
     <code>TrustManagerFactory</code> initialized with the updated keystore. 
     When you establish a new connection (using the previously initialized 
     <code>SSLContext</code>), the newly added certificate will be called to make 
     the trust decisions.
</blockquote>


</blockquote>


<a name="KeyManager"></a>
<H3><code>KeyManager</code> Class</H3>

<blockquote>

<P> 
The primary responsibility of the <code>KeyManager</code> is to select the 
authentication credentials that will eventually be sent to the remote host. 
To authenticate yourself (a local secure socket peer) to
a remote secure socket peer, you need to initialize an
<code>SSLContext</code> object with one or more
<code>KeyManager</code>s.  You need to pass one <code>KeyManager</code>
for each different authentication mechanism that will be supported. If
null is passed into the <code>SSLContext</code> initialization, an empty 
<code>KeyManager</code> will be created.  If the internal default
context is used, a <a href="#CustomizingStores">default <code>KeyManager</code></A>
is created. Typically, there is a single key manager that supports
authentication based on <code>X.509</code> public key certificates. Some secure
socket implementations may also support authentication based on shared
secret keys, Kerberos, or other mechanisms.
</blockquote>

<a name="KeyManagerFactory"></a>
<H3><code>KeyManagerFactory</code> Class</H3>

<blockquote>

<p><code>javax.net.ssl.KeyManagerFactory</code> is an engine class
for a provider-based service that acts as a factory for one or more
types of <code>KeyManager</code> objects. The <code>SunJSSE</code>
provider implements a factory which can return a basic X.509 key
manager.  Because it is provider-based, additional factories can be
implemented and configured to provide additional or alternate key
managers.


<H4>Creating a <code>KeyManagerFactory</code></H4>

<blockquote>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name string
instead of a protocol name to the <code>getInstance</code> method:

<blockquote>
<pre>
public static KeyManagerFactory
                  getInstance(String algorithm);

public static KeyManagerFactory
                  getInstance(String algorithm,
                              String provider);

public static KeyManagerFactory
                  getInstance(String algorithm,
                              Provider provider);
</pre>
</blockquote>

<P> A sample algorithm name string is:

<blockquote><i><font face="Courier New,Courier">"SunX509"</font></i>
</blockquote>

<P> A sample call is the following:

<blockquote>
<pre>
KeyManagerFactory kmf =
    KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
</blockquote>

<P> The above call will create an instance of the <code>SunJSSE</code>
provider's default key manager factory, which provides basic
X.509-based authentication keys.

<p>A newly-created factory should be initialized by calling 
one of the <code>init</code> methods:

<blockquote>
<pre>
public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</pre>
</blockquote>

<p>You should call whichever <code>init</code> method is appropriate for
the KeyManagerFactory you are using. (Ask the provider vendor.)

<p>For many factories, such as the default "SunX509" 
<code>KeyManagerFactory </code> from the <code>SunJSSE</code> provider, the 
<code>KeyStore</code> and password are the only information required 
in order to initialize the <code>KeyManagerFactory</code> and thus the first 
<code>init</code> method is the appropriate one to call. The 
<code>KeyManagerFactory</code> will query the <code>KeyStore</code> for
information on which private key and matching public key certificates
should be used for authenticating to a remote socket peer.
The password parameter specifies the password that will be used with the 
methods for accessing keys from the <code>KeyStore</code>. All keys in the 
<code>KeyStore</code> must be protected by the same password. 

<p>In some cases, initialization parameters other than a <code>KeyStore</code>
and password may be needed by a provider.  Users of that particular provider
are expected to pass an implementation of the appropriate
<CODE>ManagerFactoryParameters</CODE> as defined by the
provider.  The provider can then call the specified methods in
the <CODE>ManagerFactoryParameters</CODE> implementation to obtain the
needed information.

<p>Some factories are capable of providing access to authentication
material without having to be initialized with a KeyStore object
or any other parameters. For example,
they may access key material as part of a login mechanism such as one based
on JAAS, the Java Authentication and Authorization Service.

<p>As indicated above, the <code>SunJSSE</code> provider supports a 
"SunX509" factory that must be initialized with a KeyStore parameter.

</blockquote>



</blockquote>


<a name="X509KeyManager"></a>
<H3><code>X509KeyManager</code> Interface</H3>

<blockquote>

The <code>javax.net.ssl.X509KeyManager</code> interface extends the
general <code>KeyManager</code> interface. It must be implemented by a
key manager for X.509-based authentication. In order to support X.509
authentication to remote socket peers through JSSE, an instance of this
interface must be passed to the <code>init</code> method of an
<code>SSLContext</code> object.


<H4>Creating an <code>X509KeyManager</code></H4>

<blockquote>
You can either implement this interface directly yourself or
obtain one from a provider-based <code>KeyManagerFactory</code> (such as
that supplied by the <code>SunJSSE</code> provider). You could also
implement your own that delegates to a factory-generated key manager.
For example, you might do this in order to filter the resulting keys and
query an end-user through a graphical user interface. 

<p>Note: If no KeyStore parameter is passed to the <code>SunJSSE</code> default
"SunX509" <code>KeyManagerFactory</code>, the factory tries
to find key material by consulting the
<a href="#SystemProps">system properties</a>

<blockquote>
<pre>
javax.net.ssl.keyStore
javax.net.ssl.keyStorePassword
</pre>
</blockquote>

If these properties specify a file with an appropriate
password, the factory uses this file for the KeyStore.  
If that file does not exist, then a default
<code>KeyManager</code> using an empty keystore is created. 

<p> Generally, the process acting as the server in the handshake
will need a keystore for its KeyManager in order to obtain
credentials for authentication to the client.  However, if one
of the anonymous cipher suites is selected, the server's
<code>KeyManager</code> keystore is not necessary.  And, unless the server
requires client authentication, the process acting as the
client will not need a <code>KeyManager</code> keystore. Thus, in these
situations it may be okay if there is no
<code>javax.net.ssl.keyStore</code> system property
value defined.
</blockquote>

<H4>Creating Your Own <code>X509KeyManager</code></H4>

<blockquote>
If the default <code>X509KeyManager</code> behavior isn't suitable
for your situation, you can create your own <code>X509KeyManager</code> in
a way similiar to that shown in 
<A HREF="#OwnX509TM">Creating Your Own <code>X509TrustManager</code></A>.
</blockquote>



</blockquote>

<A NAME="RelsTM_KM"></A>
<H3>Relationships between <code>TrustManager</code>s and <code>KeyManager</code>s</H3>

<blockquote>
Historically there has been confusion regarding the jobs 
of <code>TrustManager</code>s and <code>KeyManager</code>s.  
In summary, here are the primary responsibilities of each manager type:
<blockquote>
<TABLE summary="manager types and funtions" WIDTH="400" BORDER="1" CELLSPACING="2" CELLPADDING="0">
  <Thead>
      <TH WIDTH="30%">
      <B>Type</B></TH>
      <TH WIDTH="70%">
      <B>Function</B></TH>
  </THEAD>
  <TR>
      <TD WIDTH="30%">
      <CODE>TrustManager</CODE></TD>
      <TD WIDTH="70%">
      Determines whether the remote authentication credentials (and
      thus the connection) should be trusted.</TD>
  </TR>
  <TR>
      <TD WIDTH="30%">
      <CODE>KeyManager</CODE></TD>
      <TD WIDTH="70%">
        Determines which authentication credentials to send to the remote host.</TD>
  </TR>
</TABLE>
</blockquote>

</blockquote>

<BR>

<a name="SecondarySupportClasses"></a>
<H2>Secondary Support Classes and Interfaces</H2>

<blockquote>

<P> These classes are provided as part of the JSSE API to support
the creation, use, and management of secure sockets.
They are less likely to be used by secure socket applications
than are the core and support classes. The secondary support classes and 
interfaces are part of the <code>javax.net.ssl</code> and
<code>javax.security.cert</code> packages.


<a name="SSLSessionContext"></a>
<H3><code>SSLSessionContext</code> Interface</H3>

<blockquote>

<P> A <code>javax.net.ssl.SSLSessionContext</code> is a grouping of
<a href="#SSLSession"><code>SSLSession</code></a>s
associated with a single entity. For example, it could be associated
with a server or client that participates in many sessions
concurrently. The methods on this interface enable the
enumeration of all sessions in a context and allow lookup of specific sessions
via their session ids.

<P> An <code>SSLSessionContext</code> may optionally be obtained from an
<code>SSLSession</code> by calling the SSLSession
<code>getSessionContext</code> method.  The context may be unavailable
in some environments, in which case the <code>getSessionContext</code>
method returns null.

</blockquote>


<a name="SSLSessionBindingListener"></a>
<H3><code>SSLSessionBindingListener</code> Interface</H3>

<blockquote>

<P> <code>javax.net.ssl.SSLSessionBindingListener</code> is an
interface implemented by objects which want to be notified
when they are being bound or unbound from an
<a href="#SSLSession"><code>SSLSession</code></a>.

</blockquote>


<a name="SSLSessionBindingEvent"></a>
<H3><code>SSLSessionBindingEvent</code> Class</H3>

<blockquote>

<P> A <code>javax.net.ssl.SSLSessionBindingEvent</code> is the
event communicated to an
<a href="#SSLSessionBindingListener">
<code>SSLSessionBindingListener</code></a>
when it is bound or unbound from an
<a href="#SSLSession"><code>SSLSession</code></a>.

</blockquote>


<a name="HandShakeCompletedListener"></a>
<H3><code>HandShakeCompletedListener</code> Interface</H3>

<blockquote>
<P> <code>javax.net.ssl.HandShakeCompletedListener</code> is an
interface implemented by any class which wants to receive
notification of the completion of an SSL protocol handshake
on a given <code>SSLSocket</code> connection.

</blockquote>


<a name="HandShakeCompletedEvent"></a>
<H3><code>HandShakeCompletedEvent</code> Class</H3>

<blockquote>
<P> A <code>javax.net.ssl.HandShakeCompletedEvent</code> is the
event communicated to a
<a href="#HandShakeCompletedListener">
<code>HandShakeCompletedListener</code></a>
upon completion of an SSL protocol handshake
on a given <code>SSLSocket</code> connection.

</blockquote>

<a name="HostnameVerifier"></a>
<H3><code>HostnameVerifier</code> Interface</H3>
<blockquote>
If the SSL/TLS implementation's standard hostname verification logic 
fails, the implementation will call the <code>verify</code> method of the class 
which implements this interface and is assigned to this 
<code>HttpsURLConnection</code> instance.  
If the callback class can determine that 
the hostname is acceptable given the parameters, it should report
that the connection should be allowed.  An unacceptable
response will cause the connection to be terminated.
<P>
For example:

<blockquote>
<pre>
public class MyHostnameVerifier implements HostnameVerifier {

    public boolean verify(String hostname, SSLSession session) {
        // pop up an interactive dialog box
        // or insert additional matching logic
        if (good_address) {
            return true;
        } else {
            return false;
        }
    }
}

//...deleted...

HttpsURLConnection urlc = (HttpsURLConnection)
  (new URL("https://www.sun.com/")).openConnection();
urlc.setHostnameVerifier(new MyHostnameVerifier());
</pre>
</blockquote>

See <A HREF="#HttpsURLConnection"><code>HttpsURLConnection</code> Class</A> 
for more information
on how to assign the <code>HostnameVerifier</code> to the 
<code>HttpsURLConnection</code>.

</blockquote>

<a name="X509Certificate"></a>
<H3><code>X509Certificate</code> Class</H3>

<blockquote>

<P> Many secure socket protocols perform authentication using
public key certificates, also called X.509 certificates.
This is the default authentication mechanism for the
SSL and TLS protocols.

<P> The <code>java.security.cert.X509Certificate</code> abstract
class provides a standard way to access the attributes
of X.509 certificates.

<P> Note: The <code><b>javax</b>.security.cert.X509Certificate</code> class
is supported only for backward compatibility with previous
(1.0.x and 1.1.x) versions of JSSE. New applications should use 
<code><b>java</b>.security.cert.X509Certificate</code>,
not <code>javax.security.cert.X509Certificate</code>.

</blockquote>

</blockquote>


<a name="ConfigurationClasses"></a>
<H2>Previous (JSSE 1.0.x) Implementation Classes and Interfaces</H2>

<blockquote>

<p>In previous (1.0.x) versions of JSSE, there was a reference implementation
whose classes and interfaces were provided in the <code>com.sun.net.ssl</code> 
package.

<p>Now JSSE has been integrated into the J2SDK, v 1.4. The classes formerly in 
<code>com.sun.net.ssl</code> have been promoted to the
<code>javax.net.ssl</code> package and are now a part of the standard JSSE API.

<p>For compatibility purposes the <code>com.sun.net.ssl</code> classes and 
interfaces still exist, but have been deprecated. 
Applications written using them can run in the J2SDK, v 1.4 
without being recompiled. This may change in a future release; these 
classes/interfaces may be removed. Thus, all new applications should be
written using the <code>javax</code> classes/interfaces.

<p>For now, applications written using the <code>com.sun.net.ssl</code> 
API can utilize <i>either</i> JSSE 1.0.2 providers (ones using 
<code>com.sun.net.ssl</code>) <i>or</i> JSSE providers 
written for the J2SDK, v 1.4 (ones using the <code>javax</code> API). 
However, applications written using the
JSSE API in the J2SDK, v 1.4 can only utilize JSSE providers written for 
the J2SDK, v 1.4. This new release contains some new
functionality and attempting to access such functionality on a provider 
that doesn't supply it wouldn't work. <code>SunJSSE</code>, provided with 
the J2SDK from Sun Microsystems, is a provider written using the 
<code>javax</code> API. 

<p>You can still obtain a <code>com.sun.net.ssl.HttpsURLConnection</code> 
if you update the URL search path by setting the 
<code>java.protocol.handler.pkgs</code> <code>System</code> property
as you did when using JSSE 1.0.2. For more information, see 
<A HREF="#HttpsURLConnectionEx">Code Using <code>HttpsURLConnection</code> Class...</A>
 in the Troubleshooting section.

</blockquote>

</blockquote>

</blockquote>


<br>



<a name="InstallationAndCustomization"></a>
<H1>Customizing JSSE</H1>

<blockquote>


<a name="javaHome"></a>
<H2>The Installation Directory &lt;java-home&gt;</H2>

<blockquote>

<P> The term <code>&lt;java-home&gt;</code> is used throughout this
document to refer to the directory where the 
Java 2 Runtime Environment (JRE) is
installed. It is determined based on whether you are running
JSSE on a JRE with or without the
Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 2 SDK installed.
Java 2 SDK includes the JRE, but it is located in a different
level in the file hierarchy.

<P> The following are some examples of which directories
<code>&lt;java-home&gt;</code> refers to:

<ul>

<li>On Solaris, if the Java 2 SDK is installed in
<code>/home/user1/j2sdk1.4.0</code>, then
<code>&lt;java-home&gt;</code> is

<blockquote>
<pre>
/home/user1/j2sdk1.4.0/jre
</pre>
</blockquote>

<P>

<li>On Solaris, if JRE is installed in
<code>/home/user1/j2re1.4.0</code> and the Java
2 SDK is <i>not</i> installed, then
<code>&lt;java-home&gt;</code> is

<blockquote>
<pre>
/home/user1/j2re1.4.0
</pre>
</blockquote>
<P>

<li>On Microsoft Windows platforms, if the Java 2 SDK is installed in
<code>C:\j2sdk1.4.0</code>, then
<code>&lt;java-home&gt;</code> is

<blockquote>
<pre>
C:\j2sdk1.4.0\jre
</pre>
</blockquote>
<P>

<li>On Microsoft Windows platforms, if the JRE is installed in
<code>C:\j2re1.4.0</code> and the Java 2
SDK is <i>not</i> installed, then
<code>&lt;java-home&gt;</code> is

<blockquote>
<pre>
C:\j2re1.4.0
</pre>
</blockquote>

</ul>

</blockquote>

<a name="Customization"></a>
<H2>Customization</H2>

<blockquote>

<P> JSSE includes an implementation that all users
can utilize. If desired, it is also possible to customize a number of
aspects of JSSE, plugging in different implementations or
specifying the default keystore, etc.
The table below summarizes which aspects can be customized, what the
defaults are, and which mechanisms are used to provide customization.
The first column of the table provides links to more detailed
descriptions of each designated aspect and how to customize it.

<P> Some of the customizations are done by setting system property or
security property values. Sections following the table explain
how to set such property values.

<blockquote>
<hr>
<b>IMPORTANT NOTE: Many of the properties shown in this table are
currently utilized by the JSSE implementation, but
there is no guarantee that they will continue to have the same names
and types (system or security) or even that they will exist at all in
future releases.  All such properties are flagged with an "*".  They
are documented here for your convenience for use with the JSSE
implementation.</b>
<hr> </blockquote>

<CENTER><B>JSSE Customization</B></CENTER><BR>

<TABLE summary="JSSE customization" BORDER CELLSPACING=1 CELLPADDING=7>

<THEAD><TH WIDTH="30%" VALIGN="TOP">
<B><P ALIGN="CENTER">Customizable Item</B></TH>
<TH WIDTH="30%" VALIGN="TOP">
<B><P ALIGN="CENTER">Default</B></TH>
<TH WIDTH="40%" VALIGN="TOP">
<B><P ALIGN="CENTER">How To Customize</B></TH>
</THEAD>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#X509CCust"><B>X509Certificate</B> implementation</a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>X509Certificate implementation from Sun Microsystems</TD>
<TD WIDTH="40%" VALIGN="TOP">
<I><P>cert.provider.x509v1</I> security property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#HTTPSCust"><B>HTTPS protocol</B> implementation</a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Implementation from Sun Microsystems</TD>
<TD WIDTH="40%" VALIGN="TOP">
<I><P>java.protocol.handler.pkgs</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#ProviderCust"><B>provider</B> implementation</a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>SunJSSE</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>A <I>security.provider.n= </I>line in security properties file.
See description.
</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default SSLSocketFactory implementation</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>SSLSocketFactory implementation from Sun Microsystems. 
</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>** <I>ssl.SocketFactory.provider</I> security property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default SSLServerSocketFactory implementation</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>SSLServerSocketFactory implementation from Sun Microsystems. 
</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>** <I>ssl.ServerSocketFactory.provider</I> security property</TD>
</TR>



<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default keystore</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>None.
</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.keyStore</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default keystore type</B></a>
</TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=2><P>KeyStore.getDefaultType()</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.keyStoreType</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default keystore password</B></a>
</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>None.</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.keyStorePassword</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default truststore</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>jssecacerts, if it exists. Otherwise, cacerts </TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.trustStore</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default truststore type</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=2><P>KeyStore.getDefaultType()</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.trustStoreType</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#CustomizingStores">
<B>default truststore password</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>None.</TD>
<TD WIDTH="40%" VALIGN="TOP">
<P>* <I>javax.net.ssl.trustStorePassword</I> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#DefaultKTMCust">
<B>default key manager factory algorithm name</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>"SunX509"</TD>
<TD WIDTH="40%" VALIGN="TOP">
<I>ssl.KeyManagerFactory.algorithm</I> security property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#DefaultKTMCust">
<B>default trust manager factory algorithm name</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>"SunX509"</TD>
<TD WIDTH="40%" VALIGN="TOP">
<I>ssl.TrustManagerFactory.algorithm</I> security property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default proxy host</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>None.</TD>
<TD WIDTH="40%" VALIGN="TOP">
* <i>https.proxyHost</i> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default proxy port</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>80</TD>
<TD WIDTH="40%" VALIGN="TOP">
* <i>https.proxyPort</i> system property</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default ciphersuites</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Determined by the socket factory</TD>
<TD WIDTH="40%" VALIGN="TOP">
* <i>https.cipherSuites</i> system property. This
contains a comma-separated list of cipher suite names specifying
which cipher suites to enable for use
on this <code>HttpsURLConnection</code>. See the
<a href="../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])">
SSLSocket setEnabledCipherSuites(String[])</a> method.</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default handshaking protocols</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Determined by the socket factory</TD>
<TD WIDTH="40%" VALIGN="TOP">
* <i>https.protocols</i> system property. This
contains a comma-separated list of protocol suite names specifying
which protocol suites to enable
on this <code>HttpsURLConnection</code>.  See the
<a href="../../../api/javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])">
SSLSocket setEnabledProtocols(String[])</a> method.</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<B>default https port</B></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>443</TD>
<TD WIDTH="40%" VALIGN="TOP">
* Customize via <code>port</code> field in the https URL.</TD>
</TR>

<TR><TD WIDTH="30%" VALIGN="TOP">
<a href="#JCECust">
<B>encryption algorithms used by SunJSSE provider</B></a></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>internal SunJSSE implementations</TD>
<TD WIDTH="40%" VALIGN="TOP">
Give JCE algorithm provider(s) a higher preference order
than the SunJSSE provider</TD>
</TR>

</TABLE>
</BLOCKQUOTE>

<blockquote>

<blockquote>

<P>* This property is currently used by the JSSE implementation.
It is not guaranteed to be examined and used by other implementations. If it
<I>is</I> examined by another implementation, that implementation
should handle it in the same manner as the JSSE implementation
does. There is no guarantee the property will continue to exist or be of the
same type (system or security) in future releases.

<p>** Due to U.S. export restrictions, the JSSE implementation in 
Sun Microsystems' Java 2 SDK, v 1.4 does not allow replacement of the 
default <code>SSLSocketFactory</code> or <code>SSLServerSocketFactory</code> 
implementations. Please see  the <A HREF="#pluggabilityNote">note on pluggability</A> 
in the Introduction. If you are using a different JSSE implementation that allows 
alternate SSL/TLS implementation, you do so by setting the specified security properties. 

</blockquote>
<br>

<p>Note that some items are customized by setting 
<code>java.lang.system</code> properties
while others are customized by setting <code>java.security.Security</code> 
properties. The following sections explain how to set values for both types 
of properties.


<a name="SystemProps"></a>
<H3>How to Specify a <code>java.lang.system</code> Property</H3>

<blockquote>

<P> Some aspects of JSSE may be customized by setting system
properties.
You can set a system property either statically or dynamically:

<ul>

<li>To set a system property statically, use the <code>-D</code> option
of the <code>java</code> command. For example, to run an application
named <code>MyApp</code> and set
the <code>javax.net.ssl.trustStore</code> system property
to specify a <a href="#CustomizingStores">truststore</a> named
"<code>MyCacertsFile</code>", type the following:

<blockquote>
<pre>
java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
</pre>
</blockquote>
<P>

<li>To set a system property dynamically, call the
<code>java.lang.System.setProperty</code> method in your code:

<blockquote>
<pre>
System.setProperty(<i>propertyName</i>,
    "<i>propertyValue</i>");
</pre>
</blockquote>

substituting the appropriate property name and value.
For example, a <code>setProperty</code> call corresponding to the
previous example for setting
the <code>javax.net.ssl.trustStore</code> system property
to specify a truststore named "<code>MyCacertsFile</code>" would be:

<blockquote>
<pre>
System.setProperty("javax.net.ssl.trustStore",
    "MyCacertsFile");
</pre>
</blockquote>

</ul>

</blockquote>


<a name="SecurityProps"></a>
<H3>How to Specify a <code>java.security.Security</code> Property</H3>

<blockquote>

<P> Some aspects of JSSE may be customized by setting security
properties.
You can set a security property either statically or dynamically:

<ul>

<li>To set a security property statically, add a line to
the security properties file. The security properties file is located at:

<blockquote>
<pre>
&lt;java-home&gt;/lib/security/java.security
</pre>
</blockquote>

where 
<tt>&lt;java-home&gt;</tt> refers to the directory where the
JRE runtime software is installed, as described in
<a href="#javaHome">The Installation Directory &lt;java-home&gt;</a>.

<P> To specify a security property value in the security properties file,
you add a line of the following form:

<blockquote>
<pre>
<i>propertyName</i>=<i>propertyValue</i>
</pre>
</blockquote>

<P> For example, suppose you want to specify a different key manager 
factory algorithm name than the "SunX509" default.
You do this by specifying the algorithm name as the value of a security property 
named <code>ssl.KeyManagerFactory.algorithm</code>.
Suppose you want to set the value to "MyX509". To do so,
place the following in the security properties file:

<blockquote>
<pre>
ssl.KeyManagerFactory.algorithm=MyX509
</pre>
</blockquote>

<P>


<li>To set a security property dynamically, call the
<code>java.security.Security.setProperty</code> method in
your code:

<blockquote>
<pre>
Security.setProperty(<i>propertyName</i>,
    "<i>propertyValue</i>");
</pre>
</blockquote>

substituting the appropriate property name and value.
For example, a <code>setProperty</code> call corresponding to the
previous example for specifying the key manager 
factory algorithm name 
would be:

<blockquote>
<pre>
Security.setProperty("ssl.KeyManagerFactory.algorithm",
    "MyX509");
</pre>
</blockquote>

</ul>

</blockquote>



<a name="X509CCust"></a>
<H3>Customizing the X509Certificate Implementation</H3>

<blockquote>

<P>The X509Certificate implementation returned by the
<code>X509Certificate.getInstance</code> method is by default
the implementation from the JSSE implementation.

<P> You can optionally cause a different implementation to be
returned. To do so, specify the name (and package) of the alternate
implementation's class as the value of a
<a href="#SecurityProps">security property</a>
named <code>cert.provider.x509v1</code>.
For example, if the class is called <code>MyX509CertificateImpl</code> and
it appears in the <code>com.cryptox</code> package,
you should place the following in the security properties file:

<blockquote>
<pre>
cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</pre>
</blockquote>

</blockquote>


<a name="HTTPSCust"></a>
<H3>Specifying an Alternate HTTPS Protocol Implementation</H3>

<blockquote>

<P> You can communicate securely with an SSL-enabled web server
by using the "https" URL scheme for the
<code>java.net.URL</code> class.  The J2SDK provides a default
https URL implementation.

<p>If you want an alternate https protocol implementation to be
used, set the <code>java.protocol.handler.pkgs</code> <a
href="#SystemProps">system property</a> to include the new
class name.  This action causes the specified classes to be
found and loaded before the J2SDK default classes.  See the
<code>java.net.URL</code> class documentation for details.

<p> <b>Note to previous JSSE users:</b>  In past Sun JSSE
releases, you had to set the
<code>java.protocol.handler.pkgs</code> system property during
JSSE installation.  This step is no longer required unless 
you wish to obtain an instance of 
<code>com.sun.net.ssl.HttpsURLConnection</code>.
For more information, see 
<A HREF="#HttpsURLConnectionEx">Code Using <code>HttpsURLConnection</code> Class...</A>
 in the Troubleshooting section.

</blockquote>


<a name="ProviderCust"></a>
<H3>Customizing the Provider Implementation</H3>

<blockquote>

<P> The J2SDK, v 1.4 release comes standard with
a JSSE Cryptographic Service Provider, or
<i>provider</i> for short, named "<code>SunJSSE</code>". Providers are
essentially packages that implement one or more engine classes for
specific cryptographic algorithms.  The JSSE engine classes are
<code>SSLContext</code>, <code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code>.  For more information on providers
and engine classes, see the "Design Principles" and "Concepts" sections
of the <a
href="../CryptoSpec.html">
Java<SUP><FONT SIZE="-2">TM</FONT></SUP> Cryptography Architecture API
Specification & Reference</a>.

<P> In order to be used, a provider must be registered, either
statically or dynamically. You do not need to register the "SunJSSE" 
provider because it is pre-registered. If you want to use other
providers, read the following sections to see how to register
them.


<H4>Registering the Cryptographic Service Provider Statically</H4>

<blockquote>

You register a provider statically by adding a line of the following
form to the <a href="#SecurityProps">security properties file</a>:

<blockquote>
<pre>
security.provider.<i>n</i>=<i>providerClassName</i>
</pre>
</blockquote>

<P> This declares a provider, and specifies its preference order "n".
The preference order is the order in which providers are
searched for requested algorithms (when no specific provider is
requested).  The order is 1-based; 1 is the most preferred,
followed by 2, and so on.

<P> The <i>providerClassName</i> is the fully qualified name of the
provider class. You get this name from the provider vendor.

<P> To register a provider, add the above line to the security properties 
file, replacing <i>providerClassName</i> with the fully qualified
name of the provider class and substituting <i>n</i> with the priority 
that you would like to assign to the provider.

<p>The standard security provider and the
SunJSSE provider shipped with the Java 2 platform 
are automatically registered for you; the following
lines appear in the <code>java.security</code> security properties file
to register the standard security provider with preference order 1 and 
the SunJSSE provider with preference order 2:

<blockquote>
<pre>
security.provider.1=sun.security.provider.Sun
security.provider.2=com.sun.net.ssl.internal.ssl.Provider
</pre>
</blockquote>

<P> To utilize another JSSE provider, add a line registering the
alternate provider, giving it whatever preference order you prefer.

<P> You can have more than one JSSE provider registered at the
same time. They may include different implementations for
different algorithms for different engine classes, or they may
have support for some or all of the same types of algorithms and
engine classes. When a particular engine class
implementation for a particular algorithm is searched for,
if no specific provider is specified for the search, the providers are
searched in preference order and
the implementation from the first provider
that supplies an implementation for the specified algorithm is used.

</blockquote>


<H4>Registering the Cryptographic Service Provider Dynamically</H4>

<blockquote>

<P> Instead of registering a provider statically, you can add the
provider dynamically at runtime by calling the
<code>Security.addProvider</code> method at the beginning of your
program.  For example, to dynamically add a provider whose 
Provider class name is <code>MyProvider</code> and whose <code>MyProvider</code>
class resides in the <code>com.ABC</code> package, you would call:

<blockquote>
<pre>
Security.addProvider(
  new com.ABC.MyProvider());
</pre>
</blockquote>

<P> The <code>Security.addProvider</code> method adds the specified
provider to the next available preference position.

<P> This type of registration is not persistent and can only be
done by a program with sufficient permissions.

</blockquote>

</blockquote>




<a name="CustomizingStores"></a>
<H3>Customizing the Default Key and Trust Stores, Store Types, and
Store Passwords</H3>

<blockquote>

<P> Whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created (via a call to
<code>SSLSocketFactory.getDefault</code> or
<code>SSLServerSocketFactory.getDefault</code>), and this default
<code>SSLSocketFactory</code> (or <code>SSLServerSocketFactory</code>)
comes from the JSSE reference implementation, a default
<code>SSLContext</code> is associated with the socket factory. (The
default socket factory will come from the JSSE implementation.)

<P> This default <code>SSLContext</code> is initialized with a default 
<code>KeyManager</code> and a <code>TrustManager</code>. If a <a href=""
"#Stores">keystore</a> is specified by the
<code>javax.net.ssl.keyStore</code> <a href="#SystemProps">system
property</a>, then the <code>KeyManager</code> created by the default
<code>SSLContext</code> will be a <code>KeyManager</code>
implementation for managing the specified keystore.  (The actual
implementation will be as specified in <a
href="#DefaultKTMCust">Customizing the Default Key and Trust
Managers</a>.) If no such system property is specified, then the
keystore managed by the <code>KeyManager</code> will be a new empty
keystore.

<P> Similarly, if a truststore is specified by the
<code>javax.net.ssl.trustStore</code> system property, then the
<code>TrustManager</code> created by the default
<code>SSLContext</code> will be a <code>TrustManager</code>
implementation for managing the specified truststore.  In this case, if
such a property exists but the file it specifies doesn't, then no
truststore is utilized.  If no <code>javax.net.ssl.trustStore</code>
property exists, then a default truststore is searched for.  If a
truststore named
<code>&lt;java-home&gt;/lib/security/jssecacerts</code> is found, it is
used. If not, then a truststore named
<code>&lt;java-home&gt;/lib/security/cacerts</code> is searched for and
used (if it exists).  See <a href="#javaHome">The Installation
Directory &lt;java-home&gt;</a> for information as to what
<code>&lt;java-home&gt;</code> refers to.  Finally, if a truststore is
still not found, then the truststore managed by the
<code>TrustManager</code> will be a new empty truststore.

<blockquote>
<hr>
<b>IMPORTANT NOTE:  

The J2SDK ships with a limited number of trusted root certificates in
the <code>&lt;java-home&gt;/lib/security/cacerts</code> file.  As
documented in
<a href="../../../tooldocs/tools.html#security">keytool</a>, it is your
responsibility to maintain (that is, add/remove) the certificates
contained in this file if you use this file as a truststore.

<P>

Depending on the certificate configuration of the servers you contact,
you may need to add additional root certificate(s).  Obtain the
needed specific root certificate(s) from the appropriate vendor.

</b>
<hr> 
</blockquote>

<P> If system properties <code>javax.net.ssl.keyStoreType</code> and/or
<code>javax.net.ssl.keyStorePassword</code> are also specified, they
are treated as the default <code>KeyManager</code> keystore type and
password, respectively. If there is no type specified, the default type
is that returned by <code>KeyStore.getDefaultType()</code>, which is
the value of the <code>keystore.type</code> <a href=""
"#SecurityProps">security property</a>, or "jks" if no such security
property is specified.  If there is no keystore password specified, it
is assumed to be "".

<P> Similarly, if system properties <code>javax.net.ssl.trustStoreType</code>
and/or <code>javax.net.ssl.trustStorePassword</code>
are also specified, they are treated as the default truststore type and
password, respectively. If there is no type specified, the
default type is that returned by <code>KeyStore.getDefaultType()</code>.
If there is no truststore password specified,
it is assumed to be "".

<P> <b>Important Note:</b> This section describes the current
JSSE reference implementation behavior.
The system properties described in this section
are not guaranteed to continue to have the same names and types (system
or security) or even to exist at all in future releases.
They are also not guaranteed to be examined and used by any other
JSSE implementations. If they <I>are</I> examined by an implementation,
that implementation should handle them in the same manner as the
JSSE reference implementation does, as described herein.

</blockquote>


<a name="DefaultKTMCust"></a>
<H3>Customizing the Default Key and Trust Managers</H3>

<blockquote>

<P> As noted in <a href="#CustomizingStores"> Customizing the Default
Key and Trust Stores, Store Types, and Store Passwords</a>, whenever a
default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created, and this default
<code>SSLSocketFactory</code> (or <code>SSLServerSocketFactory</code>)
comes from the JSSE reference implementation, a default
<code>SSLContext</code> is associated with the socket factory.

<P> This default <code>SSLContext</code> is initialized with a
<code>KeyManager</code> and a <code>TrustManager</code>.  The
<code>KeyManager</code> and/or <code>TrustManager</code> supplied to
the default <code>SSLContext</code> will be a
<code>KeyManager</code>/<code>TrustManager</code> implementation for
managing the specified keystore/truststore, as described in the
aforementioned section.

<P> The <code>KeyManager</code> implementation chosen is determined by
first examining the

<blockquote>
<pre>
ssl.KeyManagerFactory.algorithm
</pre>
</blockquote>

<a href="#SecurityProps">security property</a>.
If such a property value is specified, a <code>KeyManagerFactory</code>
implementation for the specified algorithm is searched for. The
implementation from the first provider that supplies an implementation
is used. Its <code>getKeyManagers</code> method is called to determine
the <code>KeyManager</code> to supply to the default
<code>SSLContext</code>.  (Technically, <code>getKeyManagers</code>
returns an array of <code>KeyManager</code>s, one
<code>KeyManager</code> for each type of key material.) If there is no
such security property value specified, the default value of "SunX509"
is used to perform the search.  Note: A <code>KeyManagerFactory</code>
implementation for the "SunX509" algorithm is supplied by the
<code>SunJSSE</code> provider. The <code>KeyManager</code> it specifies
is a <code>javax.net.ssl.X509KeyManager</code> implementation.

<P> Similarly, the <code>TrustManager</code> implementation chosen is
determined by first examining the

<blockquote>
<pre>
ssl.TrustManagerFactory.algorithm
</pre>
</blockquote>

security property. If such a property value is specified, a
<code>TrustManagerFactory</code> implementation for the specified
algorithm is searched for. The implementation from the first provider
that supplies an implementation is used. Its
<code>getTrustManagers</code> method is called to determine the
<code>TrustManager</code> to supply to the default
<code>SSLContext</code>.  (Technically, <code>getTrustManagers</code>
returns an array of <code>TrustManager</code>s, one
<code>TrustManager</code> for each type of trust material.) If there is
no such security property value specified, the default value of
"SunX509" is used to perform the search.  Note: A
<code>TrustManagerFactory</code> implementation for the "SunX509"
algorithm is supplied by the <code>SunJSSE</code> provider. The
<code>TrustManager</code> it specifies is a
<code>javax.net.ssl.X509TrustManager</code> implementation.

<P> <b>Important Note:</b> This section describes the current JSSE
reference implementation behavior.  The system properties
described in this section are not guaranteed to continue to have the
same names and types (system or security) or even to exist at all in
future releases.  They are also not guaranteed to be examined and used
by any other JSSE implementations. If they <I>are</I> examined by
an implementation, that implementation should handle them in the same
manner as the JSSE reference implementation does, as described
herein.

</blockquote>


<a name="JCECust"></a>
<H3>Customizing the Encryption Algorithm Providers</H3>

<blockquote>

<p>The SunJSSE provider can make use of JCE providers for the encryption 
algorithms it uses (RSA, RC4, DES, and Triple DES). Previously, SunJSSE always 
made use of internal implementations for encryption algorithms.

<p>Now implementations from providers with a higher preference order than 
SunJSSE are used if available. Providers with a lower preference order are 
ignored in favor of the SunJSSE internal implementations. The 
<a href="../CryptoSpec.html#ProviderImplReq">standard JCA mechanism</a>
can be used to configure providers, either statically via the security
properties file 

<blockquote>
<pre>
&lt;java-home&gt;/lib/security/java.security
</pre>
</blockquote>

or dynamically via the <code>addProvider</code> or <code>insertProviderAt</code> 
method in the <code>java.security.Security</code> class. (See
<a href="#javaHome">The Installation Directory &lt;java-home&gt;</a>
for information about what <code>&lt;java-home&gt;</code> refers to.)
For example, a statement like 

<blockquote>
<pre>
Security.insertProviderAt(new MyProvider(), 2); 
</pre>
</blockquote>

ensures that <code>MyProvider</code> is searched for relevant encryption
algorithms prior to SunJSSE, assuming that the SunJSSE provider was initially 
configured as the second provider. Note that this is the 
case in the default configuration, and in that configuration Sun is specified
as the first provider. It is strongly recommended that you leave the Sun 
provider at position 1. 

<H3>Note for People Implementing Providers</H3>

<p>The transformation strings used when SunJSSE calls 
<code>Cipher.getInstance()</code> are "RSA/ECB/PKCS1Padding", "RC4", 
"DES/CBC/NoPadding", and "DESede/CBC/NoPadding". For further information
on the Cipher class and transformation strings see 
the <a href="../jce/JCERefGuide.html">JCE Reference Guide</a>.

</blockquote>


</blockquote>




<a name="KeystoreFormats"></a>
<h1>Additional Keystore Formats</h1>

<blockquote>

<P> The JSSE <code>SunJSSE</code> provider supplies an implementation of
the PKCS12 <code>java.security.KeyStore</code> format.
This format is also supported by other toolkits and applications
for importing and exporting keys and certificates. For example, Netscape
4.x (versions 4.04 and later) can export client certificates and keys into
a file using the ".p12" filename extension in PKCS12 format.

<p>With the <code>SunJSSE</code> provider, you can access
PKCS12 keys through the KeyStore API with a keystore type of "pkcs12"
(or "PKCS12", the name is case-insensitive). In addition, you can list
the installed keys using the <b>keytool</b> command with the
<code>-storetype</code> option set to <code>pkcs12</code>.  (See <a
href="../../../tooldocs/tools.html#security">Security Tools</a> for
information about <b>keytool</b>.)

<p>JSSE in the J2SDK, v 1.4 has limitations on its implementation but it
can read and use PKCS12 keystore files exported by Netscape Navigator.
Future releases will also support and be tested with Internet Explorer
and other applications.  See the README file for the release you are
using for information as to its PKCS12-handling capabilities.
</blockquote>
</blockquote>


<a name="Troubleshooting"></a>
<h1>Troubleshooting</h1>

<blockquote>

<a name="InstallProbs"></a>
<H2>Configuration Problems</H2>

<blockquote>


<H3> CertificateException:  (while handshaking) </H3>

<blockquote>

<P> <b>Problem</b>: When negotiating an SSL connection, the client or server
throws a CertificateException.

<P> <b>Cause 1</b>: This is generally caused by the remote side sending a
certificate that is unknown to the local side.

<P> <b>Solution 1</b>: The best way to
debug this type of problem is to turn on debugging (see 
<a href="#Debug">Debugging Utilities</a>) and watch 
as certificates are loaded and when certificates are 
received via the network connection.  Most likely, the 
received certificate is unknown to the trust mechanism because 
the wrong trust file was loaded. Refer the following sections 
for more information:
<UL>
 <li><A HREF="#ClassRelationship">Relationship Between Classes</A>
 <li><A HREF="#TrustManager"><code>TrustManager</code> Class</A>
 <li><A HREF="#KeyManager"><code>KeyManager</code> Class</A>
</UL>

<P> <b>Cause 2</b>: The system clock is not set correctly.
<P> <b>Solution 2</b>: If the clock is not set correctly, the perceived
time may be outside the validity period on one of the certificates,
and unless the certificate can be replaced with a valid one from a
truststore, the system must assume that the certificate is invalid,
and therefore throw the exception.

</blockquote>


<H3>Runtime Exception: SSL Service Not Available</H3>

<blockquote>

<P> <b>Problem</b>: When running a program that uses JSSE, an
exception occurs indicating that an SSL service is not available.
For example, an exception similar to one of the following occurs:

<pre>
    Exception in thread "main"
        java.net.SocketException: no SSL Server Sockets

    Exception in thread "main":
        SSL implementation not available
</pre>

<P> <b>Cause</b>: There was a problem with <code>SSLContext</code>
initialization, for example due to an incorrect
password on a keystore or a corrupted keystore. (Note: 
A J2SDK vendor once shipped a keystore in an unknown format, and that 
caused this type of error.)

<P> <b>Solution</b>: Check initialization parameters. Ensure any
keystores specified are valid and that the passwords specified are
correct. (One way you can check these things is by trying to use the
<a href="../../../tooldocs/tools.html#security">
keytool</a> to examine the keystore(s) and the relevant contents.)

</blockquote>

<A NAME="NoAvailCert"></A> 
<H3>Exception, "No available certificate corresponding to the SSL 
cipher suites which are enabled"</H3>
<blockquote>

<P> <b>Problem</b>: When I try to run a simple SSL Server program, the
following exception is thrown:
<blockquote>
<pre>
Exception in thread "main" javax.net.ssl.SSLException:
No available certificate corresponding to the SSL
cipher suites which are enabled...
</pre>
</blockquote>

<P> <b>Cause</b>: Various cipher suites require certain types of 
        key material.  For example, if an RSA cipher suite 
        is enabled, an RSA <code>keyEntry</code> must be available in 
        the keystore.  If no such key is available, this 
        cipher suite cannot be used.  If there are no available 
        key entries for all of the cipher suites enabled, this 
        exception is thrown. 

<P> <b>Solution</b>: Create key entries for the various cipher 
        suite types, or use an anonymous suite.  (Be 
        aware that anonymous ciphersuites are inherently dangerous 
        because they are vulnerable to "man-in-the-middle" attacks, see 
        <A HREF="http://www.ietf.org/rfc/rfc2246.txt?number=2246">RFC 2246</A>.) 
        Refer to the following sections to learn how to pass the 
      correct keystore and certificates: 
<UL>
 <li><A HREF="#ClassRelationship">Relationship Between Classes</A>
 <li><A HREF="#CustomizingStores">Customizing the Default Key and Trust Stores, Store Types, and Store Passwords</A>
 <li><A HREF="#KeystoreFormats">Additional Keystore Formats</A>
</UL>
 
</blockquote>


<H3>Runtime Exception: No Cipher Suites in Common</H3>
<blockquote>

<P> <b>Problem 1</b>: When handshaking, the client 
and/or server throw this exception.

<P> <b>Cause 1</b>: Both sides of an SSL connection must agree 
on a common ciphersuite.  If the intersection of the client's 
ciphersuite set with the server's ciphersuite set is empty, 
then you will see this exception.

<P> <b>Solution 1</b>: Configure the enabled cipher suites to 
include common ciphersuites, and be sure to provide an 
appropriate <code>keyEntry</code> for asymmetric ciphersuites. 
(See <A HREF="#NoAvailCert">Exception, "No available certificate..."</A> 
in this section.)

<P> <b>Problem 2</b>: When using Netscape Navigator or Microsoft
Internet Explorer (IE) to access files on a server that only has
DSA-based certificates, a runtime exception occurs indicating
that there are no cipher suites in common.

<P> <b>Cause 2</b>: By default, <code>keyEntries</code> 
created with keytool use DSA public keys.  If only DSA 
<code>keyEntries</code> exist in the keystore, 
only DSA-based ciphersuites can be used.  By 
default, Navigator and IE send only RSA-based ciphersuites.  Since the 
intersection of client and server ciphersuite sets is empty, 
this exception is thrown.

<P> <b>Solution 2</b>: To interact with Navigator or IE, you should create
certificates that use RSA-based keys. To do this, you need to specify
the <code>-keyalg</code> RSA option when using keytool. For
example:

<pre>
    keytool -genkey -alias duke -keystore testkeys -keyalg rsa
</pre>

</blockquote>


<H3>Slowness of the First JSSE Access</H3>
<blockquote>

<P> <b>Problem</b>: JSSE seems to stall on the first access.

<P> <b>Cause</b>: JSSE must have a secure source of random
numbers. The initialization takes a while.

<P> <b>Solution</b>: Provide an alternate generator of random
numbers, or initialize ahead of time when the overhead won't be
noticed:

<blockquote>
<pre>
SecureRandom sr = new SecureRandom();
sr.nextInt();
SSLContext.init(..., ..., sr);
</pre>
</blockquote>
</blockquote>

<A NAME="HttpsURLConnectionEx"></A>
<H3>Code Using <code>HttpsURLConnection</code> Class Throws 
    <code>ClassCastException</code> in JSSE 1.0.x</H3>
<blockquote>

<P> <b>Problem</b>: The following code snippet was written using JSSE 1.0.x's
<code>com.sun.net.ssl.HttpsURLConnection</code>.
<blockquote>
<pre>
import com.sun.net.ssl.*;
...deleted...
HttpsURLConnection urlc = new URL("https://foo.com/").openConnection();
</pre>
</blockquote>
When running under this release, this code returns a
<code>javax.net.ssl.HttpsURLConnection</code> and throws a 
<code>ClassCastException</code>. 

<P> <b>Cause</b>: By default, opening an "https" URL will create a
<code>javax.net.ssl.HttpsURLConnection</code>. 

<P> <b>Solution</b>: 
        Previous releases of the JDK (now known as the Java 2 SDK) 
      did not ship with an "https" URL 
        implemention.  The JSSE 1.0.x implementation did provide such an 
        "https" URL handler, and the installation guide described how to 
        set the URL handler search path to obtain a JSSE 1.0.x 
        <code>com.sun.net.ssl.HttpsURLConnection</code> implementation.
<P>
        In this release, there is now an "https" handler in the default 
        URL handler search path.  It returns an instance of 
        <code>javax.net.ssl.HttpsURLConnection</code>.  By prepending the old JSSE 1.0.x 
        implementation path to the URL search path via the 
        <code>java.protocol.handler.pkgs</code> variable, you can still obtain a 
        <code>com.sun.net.ssl.HttpsURLConnection</code>, and the code will no longer 
        throw cast exceptions.

<blockquote>
<pre>
% java -Djava.protocol.handler.pkgs=\
  com.sun.net.ssl.internal.www.protocol YourClass
</pre>
</blockquote>
or
<blockquote>
<pre>
System.setProperty("java.protocol.handler.pkgs", 
                   "com.sun.net.ssl.internal.www.protocol");
</pre>
</blockquote>


</blockquote>


<H3>Socket Disconnected after Sending <code>ClientHello</code> Message</H3>
<blockquote>

<P> <b>Problem</b>: A socket attempts to connect, sends a <code>ClientHello</code> 
message, and is immediately disconnected.

<P> <b>Cause</b>: Some SSL/TLS servers will disconnect if a <code>ClientHello</code> message
is received in a format it doesn't understand or with a protocol
version number that it doesn't support. 

<P> <b>Solution</b>: Try adjusting the protocols in
<code>SSLSocket.setEnabledProtocols</code>.
For example, some older server implementations speak only SSLv3 and do
not understand TLS. Ideally, these implementations should negotiate to SSLv3, 
but some simply hangup. 
For backwards compatibility, some server implementations (such as SunJSSE) 
send SSLv3/TLS <code>ClientHello</code>s encapsulated in a SSLv2 <code>ClientHello</code> packet.
Some servers do not accept this format, in these cases use <code>setEnabledProtocols</code>
to disable the sending of encapsulated SSLv2 <code>ClientHello</code>s.

</blockquote>

</blockquote>


<a name="Debug"></a>
<H2>Debugging Utilities</H2>

<blockquote>

<P> JSSE provides dynamic debug tracing support. This is similar
to the support used for debugging access control failures
in the Java 2 platform. The generic Java dynamic debug tracing
support is accessed with the system property
<code>java.security.debug</code>, while the JSSE-specific dynamic
debug tracing support is accessed with the system property
<code>javax.net.debug</code>.

<P> Note: The debug utility is not an officially supported
feature of JSSE.

<P> To view the options of the JSSE dynamic debug utility, use the
following command-line option on the <code>java</code> command:

<pre>
    -Djavax.net.debug=help
</pre>

<P> Note: If you specify the value <code>help</code> with either dynamic
debug utility when running a program that does not use
any classes that the utility was designed to debug, you
will not get the debugging options.

<P> Here is a complete example of how to get a list of the debug options:

<pre>
    java -Djavax.net.debug=help <i>MyApp</i>
</pre>

<P> where <i>MyApp</i> is an application that uses some of the JSSE classes.
<i>MyApp</i> will not run after the debug help information is printed,
as the help code causes the application to exit.

<P> Here are the current options:

<blockquote>
<pre>
all        turn on all debugging
ssl        turn on ssl debugging

The following can be used with ssl:
        record          enable per-record tracing
        handshake       print each handshake message
        keygen          print key generation data
        session         print session activity
        defaultctx      print default SSL initialization
        sslctx          print SSLContext tracing
        sessioncache    print session cache tracing
        keymanager      print key manager tracing
        trustmanager    print trust manager tracing

handshake debugging can be widened with:
        data            hex dump of each handshake message
        verbose         verbose handshake message printing

record debugging can be widened with:
        plaintext       hex dump of record plaintext
</pre>
</blockquote>

<P> The <code>javax.net.debug</code> property value must specify either
<code>all</code> or <code>ssl</code>, optionally followed by
debug specifiers. You can use one or more options.
You do <i>not</i> have to have a separator between options, although a
separator such as ":" or "," helps readability.
It doesn't matter what separators you use, and the ordering of
the option keywords is also not important.

<H3>Examples</H3>

<ul>

<li> To view all debugging messages:

<pre>
    java -Djavax.net.debug=all MyApp
</pre>

<P>


<li>To view the hexadecimal dumps of each handshake
message, you can type the following, where the colons are optional:

<pre>
    java -Djavax.net.debug=ssl:handshake:data MyApp
</pre>
<P>

<li>To view the hexadecimal dumps of each handshake
message, and to print trust manager tracing,
you can type the following, where the commas are optional:

<pre>
    java -Djavax.net.debug=SSL,handshake,data,trustmanager MyApp
</pre>

</ul>

</blockquote>

</blockquote>


<a name="CodeExamples"></a>
<h1>Code Examples</h1>

<blockquote>

<P> The sections below describe the following code examples:

<ul>

<li><a href="#UnsecureSecure">Converting an Unsecure Socket
to a Secure Socket</a>

<ul>
<li><a href="#NoSSLSocket">Socket Example <i>Without</i> SSL</a>

<li><a href="#WithSSLSocket">Socket Example <i>With</i> SSL</a><P>
</ul>

<li><a href="#SampleCode">Running the JSSE Sample Code</a>

<ul>
<li><a href="#SecureConnSample">Sample Code Illustrating a Secure Socket
Connection Between a Client and a Server</a>

<ul>
<li><a href="#SampleConfig">Configuration Requirements</a>

<li><a href="#SSC">Running <code>SSLSocketClient</code></a>

<li><a href="#SSCWT">Running
<code>SSLSocketClientWithTunneling</code></a>

<li><a href="#SSCWCA">Running
<code>SSLSocketClientWithClientAuth</code></a>

<li><a href="#RunningCFS">Running
<code>ClassFileServer</code></a> 

<li><a href="#SSCWCAnCFS">Running
<code>SSLSocketClientWithClientAuth</code> With
<code>ClassFileServer</code></a> 
</ul>

<li><a href="#HTTPSSample">Sample Code Illustrating HTTPS Connections</a>

<ul>
<li><a href="#URLReader">Running URLReader</a>

<li><a href="#URLReaderWO">Running URLReaderWithOptions</a>
</ul>

<li><a href="#RMISample">Sample Code Illustrating a Secure RMI
Connection</a>

</ul>

<BR>
<li><a href="#CreateKeystore">Creating a Keystore to Use with JSSE</A>
<ul>
<li><a href="#CreateSimpleKeystore">Creating a Simple Keystore and Truststore</A>
</ul>

</ul>



<a name="UnsecureSecure"></a>
<H2>Converting an Unsecure Socket to a Secure Socket</H2>

<blockquote>

<P> This section provides examples of source code that illustrate
how to use JSSE to convert an unsecure socket connection to
a secure socket connection. The code in this section is
excerpted from the book <i>Java 2 Network Security</i> by Marco
Pistoia, et. al.

<P> First, "Socket Example Without SSL" shows
sample code that can be used to set up communication
between a client and a server using unsecure sockets. This
code is then modified in "Socket Example With
SSL" to use JSSE to set up secure socket communication.

<a name="NoSSLSocket"></a>
<H3>Socket Example <i>Without</i> SSL</H3>

<blockquote>

<H4>Server Code for Unsecure Socket Communications</H4>

<P> When writing a Java program that acts as a server and communicates
with a client using sockets, the socket communication
is set up with code similar to the following:

<blockquote>
<pre>
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;

ServerSocket s;

try {
    s = new ServerSocket(port);
    Socket c = s.accept();

    OutputStream out = c.getOutputStream();
    InputStream in = c.getInputStream();

    // Send messages to the client through
    // the OutputStream
    // Receive messages from the client
    // through the InputStream
}

catch (IOException e) {
}
</pre>
</blockquote>


<H4>Client Code for Unsecure Socket Communications</H4>

<P> The client code to set up communication with a server using
sockets is similar to the following:

<blockquote>
<pre>
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
    s = new Socket(host, port);

    OutputStream out = s.getOutputStream();
    InputStream in = s.getInputStream();

    // Send messages to the server through
    // the OutputStream
    // Receive messages from the server
    // through the InputStream
}

catch (IOException e) {
}
</pre>
</blockquote>

</blockquote>


<a name="WithSSLSocket"></a>
<H3>Socket Example <i>With</i> SSL</H3>

<blockquote>

<H4>Server Code for Secure Socket Communications</H4>

<P> When writing a Java program that acts as a server and communicates
with a client using secure sockets, the socket communication
is set up with code similar to the following. Differences between this
program and the one for communication using unsecure sockets are
highlighted in bold.

<blockquote>
<pre>
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;

<b>SSLServerSocket</b> s;

try {
    <b>SSLServerSocketFactory sslSrvFact =
        (SSLServerSocketFactory)
        SSLServerSocketFactory.getDefault();
    s =(SSLServerSocket)sslSrvFact.createServerSocket(port);</b>

    <b>SSLSocket</b> c = <b>(SSLSocket)</b>s.accept();

    OutputStream out = c.getOutputStream();
    InputStream in = c.getInputStream();

    // Send messages to the client through
    // the OutputStream
    // Receive messages from the client
    // through the InputStream
}

catch (IOException e) {
}
</pre>
</blockquote>


<H4>Client Code for Secure Socket Communications</H4>

<P> The client code to set up communication with a server using
secure sockets is similar to the following, where differences with
the unsecure version are highlighted in bold:

<blockquote>
<pre>
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
    <b>SSLSocketFactory sslFact =
      (SSLSocketFactory)SSLSocketFactory.getDefault();
    SSLSocket s =
      (SSLSocket)sslFact.createSocket(host, port);</b>

    OutputStream out = s.getOutputStream();
    InputStream in = s.getInputStream();

    // Send messages to the server through
    // the OutputStream
    // Receive messages from the server
    // through the InputStream
}

catch (IOException e) {
}
</pre>
</blockquote>

</blockquote>

</blockquote>



<a name="SampleCode"></a>
<H2>Running the JSSE Sample Code</H2>

<blockquote>

<P> The JSSE sample programs illustrate how to use JSSE to:
<P>

<ul>

<li><a href="#SecureConnSample">
Create a secure socket connection between a client and a server</a>
<P>

<li><a href="#HTTPSSample">Create a secure connection to an HTTPS Web site</a>
<P>

<li><a href="#RMISample">Use secure communications with RMI</a>

</ul>

<P> When using the sample code, be aware that the sample programs
are designed to illustrate how to use JSSE. They are
not designed to be robust applications.

<P> Note: Setting up secure communications involves complex
algorithms. The sample programs provide no feedback
during the setup process. When running the
programs, be patient: you may not see any output for a
while. If you run the programs with the system
property <code>javax.net.debug</code> set to <code>all</code>, you will see
more feedback.


<a name="SamplesLoc"></a>
<H3>Where to Find the Sample Code</H3>

<blockquote>

<p>The sample code is located in the 
<a href = "samples/index.html">samples subdirectory</a>
of the same directory as that containing the document you are
reading. Follow that link to see a listing of all the samples
files and to link to the text files. That page also has a
zip file you can download to obtain all the samples files, which is
helpful if you are viewing this documentation from the web.

<p>The sections below describe the samples. See
the <a href = "samples/README.txt">README</a> for further information.

</blockquote>



<a name="SecureConnSample"></a>
<H3>Sample Code Illustrating a Secure Socket Connection
Between a Client and a Server</H3>

<blockquote>

<P> The sample programs in the <code>samples/sockets</code> 
directory illustrate how to set
up a secure socket connection between a client and a server.

<P> When running the sample client programs, you can communicate
with an existing server, such as a commercial Web
server, or you can communicate with the sample server program,
<code>ClassFileServer</code>. You can run the sample client
and the sample server programs on different machines connected
to the same network, or you can run them both on one
machine but from different terminal windows.

<P> All the sample <code>SSLSocketClient</code>* programs 
in the <code>samples/sockets/client</code> directory 
(and URLReader* programs described in <a href="#HTTPSSample">Sample Code
Illustrating HTTPS Connections</a>) can be run with the
<code>ClassFileServer</code> sample server program. 
An example of how to do this is shown in <a href="#SSCWCAnCFS">Running
<code>SSLSocketClientWithClientAuth</code> with
<code>ClassFileServer</code></a>.  You can make similar changes in
order to run <code>URLReader</code>, <code>SSLSocketClient</code> or
<code>SSLSocketClientWithTunneling</code> with
<code>ClassFileServer</code>.

<P> If an authentication error occurs while attempting to send messages
between the client and the server (whether using a web server or
<code>ClassFileServer</code>), it is most likely because the necessary
keys are not in the <a href="#Stores">truststore</a> (trust key
database).  For example, the <code>ClassFileServer</code> uses a
keystore called "testkeys" containing the private key for "duke" as
needed during the SSL handshake.  ("testkeys" is included in the same
<code>samples/sockets/server</code> 
directory as the <code>ClassFileServer</code> source.) If the client
cannot find a certificate for the corresponding public key of "duke" in
the truststore it consults, an authentication error will occur. Be sure
to use the <code>samplecacerts</code> truststore (which contains
"duke"s public key), as described in the next section.

<a name="SampleConfig"></a>
<H3>Configuration Requirements</H3>

<P> When running the sample programs that create a secure socket
connection between a client and a server, you will need to make the
appropriate certificates file (truststore) available. For both the
client and the server programs, you should use the certificates file
<code>samplecacerts</code> from the <code>samples</code>
directory.  Using this certificates file
will allow the client to authenticate the server.  The file contains
all the common Certification Authority certificates shipped with the J2SDK
(in the <code>cacerts</code> file), plus a certificate for "duke"
needed by the client to authenticate "duke" when communicating with the
sample server <code>ClassFileServer</code>.
(<code>ClassFileServer</code> uses a keystore containing the private
key for "duke" which corresponds to the public key in
<code>samplecacerts</code>. )

<P> To make the <code>samplecacerts</code> file available to both the client
and the server, you can either copy it to the file
<code>&lt;java-home&gt;/lib/security/jssecacerts</code>,
rename it <code>cacerts</code> and use it to replace the
<code>&lt;java-home&gt;/lib/security/cacerts</code> file,
or add the following
option to the command line when running the <code>java</code> command
for both the client and the server:

<pre>
-Djavax.net.ssl.trustStore=path_to_samplecacerts_file
</pre>

<p>(See
<a href="#javaHome">The Installation Directory &lt;java-home&gt;</a>
for information about what <code>&lt;java-home&gt;</code> refers to.)

<P> The password for the <code>samplecacerts</code> truststore
is <code>changeit</code>. You can substitute your own certificates
in the samples, using keytool.

<P> If you use a browser, such as Netscape Navigator or Microsoft's
Internet Explorer, to access the sample SSL server provided in the
<code>ClassFileServer</code> example, a dialog box may pop up with the
message that it does not recognize the certificate. This is normal
because the certificate used with the sample programs is self-signed
and is for testing only. You can accept the certificate for the current
session. After testing the SSL server, you should exit the browser,
which deletes the test certificate from the browser's namespace.

<blockquote>
<P> Note: The "duke" certificate in the <code>samples</code> directory is
different from the "duke" certificate available from the
security example provided on
<code>http://java.sun.com/security/signExample12/</code>.
If you have both "duke"
certificates installed, the sample code will not work properly.
To view the certificates available in your certificate
file, use the keytool command.

</blockquote>

<a name="SSC"></a>
<H3>Running <code>SSLSocketClient</code></H3>

<blockquote>

<P> The <a href = "samples/sockets/client/SSLSocketClient.java"> 
SSLSocketClient.java</a> program demonstrates how to create a client to use an
<code>SSLSocket</code> to send an HTTP request and to get a response
from an HTTPS server. The output of this program is the
HTML source for <code>https://www.verisign.com/index.html</code>.

<P> You must not be behind a firewall to run this program as shipped.
If you run it from behind a firewall, you will get an
<code>UnknownHostException</code> because JSSE can't find a path through
your firewall to <code>www.verisign.com</code>.  To create an
equivalent client that can run from behind a firewall, set up proxy
tunneling as illustrated in the sample program
<code>SSLSocketClientWithTunneling</code>.

</blockquote>


<a name="SSCWT"></a>
<H3>Running <code>SSLSocketClientWithTunneling</code></H3>

<blockquote>

<P> The <a href = "samples/sockets/client/SSLSocketClientWithTunneling.java"> 
SSLSocketClientWithTunneling.java</a> program illustrates how to do proxy 
tunneling to access a secure web server from behind a firewall. To run this 
program, you must set the following Java system properties to
the appropriate values:

<blockquote>
<pre>
java <FONT COLOR="blue">-Dhttps.proxyHost=webproxy
     -Dhttps.proxyPort=ProxyPortNumber</FONT>
     SSLSocketClientWithTunneling
</pre>
</blockquote>

<P> Note: Proxy specifications with the <code>-D</code> options 
(shown in blue) are optional. Also, be sure 
to replace <code>webproxy</code> with the name of your
proxy host and <code>ProxyPortNumber</code> with the appropriate
port number. 

<P> The program will return the HTML source file from
<code>https://www.verisign.com/index.html</code>.

</blockquote>


<a name="SSCWCA"></a>
<H3>Running <code>SSLSocketClientWithClientAuth</code></H3>

<blockquote>

<P> The <a href = "samples/sockets/client/SSLSocketClientWithClientAuth.java"> 
SSLSocketClientWithClientAuth.java</a> program shows how to set up a 
key manager to do client
authentication if required by a server. This program also assumes
that the client is not outside a firewall. You can modify the
program to connect from inside a firewall by following the
example in <code>SSLSocketClientWithTunneling</code>.

<P> To run this program, you must specify three parameters:
host, port, and requested file path. To mirror the previous
examples, you can run this program without client authentication
by setting the host to <code>www.verisign.com</code>, the port
to <code>443</code>, and the requested file path to
<code>https://www.verisign.com/</code>. The output when using these
parameters is the HTML for the Web site
<code>https://www.verisign.com/</code>.

<P> To run <code>SSLSocketClientWithClientAuth</code> to do client
authentication, you must access a server that requests client
authentication. You can use the sample program
<code>ClassFileServer</code> as this server. This is described in the
following sections.

</blockquote>


<a name="RunningCFS"></a>
<H3>Running <code>ClassFileServer</code></H3>

<blockquote>

<p>The program referred to herein as <code>ClassFileServer</code>
is made up of two files, 
<a href = "samples/sockets/server/ClassFileServer.java"> 
ClassFileServer.java</a> and
<a href = "samples/sockets/server/ClassServer.java"> 
ClassServer.java</a>.

<p>To execute them, run <code>ClassFileServer.class</code>, 
which requires the following parameters:
<P>

<ul>

<li><code>port</code> - The port parameter can be any available
unused port number, for example, you can use the
number 2001.
<P>

<li><code>docroot</code> - This parameter indicates the directory
on the server that contains the file you wish to retrieve. For example,
on Solaris, you can use <code>/home/userid/</code> (where <code>userid</code> 
refers to your particular user id), while
on Microsoft Windows systems, you can use <code>c:\</code>.
<P>

<li><code>TLS</code> - This is an optional parameter. When used, it
indicates that the server is to use SSL or TLS.
<P>

<li><code>true</code> - This is an optional parameter. When used,
client authentication is required. This parameter is
only consulted if the TLS parameter is set.

</ul>

<P> Note 1: The <code>TLS</code> and <code>true</code> parameters are optional.
If you leave them off, indicating that just an ordinary (not TLS) file server
should be used, without authentication, nothing happens.
This is because one side (the client) is trying to negotiate
with TLS, while the other (the server) isn't, so they can't
communicate.

<P> Note 2: The server expects GET requests in the form
"GET /...", where "..." is the path to the file.<P>

</blockquote>



<a name="SSCWCAnCFS"></a>
<H3>Running <code>SSLSocketClientWithClientAuth</code> With
<code>ClassFileServer</code></H3>

<blockquote>

<P> You can use the sample programs
<a href = "samples/sockets/client/SSLSocketClientWithClientAuth.java"> 
SSLSocketClientWithClientAuth</a> and
<code>ClassFileServer</code> to set up authenticated communication,
where the client and server are authenticated to each other. You can
run both sample programs on different machines connected to the same
network, or you can run them both on one machine but from different
terminal windows or command prompt windows. To set up both the client
and the server, do the following:

<ol>

<li>Run the program <code>ClassFileServer</code> from one
machine or terminal window, as described in
<a href="#RunningCFS">Running <code>ClassFileServer</code></a>. <p>

<li>Run the program <code>SSLSocketClientWithClientAuth</code> on
another machine or terminal window.
<code>SSLSocketClientWithClientAuth</code> requires the following
parameters:  <P>

<ul>

<li><code>host</code> - This is the hostname of the machine you are
using to run <code>ClassFileServer</code>.
<P>

<li><code>port</code> - This is the same port you specified for
<code>ClassFileServer</code>.
<P>

<li><code>requestedfilepath</code> - This parameter indicates
the path to the file you want to retrieve from the
server. You must give this parameter as <code>/filepath</code>.
Forward slashes are required in the file path because it is used as
part of a GET statement, which requires forward slashes
regardless of what type of operating system you are running.
The statement is formed as

<blockquote>
<pre>
"GET " + requestedfilepath + " HTTP/1.0"
</pre>
</blockquote>

</ul>

</ol>

NOTE: you can modify the other SSLClient* application's "GET" commands
to connect to a local machine running <code>ClassFileServer</code>.

</blockquote>

</blockquote>


<a name="HTTPSSample"></a>
<H3>Sample Code Illustrating HTTPS Connections</H3>

<blockquote>

<P> There are two primary APIs for accessing secure communications
through JSSE. One way is through a socket-level API which can be used for
arbitrary secure communications, as illustrated by the
<code>SSLSocketClient</code>, <code>SSLSocketClientWithTunneling</code>, and
<code>SSLSocketClientWithClientAuth</code> (with and without
<code>ClassFileServer</code>) sample programs.

<P> A second, and often simpler way, is through the standard Java URL API.
You can communicate securely with an SSL-enabled web server by using
the "https" URL protocol or scheme using the <code>java.net.URL</code> class.

<p>Support for "https" URL schemes is implemented in many of the
common browsers, which allows access to secured communications without
requiring the socket-level API provided with JSSE.

<p>An example URL might be:

<blockquote>
<i>"https://www.verisign.com"</i>
</blockquote>

<p>The trust and key management for the "https" URL implementation is
environment-specific. The JSSE implementation provides an "https"
URL implementation. If you want a different https protocol implementation 
to be used, you can set the <code>java.protocol.handler.pkgs</code>
<a href="#SystemProps">system property</a> to the package name.
See the <code>java.net.URL</code> class documentation for details.

<P> The samples that you can download with JSSE include
two sample programs that illustrate how to create
an HTTPS connection. Both of these sample programs are in
the <a href = "samples/urls/"> urls</a> directory.


<a name="URLReader"></a>
<H3>Running URLReader</H3>

<blockquote>

<P> The <a href = "samples/urls/URLReader.java"> 
URLReader.java</a> program illustrates using the URL class to access a
secure site. The output of this program is the HTML source
for <code>https://www.verisign.com/</code>.
By default, the HTTPS protocol implementation included with
JSSE in the J2SDK, v 1.4 will be utilized. If you want to use a
different implementation, you must set the system property 
<code>java.protocol.handler.pkgs</code> value to be the
name of the package containing the implementation. 

<P> If you are running the sample code behind a firewall, you
must set the system properties <code>https.proxyHost</code> and
<code>https.proxyPort</code>. For example, to use the proxy host
"webproxy" on port 8080, you can use the following options
to the <code>java</code> command:

<pre>
-Dhttps.proxyHost=webproxy

-Dhttps.proxyPort=8080
</pre>

<P> Alternatively, you can set the system properties within the
source code with the <code>java.lang.System</code> method
<code>setProperty</code>. For example, instead of using the command line
options, you can include the following
lines in your program:

<blockquote>
<pre>
System.setProperty("java.protocol.handler.pkgs",
    "com.ABC.myhttpsprotocol");

System.setProperty("https.proxyHost",
    "webproxy");

System.setProperty("https.proxyPort",
    "8080");
</pre>
</blockquote>

<P> Note: When running on Windows 95 or Windows 98, the
maximum number of characters allowed in an MS-DOS
prompt may not be enough to include all the command-line
options. If you encounter this problem, either create a
.bat file with the entire command or add the system
properties to the source code and recompile the source
code.

</blockquote>


<a name="URLReaderWO"></a>
<H3>Running URLReaderWithOptions</H3>

<blockquote>

<P> The <a href = "samples/urls/URLReaderWithOptions.java"> 
URLReaderWithOptions.java</a> program is essentially the same as URLReader,
except that it allows you to optionally input any or all of the following
system properties as arguments to the program when you
run it:
<P>

<ul>

<li>java.protocol.handler.pkgs
<P>

<li>https.proxyHost
<P>

<li>https.proxyPort
<P>

<li>https.cipherSuites

</ul>

<P> To run URLReaderWithOptions, type the following command
(all on one line):

<blockquote>
<pre>
java URLReaderWithOptions
     [-h proxyhost -p proxyport]
     [-k protocolhandlerpkgs]
     [-c ciphersarray]
     myApp
</pre>
</blockquote>

<P> Note: Multiple protocol handlers can be included in the
<code>protocolhandlerpkgs</code> in a list
with items separated by vertical bars. Multiple SSL cipher
suite names can be included in the <code>ciphersarray</code> in
a list with items separated by
commas. The possible cipher suite names are the same as those
returned by the call <code>SSLSocket.getSupportedCipherSuites()</code>.
The suite names are taken from the SSL and TLS protocol specifications.

<p>You only need a <code>protocolhandlerpkgs</code> argument if
you want to use an HTTPS protocol handler implementation other than
the default one provided by Sun Microsystems.

<P> If you are running behind a firewall, you must include
arguments for the proxy host and the proxy port. Additionally,
you can include a list of cipher suites to enable.

<p>Here is an example of running URLReaderWithOptions and
specifying the proxy host "webproxy" on port 8080:

<blockquote>
<pre>
java URLReaderWithOptions
    -h webproxy -p 8080
</pre>
</blockquote>

</blockquote>

</blockquote>


<a name="RMISample"></a>
<H3>Sample Code Illustrating a Secure RMI Connection</H3>

<blockquote>

<P> The sample code in the <code>samples/rmi</code> directory
illustrates how to create a
secure RMI connection. The sample code is based on an 
<a href="../../rmi/socketfactory/index.html">
RMI example</a> that is basically a "Hello World" example modified
to install and use a custom RMI socket factory. 

<P> For more information about RMI, see the 
<a href="../../rmi/">Java RMI documentation</a>.
This Web page points to RMI tutorials and other information about RMI.


</blockquote>

</blockquote>


<A NAME="CreateKeystore"></A>
<H2>Creating a Keystore to Use with JSSE</H2>
<BLOCKQUOTE>

<A NAME="CreateSimpleKeystore"></A>
<H3>Creating a Simple Keystore and Truststore</H3>
        <BLOCKQUOTE>
        In this section, we'll use <code>keytool</code> to create a 
      simple JKS keystore suitable for use with JSSE.  We'll make a 
      <code>keyEntry</code> (with public/private keys) in the 
      keystore, then make a corresponding <code>trustedCertEntry</code> 
      (public keys only) in a truststore.  (For client authentication, 
      you'll need to do a similar process for the client's certificates.)

        <BLOCKQUOTE>
        <B>Note:</B> It is beyond the scope of this example to explain each 
      step in detail. If you need more information, please see the keytool 
      documentation for 
      <A HREF="../../../tooldocs/solaris/keytool.html">Solaris</A> or 
      <A HREF="../../../tooldocs/windows/keytool.html">Microsoft Windows</A>.
        </BLOCKQUOTE>

        User input is shown in boldface font.
</BLOCKQUOTE>
<OL>

       <LI> Create a new keystore and self-signed certificate
         with corresponding public/private keys.

        <BLOCKQUOTE>
      <PRE>
% <B>keytool -genkey -alias duke -keyalg RSA \
  -validity 7 -keystore keystore </B>

 Enter keystore password:  <B>password</b>
 What is your first and last name?
 [Unknown]:  <B>Duke</B>
 What is the name of your organizational unit?
 [Unknown]:  <B>Java Software</B>
 What is the name of your organization?
 [Unknown]:  <B>Sun Microsystems, Inc.</B>
 What is the name of your City or Locality?
 [Unknown]:  <B>Palo Alto</B>
 What is the name of your State or Province?
 [Unknown]:  <B>CA</B>
 What is the two-letter country code for this unit?
 [Unknown]:  <B>US</B> 
 Is CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.",
 L=Palo Alto, ST=CA, C=US correct?
 [no]:  <B>yes</B>

 Enter key password for &lt;duke&gt;
  (RETURN if same as keystore password):  <B>&lt;CR&gt;</B>
      </PRE>
        </BLOCKQUOTE>

        This is the keystore that the server will use.

<P>

       <LI> Examine the keystore. Notice the entry type is
                <CODE>keyEntry</CODE> which means that this entry has a 
                private key associated with it (shown in red).

        <BLOCKQUOTE>
      <PRE>
% <B>keytool -list -v -keystore keystore</B>
Enter keystore password:  <B>password</B>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: duke
Creation date: Dec 20, 2001
Entry type: <FONT COLOR="red">keyEntry</FONT>
Certificate chain length: 1
Certificate[1]:
Owner: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", 
L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
      </PRE>
        </BLOCKQUOTE>

<P>


       <LI> Export and examine the self-signed certificate.
        <BLOCKQUOTE>
      <PRE>
% <B>keytool -export -alias duke -keystore keystore -rfc \
  -file duke.cer</B>
Enter keystore password:  <B>password</B>
Certificate stored in file &lt;duke.cer&gt;
% <B>cat duke.cer</B>
-----BEGIN CERTIFICATE-----       
MIICXjCCAccCBDwircEwDQYJKoZIhvcNAQEEBQAwdjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB  
MRIwEAYDVQQHEwlQYWxvIEFsdG8xHzAdBgNVBAoTFlN1biBNaWNyb3N5c3RlbXMsIEluYy4xFjAU
BgNVBAsTDUphdmEgU29mdHdhcmUxDTALBgNVBAMTBER1a2UwHhcNMDExMjIxMDMzNDI1WhcNMDEx
MjI4MDMzNDI1WjB2MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0
bzEfMB0GA1UEChMWU3VuIE1pY3Jvc3lzdGVtcywgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2Fy
ZTENMAsGA1UEAxMERHVrZTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1loObJzNXsi5aSr8
N4XzDksD6GjTHFeqG9DUFXKEOQetfYXvA8F9uWtz8WInrqskLTNzwXgmNeWkoM7mrPpK6Rf5M3G1
NXtYzvxyi473Gh1h9k7tjJvqSVKO7E1oFkQYeUPYifxmjbSMVirWZgvo2UmA1c76oNK+NhoHJ4qj
eCUCAwEAATANBgkqhkiG9w0BAQQFAAOBgQCRPoQYw9rWWvfLPQuPXowvFmuebsTc28qI7iFWm6BJ
TT/qdmzti7B5MHOt9BeVEft3mMeBU0CS2guaBjDpGlf+zsK/UUi1w9C4mnwGDZzqY/NKKWtLxabZ
5M+4MAKLZ92ePPKGpobM2CPLfM8ap4IgAzCbBKd8+CMp8yFmifze9Q==
-----END CERTIFICATE-----
      </PRE>
        </BLOCKQUOTE>

                Alternatively, you could generate Certificate Signing
                Request (CSR) with <CODE>-certreq</CODE> and send that to a
                Certificate Authority (CA) for signing, but again,
                that's beyond the scope of this example.
<P>


       <LI> Import the certificate into a new truststore.
<BLOCKQUOTE>
<PRE>
% <B>keytool -import -alias dukecert -file duke.cer \
  -keystore truststore</B>
Enter keystore password:  <B>trustword</B>
Owner: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
Trust this certificate? [no]:  <B>yes</B>
Certificate was added to keystore
      </PRE>
        </BLOCKQUOTE>


       <LI> Examine the truststore.  Note that the entry
                type is <code>trustedCertEntry</code>, which means that
                a private key is not available for this entry (shown in red). It also means 
            that this file is not suitable as a <code>KeyManager</code>'s
                keystore.
<BLOCKQUOTE>
<PRE>
% <B>keytool -list -v -keystore truststore</B> 
Enter keystore password:  <B>trustword</B>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: dukecert
Creation date: Dec 20, 2001
Entry type: <FONT COLOR="red">trustedCertEntry</FONT>

Owner: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
      </PRE>
        </BLOCKQUOTE>

        Now run your applications with the appropriate key stores.
        This example assumes the default <code>X509KeyManager</code> 
      and <code>X509TrustManager</code> are used, thus we will 
      select the keystores using the system properties described in
      <a href="#Customization">Customization</a>.
<BLOCKQUOTE>
<PRE>
% java -Djavax.net.ssl.keyStore=keystore \
  -Djavax.net.ssl.keyStorePassword=password Server

% java -Djavax.net.ssl.trustStore=truststore \
  -Djavax.net.ssl.trustStorePassword=trustword Client
</PRE>
</BLOCKQUOTE>

<BR>
<P>

</OL>

<HR>    
<b>Note:</b> In this example, we authenticated the server only. 
If client authentication is desired, you will
need to provide a similar keystore for the client's keys, and
an appropriate truststore for the server.
<HR>



</blockquote>
</blockquote>


<HR>

<H1><a name="AppA">Appendix A: Standard Names</a></H1>

<blockquote>

<!--insert table of standard names, including all 
    ciphersuites not supported-->

The <code>protocol</code> name parameter passed to the
<code>getInstance</code> method of <code>SSLContext</code> supports a
named secure socket protocol and optionally a named purpose separated
from the protocol name by a '/' character. The table below lists some
common standard protocol names.

<blockquote>

<table summary="standard protocol names" BORDER CELLSPACING=1 CELLPADDING=4 WIDTH="80%" >
<tr>
<th BGCOLOR="#dedeef">Protocol</th>

<th BGCOLOR="#dedeef">Comment</th>
</tr>

<tr>
<td>SSL</td>

<td>Supports some version of SSL; may support other versions</td>
</tr>

<tr>
<td>SSLv2</td>

<td>Supports SSL version 2 or higher</td>
</tr>

<tr>
<td>SSLv3</td>

<td>Supports SSL version 3; may support other versions</td>
</tr>

<tr>
<td>TLS</td>

<td>Supports some version of TLS; may support other versions</td>
</tr>

<tr>
<td>TLSv1</td>

<td>Supports TLS version 1; may support other versions</td>
</tr>
</table>

</blockquote>


<p>The <code>keyType</code> parameter passed to the
<code>chooseClientAlias</code>, <code>chooseServerAlias</code>,
<code>getClientAliases</code>, and <code>getServerAliases</code>
methods of <code>X509KeyManager</code> specify the public key type(s). 
Each row of the table below lists the standard name that should be used 
for <code>keyType</code>, given the specified certificate type.

<blockquote>

<table summary="standard names and types" BORDER CELLSPACING=1 CELLPADDING=4 WIDTH="80%" >
<tr>
<th BGCOLOR="#dedeef">Name</th>
<th BGCOLOR="#dedeef">Certificate Type</th>
<th BGCOLOR="#dedeef">Corresponds to (RFC 2246)</th>
</tr>

<tr>
<td>RSA</td>
<td>RSA</td>
<td>rsa_sign(1)</td>
</tr>

<tr>
<td>DSA</td>
<td>DSA</td>
<td>dss_sign(2)</td>
</tr>

<tr>
<td>DH_RSA</td>
<td>Diffie-Hellman with RSA signature</td>
<td>rsa_fixed_dh(3)</td>
</tr>

<tr>
<td>DH_DSA</td>
<td>Diffie-Hellman with DSA signature</td>
<td>dss_fixed_dh(4)</td>
</tr>

</table>

</blockquote>


<p>The <code>protocols</code> parameter passed to the
<code>setEnabledProtocols</code> method of <code>SSLSocket</code> 
specifies the protocol versions to be enabled for use on the connection. 
The table below lists the standard names that can be passed
to <code>setEnabledProtocols</code> or that may be returned by
the <code>SSLSocket getSupportedProtocols</code> and 
<code>getEnabledProtocols</code> methods.

<blockquote>

<table summary="standard names" BORDER CELLSPACING=1 CELLPADDING=4 WIDTH="80%" >
<tr>
<th BGCOLOR="#dedeef">Name</th>
<th BGCOLOR="#dedeef">Protocol</th>
</tr>

<tr>
<td>SSLv2</td>
<td>SSL version 2 protocol</td>
</tr>

<tr>
<td>SSLv3</td>
<td>SSL version 3 protocol</td>
</tr>

<tr>
<td>TLSv1</td>
<td>TLS version 1 protocol (defined in RFC 2246)</td>
</tr>

<tr>
<td>SSLv2Hello</td>
<td>Enables the sending of SSLv2 hellos. For compatibility reasons,
some protocols such as SSLv3 and TLSv1 allow sending SSLv3/TLSv1 hellos
encapsulated in an SSLv2 format hello.</td>
</tr>

</table>

</blockquote>


<p>The <code>authType</code> parameter passed to the
<code>checkClientTrusted</code> and <code>checkServerTrusted</code>
methods of <code>X509TrustManager</code> indicates 
the authentication type. 
The table below specifies what standard names should be used
for the client or server certificate chains.

<blockquote>

<table summary="standard names for certificate chains" BORDER CELLSPACING=1 CELLPADDING=4 WIDTH="80%" >
<tr>
<th BGCOLOR="#dedeef">Client or Server Certificate Chain</th>
<th BGCOLOR="#dedeef">Authentication Type Standard Name</th>
</tr>

<tr>
<td>Client</td>
<td>Determined by the actual certificate used. For instance, 
if RSAPublicKey is used, the <code>authType</code> should be "RSA".</td>
</tr>

<tr>
<td>Server</td>
<td>The key exchange algorithm portion of the cipher suites 
represented as a String, such as "RSA" or "DHE_DSS". Note: For some exportable 
cipher suites, the key exchange algorithm is determined at run time during the 
handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5, the 
<code>authType</code> should be "RSA_EXPORT" when an ephemeral RSA key is used 
for the key exchange, and "RSA" when the key from the server certificate is 
used. Or it can take the value "UNKNOWN".</td>
</tr>

</table>
</blockquote>
</blockquote>

<HR SIZE=3 NOSHADE>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>
<TD>
<P><FONT SIZE="-2">
   Copyright &#169; 1998-2003, Sun Microsystems, Inc.
   4150 Network Circle
   Santa Clara, California 95054
   All Rights Reserved.</FONT></P>

   <FONT SIZE="-1">
   Please send comments to: <a href="mailto:java-security@sun.com">java-security@sun.com</a>. This is not a subscription list.
   </FONT>
</TD>
</TR>
</TABLE>


</body>
</html>
