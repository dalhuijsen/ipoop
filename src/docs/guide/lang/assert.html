<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>Programming With Assertions</TITLE>
 <META content="MSHTML 6.00.2713.1100" name=GENERATOR>
</HEAD>

<BODY bgColor=#ffffff>
 <TABLE summary="layout" width="100%" border=0>
 <TBODY>
  <TR>
    <TD width=60>
   <IMG SRC="../../images/javalogo52x88.gif" ALT="Java" BORDER=0 WIDTH=52 HEIGHT=88>
    </TD>
    <TD>
      <div align=CENTER>
        <H1>Programming With Assertions</H1></div>
    </TD>
    <TD vAlign=top align=right>
      <FONT size=-1>
        <A href="../../index.html">Documentation 
            Contents</a>
      </FONT>
    </TD>
  </TR>
 </TBODY>
 </TABLE>

<HR>

<P>An <I>assertion</I> is a statement in the Java<font
size=-1><sup>TM</sup></font> programming language that enables you to test
your assumptions about your program.  For example, if you write a method that
calculates the speed of a particle, you might assert that the calculated speed
is less than the speed of light.

<p>Each assertion contains a boolean expression that you believe will be true
when the assertion executes.  If it is not true, the system will throw an
error.  By verifying that the boolean expression is indeed true, the assertion
confirms your assumptions about the behavior of your program, increasing your
confidence that the program is free of errors.

<p>Experience has shown that writing assertions while programming is one of
the quickest and most effective ways to detect and correct bugs.  As an added
benefit, assertions serve to document the inner workings of your program,
enhancing maintainability.


<p>This document shows you how to program with assertions.  It covers the
topics:
<ul>
  <li><a href="#intro">Introduction</a> </li>
  <li><a href="#usage">Putting Assertions Into Your Code</a> </li>
  <li><a href="#compiling">Compiling Files That Use Assertions</a>  </li>
  <li><a href="#enable-disable">Enabling and Disabling Assertions</a>  </li>
  <li><a href="#compatibility">Compatibility With Existing Programs</a> </li>
  <li><a href="#design-faq">Design FAQ</a> </li>
</ul>

<p>&nbsp;
<HR>
<a name="intro"><H2>Introduction</H2></a>

<p>The assertion statement has two forms. The first, simpler form is:

<pre>    assert <VAR>Expression<SUB>1</SUB></VAR> ;</pre>

where <var>Expression<font size=-1><sub>1</sub></font></var> is a
<code>boolean</code> expression. When the system runs the assertion, it
evaluates <var>Expression<font size=-1><sub>1</sub></font></var> and if it is
<code>false</code> throws an <a
href="../../api/java/lang/AssertionError.html"><CODE>AssertionError</CODE></a>
with no detail message.

<p>The second form of the assertion statement is:

<pre>    assert <VAR>Expression<SUB>1</SUB></VAR> : <VAR>Expression<SUB>2</SUB></VAR> ;</pre>

<p>where: 
<ul>
<li><var>Expression<font size=-1><sub>1</sub></font></var> is a
    <code>boolean</code> expression. </li>

<li><var>Expression<font size=-1><sub>2</sub></font></var> is an expression
    that has a value.  (It cannot be an invocation of a method that is declared
    <code>void</code>.)
</ul>


<p>Use this version of the <code>assert</code> statement to provide a detail
message for the <code>AssertionError</code>.  The system passes the value of
<var>Expression<font size=-1><sub>2</sub></font></var> to the appropriate
<code>AssertionError</code> constructor, which uses the string representation
of the value as the error's detail message.

<p>The purpose of the detail message is to capture and communicate
the details of the assertion failure.  The message should allow you to
diagnose and ultimately fix the error that led the assertion to fail.  Note
that the detail message is <i>not</i> a user-level error message, so it is
generally unnecessary to make these messages understandable in isolation, or
to internationalize them.  The detail message is meant to be interpreted
in the context of a full stack trace, in conjunction with the source code
containing the failed assertion.

<p>Like all uncaught exceptions, assertion failures are generally labeled in
the stack trace with the file and line number from which they were thrown.
The second form of the assertion statement should be used in preference to the
first only when the program has some additional information that might help
diagnose the failure.  For example, if <VAR>Expression<SUB>1</SUB></VAR>
involves the relationship between two variables <code>x</code> and
<code>y</code>, the second form should be used.  Under these circumstances,
a reasonable candidate for <VAR>Expression<SUB>2</SUB></VAR> would be 
<code>"x: " + x + ", y: " + y</code>.

<p>In some cases <var>Expression<font size=-1><sub>1</sub></font></var> may be
expensive to evaluate.  For example, suppose you write a method to find the
minimum element in an unsorted list, and you add an assertion to verify that
the selected element is indeed the minimum.  The work done by the assert will
be at least as expensive as the work done by the method itself.  To ensure
that assertions are not a performance liability in deployed applications,
assertions can be enabled or disabled when the program is started, and are
disabled by default.  Disabling assertions eliminates their performance
penalty entirely.  Once disabled, they are essentially equivalent to
<i>empty statements</i> in semantics and performance.  See <a
href="#enable-disable">Enabling and Disabling Assertions</a> for more
information.

<p>The addition of the <code>assert</code> keyword to the Java programming
language has implications for existing code.  See <a
href="#compatibility">Compatibility With Existing Programs</a> for
more information.

<p>&nbsp;
<HR>
<a name="usage"><H2>Putting Assertions Into Your Code</H2></a>

<p>There are many situations where it is good to use assertions.  This
section covers some of them:

<ul>
  <li><a href="#usage-invariants">Internal Invariants</a> 
  <li><a href="#usage-control">Control-Flow Invariants</a> 
  <li><a href="#usage-conditions">Preconditions, Postconditions, and Class
      Invariants</a>
</ul>

<p>There are also a few situations where you should <i>not</i> use them:

<ul>
<li>Do <i>not</i> use assertions for argument checking in public methods.

<p>Argument checking is typically part of the published specifications (or
<i>contract</i>) of a method, and these specifications must be obeyed whether
assertions are enabled or disabled.  Another problem with using assertions for
argument checking is that erroneous arguments should result in an appropriate
runtime exception (such as <code>IllegalArgumentException</code>,
<code>IndexOutOfBoundsException</code>, or
<code>NullPointerException</code>). An assertion failure will not throw an
appropriate exception.</li>

<li>Do <i>not</i> use assertions to do any work that your application requires
for correct operation.

<p>Because assertions may be disabled, programs must not assume that the
boolean expression contained in an assertion will be evaluated.  Violating
this rule has dire consequences.  
For example, suppose you wanted to remove all of the null elements
from a list <code>names</code>, and knew that the list contained one or more
nulls.  It would be wrong to do this:
<pre>
    <b>// Broken! - action is contained in assertion</b>
    assert names.remove(null);
</pre>
The program would work fine when asserts were enabled, but would fail when
they were disabled, as it would no longer remove the null elements from the
list.
The correct idiom is to perform the action before the assertion and then
assert that the action succeeded:
<pre>
    <b>// Fixed - action precedes assertion</b>
    boolean nullsRemoved = names.remove(null);
    assert nullsRemoved;  // Runs whether or not asserts are enabled
</pre>
As a rule, the expressions contained in assertions should be free of
<i>side effects</i>: evaluating the expression should not affect any state
that is visible after the evaluation is complete.  One exception to this rule
is that assertions can modify state that is used only from within other
assertions.  <a href="#complexpostconditions">An idiom that makes use of this
exception</a> is presented later in this document.
</li>
</ul>

<p>&nbsp;
<a name=usage-invariants><H3>Internal Invariants</H3></a>

<P>Before assertions were available, many programmers used comments to
indicate their assumptions concerning a program's behavior.  For example,
you might have written something like this to explain your assumption
about an <CODE>else</CODE> clause in a multiway if-statement:  

<PRE>    if (i % 3 == 0) {
        ...
    } else if (i % 3 == 1) {
        ...
    } else { <b>// We know (i % 3 == 2)</b>
        ...
    }</PRE>

<p>You should now <b>use an assertion whenever you would have written a
comment that asserts an invariant</b>.  For example, you should rewrite the
previous if-statement like this: 

<PRE>    if (i % 3 == 0) {
        ...
    } else if (i % 3 == 1) {
        ...
    } else {
        <b>assert i % 3 == 2 : i;</b>
        ...
    }</PRE>

<p>Note, incidentally, that the assertion in the above example may fail if
<CODE>i</CODE> is negative, as the <code>%</code> operator is not a true
<i>modulus</i> operator, but computes the <i>remainder</i>, which may be
negative.

<p>Another good candidate for an assertion is a <code>switch</code> statement
with no <code>default</code> case.  The absence of a <code>default</code> case
typically indicates that a programmer believes that one of the cases will
always be executed.  The assumption that a particular variable will have one
of a small number of values is an invariant that should be checked with an
assertion.  For example, suppose the following <code>switch</code> statement
appears in a program that handles playing cards: 

<PRE>    switch(suit) {
      case Suit.CLUBS:
        ...
        break;

      case Suit.DIAMONDS:
        ...
        break;

      case Suit.HEARTS:
        ...
        break;

      case Suit.SPADES:
        ...
    } </PRE>

<p>It probably indicates an assumption that the <code>suit</code> variable
will have one of only four values. To test this assumption, you
should add the following default case:  

<PRE>      default:
        assert false : suit; </PRE>

<p>If the <code>suit</code> variable takes on another value and assertions are
enabled, the assert will fail and an <code>AssertionError</code> will be
thrown.

<p>An acceptable alternative
is:<PRE>      default:
        throw new AssertionError(suit); </PRE>
</PRE>
This alternative offers protection even if assertions are disabled, but
the extra protection adds no cost: the <code>throw</code> statement won't
execute unless the program has failed.  Moreover, the alternative
is legal under some circumstances where the <code>assert</code> statement is
not.  If the enclosing method returns a value, each case in the
<code>switch</code> statement contains a <code>return</code> statement, and no
<code>return</code> statement follows the <code>switch</code> statement, then
it would cause a syntax error to add a default case with an assertion.
(The method would return without a value if no case matched and assertions were
disabled.)

<p>&nbsp;
<a name=usage-control><H3>Control-Flow Invariants</H3></a>

<p>The previous example not only tests an invariant, it also checks an
assumption about the application's flow of control.  The author of the
original <code>switch</code> statement probably assumed not only that the
<code>suit</code> variable would always have one of four values, but also that
one of the four cases would always be executed.  It points out another general
area where you should use assertions: <b>place an assertion at any location
you assume will not be reached</b>.  The assertions statement to use is: 

<PRE>    assert false; </PRE>

<p>For example, suppose you have a method that looks like this:  

<PRE>    void foo() {
        for (...) {
            if (...)
                return;
        }
        <b>// Execution should never reach this point!!!</b>
    } </PRE>

<p>Replace the final comment so that the code now reads:  

<PRE>    void foo() {
        for (...) {
            if (...)
                return;
        }
        <b>assert false; // Execution should never reach this point!</b>
    } </PRE>

</p>

<p>
<hr width="50%" align=left>
<b>Note: </b> Use this technique with discretion. If a statement is
unreachable as defined in the Java Language Specification (
<a href="/docs/books/jls/second_edition/html/statements.doc.html#236365">
JLS 14.20</a>), you
will get a compile time error if you try to assert that it is not
reached. Again, an acceptable alternative is simply to throw an
<code>AssertionError</code>.
<hr width="50%" align=left></p>

<p>&nbsp;
<a name=usage-conditions><H3>Preconditions, Postconditions, and Class
Invariants</H3></a>

<P>While the assert construct is not a full-blown <i>design-by-contract</i>
facility, it can help support an informal design-by-contract style of
programming.  This section shows you how to use asserts for:
<ul>
<li><a href="#preconditions">Preconditions</a> &mdash; what must be true when
a method is invoked. </li>
  <ul>
    <li><a href=#usage-adv-locks>Lock-Status Preconditions</a> &mdash;
    preconditions concerning whether or not a given lock is held.
  </ul>

<li><a href="#postconditions">Postconditions</a> &mdash; what must be true
after a method completes successfully.</li>

<li><a href="#class-invariants">Class invariants</a> &mdash; what must be true
about each instance of a class.</li>
</ul>

<p>&nbsp;
<a name="preconditions"></a><H4>Preconditions</H4>

<P>By convention, preconditions on <i>public</i> methods are enforced by
explicit checks that throw particular, specified exceptions. For example:

<PRE>    /**
     * Sets the refresh rate.
     *
     * @param  rate refresh rate, in frames per second.
     * @throws IllegalArgumentException if rate &lt;= 0 or
     *          rate &gt; MAX_REFRESH_RATE.
     */
     public void setRefreshRate(int rate) {
         // <B>Enforce specified precondition in public method</B>
         if (rate &lt;= 0 || rate &gt; MAX_REFRESH_RATE)
             throw new IllegalArgumentException("Illegal rate: " + rate);

         setRefreshInterval(1000/rate);
     } </PRE>

<p>This convention is unaffected by the addition of the <code>assert</code>
construct. <b>Do not use assertions to check the parameters of a public
method.</b> An assert is inappropriate because the method guarantees that it
will always enforce the argument checks.  It must check its arguments whether
or not assertions are enabled.  Further, the <code>assert</code> construct
does not throw an exception of the specified type.  It can throw only an
<code>AssertionError</code>.

<P>You can, however, use an assertion to test a <i>nonpublic</i> method's
precondition that you believe will be true no matter what a client does with
the class. For example, an assertion <i>is</i> appropriate in the following
"helper method" that is invoked by the previous method:

<PRE>   /**
    * Sets the refresh interval (which must correspond to a legal frame rate).
    *
    * @param  interval refresh interval in milliseconds.
    */
    <b>private</b> void setRefreshInterval(int interval) {
        <b>// Confirm adherence to precondition in nonpublic method</b>
        assert interval &gt; 0 &amp;&amp; interval &lt;= 1000/MAX_REFRESH_RATE : interval;

        ... // Set the refresh interval
    } </PRE>

<p>Note, the above assertion will fail if <code>MAX_REFRESH_RATE</code> is
greater than 1000 and the client selects a refresh rate greater than
1000. This would, in fact, indicate a bug in the library!

<p>&nbsp;
<a name=usage-adv-locks><h5>Lock-Status Preconditions</h5></a>

<p>Classes designed for multithreaded use often have non-public methods with
preconditions relating to whether or not some lock is held. For example, it is
not uncommon to see something like this:

<pre>   private Object[] a;

   public synchronized int find(Object key) {
      return find(key, a, 0, a.length);
   }

   <b>// Recursive helper method - always called with a lock on this object</b>
   private int find(Object key, Object[] arr, int start, int len) {
       ...
   } </pre>

<p>A static method called <code>holdsLock</code> has been added to the
<code>Thread</code> class to test whether the current thread holds the lock on
a specified object. This method can be used in combination with an
<code>assert</code> statement to supplement a comment describing a lock-status
precondition, as shown in the following example:

<pre>    // Recursive helper method - always called with a lock on this.
    private int find(Object key, Object[] arr, int start, int len) {
        <b>assert Thread.holdsLock(this); // lock-status assertion </b>
        ...
    } </pre>

<p>Note that it is also possible to write a lock-status assertion asserting
that a given lock <i>isn't</i> held.

<p>&nbsp;
<a name="postconditions"></a><H4>Postconditions</H4>

<p>You can test postcondition with assertions in both public and nonpublic
methods.  For example, the following public method uses an <code>assert</code>
statement to check a post condition:

<PRE>    /**
     * Returns a BigInteger whose value is (this<SUP>-1</SUP> mod m).
     *
     * @param  m the modulus.
     * @return this<SUP>-1</SUP> mod m.
     * @throws ArithmeticException  m &lt;= 0, or this BigInteger
     *         has no multiplicative inverse mod m (that is, this BigInteger
     *         is not <I>relatively prime</I> to m).
     */
    public BigInteger modInverse(BigInteger m) {
        if (m.signum &lt;= 0)
            throw new ArithmeticException("Modulus not positive: " + m);

        ... // Do the computation

        <b>assert this.multiply(result).mod(m).equals(ONE) : this;</b>
        return result;
    }
</PRE>

<p>
<a name="complexpostconditions"></a>
Occasionally it is necessary to save some data prior to performing a
computation in order to check a postcondition.  You can do this with two
<code>assert</code> statements and a simple inner class that saves the state
of one or more variables so they can be checked (or rechecked) after the
computation.  For example, suppose you have a piece of code that looks like
this:

<PRE>    void foo(int[] array) {
        // Manipulate array
        ...

        // At this point, array will contain exactly the ints that it did
        // prior to manipulation, in the same order.
    }
</PRE>

<p>Here is how you could modify the above method to turn the textual assertion
of a postcondition into a functional one:

<PRE>    void foo(final int[] array) {

        <b>// Inner class that saves state and performs final consistency check</b>
        class DataCopy {
            private int[] arrayCopy;

            DataCopy() { arrayCopy = (int[]) array.clone(); }

            boolean isConsistent() { return Arrays.equals(array, arrayCopy); }
        }

        DataCopy copy = null;

        <b>// Always succeeds; has side effect of saving a copy of array</b>
        assert ((copy = new DataCopy()) != null);

        ... // Manipulate array

        <b>// Ensure array has same ints in same order as before manipulation.</b>
        assert copy.isConsistent();
     } </PRE>

<p>You can easily generalize this idiom to save more than one data field, and
to test arbitrarily complex assertions concerning pre-computation and
post-computation values.

<P>You might be tempted to replace the first assert statement (which is
executed solely for its side-effect) by the following, more expressive
statement:

<PRE>    copy = new DataCopy(); </PRE>

<p>Don't make this replacement.  The statement above would copy the array
whether or not asserts were enabled, violating the principle that assertions
should have no cost when disabled.

<p>&nbsp;
<a name="class-invariants"></a><H4>Class Invariants</H4>

A class invariants is a type of <a href="#usage-invariants">internal
invariant</a> that applies to every instance of a class at all times, except
when an instance is in transition from one consistent state to another.
A class invariant can specify the relationships among multiple attributes, and
should be true before and after any method completes.  For example, suppose
you implement a balanced tree data structure of some sort.  A class invariant
might be that the tree is balanced and properly ordered.

<p>The assertion mechanism does not enforce any particular style for checking
invariants.  It is sometimes convenient, though, to combine the expressions
that check required constraints into a single internal method that can be
called by assertions. Continuing the balanced tree example, it might be
appropriate to implement a private method that checked that the tree was
indeed balanced as per the dictates of the data structure:

<PRE>    // Returns true if this tree is properly balanced
    private boolean balanced() {
        ...
    }
</PRE>

<p>Because this method checks a constraint that should be true before and
after any method completes, each public method and constructor should contain
the following line immediately prior to its return:

<PRE>    assert balanced(); </PRE>

<p>It is generally unnecessary to place similar checks at the head of each
public method unless the data structure is implemented by native methods. In
this case, it is possible that a memory corruption bug could corrupt a "native
peer" data structure in between method invocations. A failure of the assertion
at the head of such a method would indicate that such memory corruption had
occurred. Similarly, it may be advisable to include class invariant checks at
the heads of methods in classes whose state is modifiable by other
classes. (Better yet, design classes so that their state is not directly
visible to other classes!)

<p>&nbsp;
<a name=usage-advanced><H3>Advanced Uses</H3></a>

The following sections discuss topics that apply only to 
resource-constrained devices and to systems where asserts must not be
disabled in the field.  
If you have no interest in these topics, skip to the next
section, <a href="#compiling">&quot;Compiling Files that Use
Assertions&quot;</a>.

<p>&nbsp;
<a name=usage-adv-removing><H4>Removing all Trace of Assertions from Class
Files</H4></a>

<P>Programmers developing applications for resource-constrained devices may
wish to strip assertions out of class files entirely. While this makes it
impossible to enable assertions in the field, it also reduces class file size,
possibly leading to improved class loading performance. In the absence of a
high quality JIT, it could lead to decreased footprint and improved runtime
performance.

<P>The assertion facility offers no direct support for stripping assertions
out of class files. The assert statement may, however,  be used in conjunction
with the "conditional compilation" idiom described in <a href="/docs/books/jls/second_edition/html/statements.doc.html#236365">
JLS 14.20</a>, enabling the 
compiler to eliminate all traces of these asserts from the class files that it
generates:

<PRE>    static final boolean asserts = ... ; // false to eliminate asserts

    if (asserts)
        assert &lt;expr&gt; ; </PRE>


<p>&nbsp;
<a name=usage-adv-requiring><H4>Requiring that Assertions are Enabled</H4></a>

<p>Programmers of certain critical systems might wish to ensure that
assertions are not disabled in the field.  The following static initialization
idiom prevents a class from being initialized if its assertions have been
disabled:

<PRE>    static {
        boolean assertsEnabled = false;
        assert assertsEnabled = true; // <B>Intentional side effect!!!</B>
        if (!assertsEnabled)
            throw new RuntimeException("Asserts must be enabled!!!");
    } </PRE>

<p>Put this static-initializer at the top of your class.


<p>&nbsp;
<HR>
<a name=compiling><H2>Compiling Files That Use Assertions</H2></a>

<p>In order for the <code>javac</code> compiler to accept code containing
assertions, you must use the <code>-source&nbsp;1.4</code> command-line option
as in this example:

<PRE>    javac <b>-source 1.4</b> MyClass.java </PRE>
This flag is necessary so as not to cause source <a
href="#compatibility">compatibility</a> problems.

<p>&nbsp;
<HR>
<H2><a name=enable-disable>Enabling and Disabling Assertions</a></H2>

<p>By default, assertions are disabled at runtime. Two command-line switches
allow you to selectively enable or disable assertions.

<P>To enable assertions at various granularities, use the
<nobr><code>-enableassertions</code></nobr>, or <nobr><code>-ea</code></nobr>,
switch.  To disable assertions at various granularities, use the
<nobr><code>-disableassertions</code></nobr>, or
<nobr><code>-da</code></nobr>, switch.  You specify the granularity
with the arguments that you provide to the switch:

<ul><a name=arg-list></a>
<li>no arguments <br>
&nbsp;&nbsp;&nbsp;Enables or disables assertions in all classes except system
classes.

<li><i>packageName</i><code>...</code> <br>
&nbsp;&nbsp&nbsp;Enables or disables assertions in the named package and any
subpackages.

<li><code>...</code><br>
&nbsp;&nbsp;&nbsp;Enables or disables assertions in the unnamed package in the
current working directory.

<li><i>className</i><br>
&nbsp;&nbsp;&nbsp;Enables or disables assertions in the named class
</ul>

<p>For example, the following command runs a program, <code>BatTutor</code>,
with assertions enabled in only package <code>com.wombat.fruitbat</code> and
its subpackages:

<PRE>    java -ea:com.wombat.fruitbat... BatTutor</PRE>

<p>If a single command line contains multiple instances of these switches,
they are processed in order before loading any classes.  For example, the
following command runs the <code>BatTutor</code> program with assertions
enabled in package <code>com.wombat.fruitbat</code> but disabled in class
<code>com.wombat.fruitbat.Brickbat</code>:

<PRE>    java -ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat BatTutor </PRE>

<p>The above switches apply to all class loaders.  With one exception,
they also apply to <i>system classes</i> (which do not have an explicit class
loader).  The exception concerns the switches with no arguments, which (as
indicated above) do not apply to system classes.   This behavior makes it easy
to enable asserts in all classes except for system classes, which is commonly
desirable.

<p>To enable assertions in all system classes, use a different switch:
<nobr><code>-enablesystemassertions</code></nobr>, or
<nobr><code>-esa</code>.</nobr>  Similarly, to disable assertions in system
classes, use <nobr><code>-disablesystemassertions</code></nobr>, or
<nobr><code>-dsa</code>.</nobr>

<p>For example, the following command runs the <code>BatTutor</code> program
with assertions enabled in system classes, as well as in the
<code>com.wombat.fruitbat</code> package and its subpackages:

<PRE>    java -esa -ea:com.wombat.fruitbat... </PRE>

<p>

The assertion status of a class (enabled or disabled) is set at the time it is
initialized, and does not change.  There is, however, one corner case that
demands special treatment.  It is possible, though generally not desirable, to
execute methods or constructors prior to initialization. This can happen when
a class hierarchy contains a circularity in its static initialization.
<p>If an <tt>assert</tt> statement executes before its class is initialized,
the execution must behave as if assertions were enabled in the class.  This
topic is discussed in detail in 
<a href="/docs/books/jls/assert-spec.html#semantics">
the assertions specification</a>.

<HR>
<a name=compatibility><H2>Compatibility With Existing Programs</H2></a>

<p>The addition of the <code>assert</code> keyword to the Java programming
language does not cause any problems with preexisting binaries
(<code>.class</code> files).  If you try to compile an application that uses
<code>assert</code> as an identifier, however, you will receive
a warning or error message.  In order to ease the transition from a world where
<code>assert</code> is a legal identifier to one where it isn't, the compiler
supports two modes of operation in this release:

<UL>
  <li><b>source mode 1.3</b> (default) &mdash; the compiler accepts
  programs that use <code>assert</code> as an identifier, 
  but issues warnings.  In this mode, programs are <i>not</i> permitted to use
  the <code>assert</code> statement.</li> 

  <li><b>source mode 1.4</b> &mdash; the compiler generates an error message
  if the program uses <code>assert</code> as an identifier.  In this mode,
  programs <i>are</i> permitted to use the <code>assert</code> statement.</li>
</UL>

<p>Unless you specifically request source mode 1.4 with the <code>-source
1.4</code> flag, the compiler operates in source mode 1.3. <i>If you
forget to use this this flag, programs that use the new <code>assert</code>
statement will not compile</i>.  Having the compiler use the old semantics as
its default behavior (that is, allowing <code>assert</code> to be used as an
identifier) was done for maximal source compatibility.  Source mode 1.3 is
likely to be phased out over time.

<p>&nbsp;
<HR>
<a name=design-faq><H2>Design FAQ</H2></a>

<p>Here is a collection of frequently asked questions concerning the
design of the assertion facility.
<UL>
  <li><a href="#design-faq-general">General Questions</a>

  <li><a href="#design-faq-compat">Compatibility</a>

  <li><a href="#design-faq-ss">Syntax and Semantics</a>

  <li><a href="#design-faq-error">The <code>AssertionError</code> Class</a>

  <li><a href="#design-faq-enable-disable">Enabling and Disabling
  Assertions</a> </li>
</UL>

<p>&nbsp;
<a name=design-faq-general><H3>General Questions</H3></a>

<OL><B>
  <li>Why provide an assertion facility, given that one can program 
  assertions atop the Java programming language with no special support?</B> 

  <P>Although ad hoc implementations are possible, they are of necessity
  either ugly (requiring an <code>if</code> statement for each assertion) or
  inefficient (evaluating the condition even if assertions are disabled).
  Further, each ad hoc implementation has its own means of enabling and
  disabling assertions, which lessens the utility of these implementations,
  especially for debugging in the field. As a result of these shortcomings,
  assertions have never become a part of the culture among engineers using the
  Java programming language. Adding assertion support to the platform stands a
  good chance of rectifying this situation.
  <P>&nbsp;

  <li><B>Why does this facility justify a language change, as opposed to a
  library solution?</B>

  <P>We recognize that a language change is a serious effort, not to be
  undertaken lightly. The library approach was considered. It was, however,
  deemed essential that the runtime cost of assertions be negligible if they
  are disabled. In order to achieve this with a library, the programmer is
  forced to hard-code each assertion as an <code>if</code> statement. Many
  programmers would not do this. Either they would omit the if statement and
  performance would suffer, or they would ignore the facility entirely. Note
  also that assertions were contained in James Gosling's original
  specification for the Java programming language.  Assertions were removed
  from the Oak specification because time constraints prevented a satisfactory
  design and implementation.
  <P>&nbsp;

  <li><B>Why not provide a full-fledged <i>design-by-contract</i> facility
  with preconditions, postconditions and class invariants, like the one in
  the Eiffel programming language?</B>

  <P>We considered providing such a facility, but were unable to convince
  ourselves that it is possible to graft it onto the Java programming language
  without massive changes to the Java platform libraries, and massive
  inconsistencies between old and new libraries. Further, we were not
  convinced that such a facility would preserve the simplicity that is the
  hallmark of the Java programming language. On balance, we came to the
  conclusion that a simple boolean assertion facility was a fairly
  straight-forward solution and far less risky. It's worth noting that adding
  a boolean assertion facility to the language doesn't preclude adding a
  full-fledged design-by-contract facility at some time in the future.

  <P>The simple assertion facility does enable a limited form of
  <a href="#usage-conditions">design-by-contract style programming</a>. The
  <code>assert</code> statement is appropriate for nonpublic precondition,
  postcondition and class invariant checking. Public precondition checking
  should still be performed by checks inside methods that result in
  particular, documented exceptions, such as
  <code>IllegalArgumentException</code> and <code>IllegalStateException</code>.
  <P>&nbsp;

  <li><B>In addition to boolean assertions, why not provide an assert-like
  construct to suppress the execution of an entire block of code if assertions
  are disabled?</B>

  <P>Providing such a construct would encourage programmers to put complex
  assertions inline, when they are better relegated to separate methods. 
  </li>
</OL>


<p>&nbsp;
<a name=design-faq-compat><H3>Compatibility</H3></a>

<OL>
  <P>
  <li><B>Won't the new keyword cause compatibility problems with existing
  programs that use <code>assert</code> as an identifier?</B>

  <P>Yes, for source files. (Binaries for classes that use <code>assert</code>
  as an identifier will continue to work fine.) To ease the transition, we
  implemented <a href="#compatibility">a strategy</a> whereby developers can
  continue using <code>assert</code> as an identifier during a transitional
  period.<P>&nbsp;

  <li>
  <b>Doesn't this facility produce class files that cannot be run against
  older JREs?</b> 

  <p>Yes. Class files will contain calls to the new <tt>ClassLoader</tt>
  and <tt>Class</tt> methods, such as <tt>desiredAssertionStatus</tt>. If
  a class file containing calls to these methods is run against an older
  JRE (whose <tt>ClassLoader</tt> class doesn't define the methods), the
  program will fail at run time, throwing a <tt>NoSuchMethodError</tt>.
  It is generally the case that programs using new facilities are not
  compatible with older releases.
</OL>

<p>&nbsp;
<a name=design-faq-ss><H3>Syntax and Semantics</H3></a>

<OL>
  <li><B>Why allow primitive types in <VAR>Expression<font
  size="1"><SUB>2</SUB></font></VAR>?</B>

  <P>There is no compelling reason to restrict the type of this expression.
  Allowing arbitrary types provides convenience for developers who, for
  example, want to associate a unique integer code with each
  assertion. Further, it makes this expression feel like the argument of
  <code>System.out.println(...)</code>, which is seen as desirable.

  </li>
</OL>


<p>&nbsp;
<a name=design-faq-error><H3>The AssertionError Class</H3></a>

<OL>
  <li><B>When an <code>AssertionError</code> is generated by an assert
  statement in which <var>Expression<font size="-1"><SUB>2</SUB></font></var>
  is absent, why isn't the program text of the asserted condition used as the
  detail message (for example, <nobr>&quot;<code>height &lt;
  maxHeight</code>&quot;</nobr>)?</B>

  <P>While doing so might improve out-of-the-box usefulness of assertions in
  some cases, the benefit doesn't justify the cost of adding all those string
  constants to <code>.class</code> files and runtime images.
  <P>&nbsp;


  <li><B>Why doesn't an <code>AssertionError</code> allow access to the object
  that generated it? Similarly, why not pass an arbitrary object from the
  assertion to the <code>AssertionError</code> constructor in place of a
  detail message?</B>

  <P>Access to these objects would encourage programmers to attempt to recover
  from assertion failures, which defeats the purpose of the facility.
  <P>&nbsp;

  <li><B>Why not provide context accessors (like <code>getFile</code>,
  <code>getline</code>, <code>getMethod</code>) on
  <code>AssertionError</code>?</B>

  <P>This facility is best provided on <code>Throwable</code>, so it may be
  used for all throwables, not just just assertion errors. We
  enhanced <code>Throwable</code> with the <code>getStackTrace</code>
  method to provide this functionality.

  <P>&nbsp;


  <li><B>Why is <code>AssertionError</code> a subclass of <code>Error</code>
  rather than <code>RuntimeException</code>?</B>

  <P>This issue was controversial. The expert group discussed it at at length,
  and came to the conclusion that <code>Error</code> was more appropriate to
  discourage programmers from attempting to recover from assertion
  failures. It is, in general, difficult or impossible to localize the source
  of an assertion failure. Such a failure indicates that the program is
  operating "outside of known space," and attempts to continue execution are
  likely to be harmful.  Further, convention dictates that methods specify
  most runtime exceptions they may throw (with <code>@throws</code> doc
  comments). It makes little sense to include in a method's specification the
  circumstances under which it may generate an assertion failure. Such
  information may be regarded as an implementation detail, which can change
  from implementation to implementation and release to release. 
  </li>
</OL>


<p>&nbsp;
<a name=design-faq-enable-disable><H3>Enabling and Disabling
Assertions</H3></a>

<OL>
  <li><B>Why not provide a compiler flag to completely eliminate assertions
  from object files?</B>

  <P>It is a firm requirement that it be possible to enable assertions in the
  field, for enhanced serviceability. It would have been possible to also
  permit developers to eliminate assertions from object files at compile time.
  Assertions can contain side effects, though they should not, and such a flag
  could therefore alter the behavior of a program in significant ways. It is
  viewed as good thing that there is only one semantics associated with each
  valid Java program. Also, we want to encourage users to leave asserts in
  object files so they can be enabled in the field.  Finally, the 
  spec demands that assertions behave as if enabled when a class
  runs before it is initialized.  It would be impossible to offer
  these semantics if assertions were stripped from the class file.
  Note, however, that the standard "conditional compilation idiom" described
  in JLS 14.20 can be used to achieve this effect for developers who really
  want it.
  <P>&nbsp;

  <li><B>Why do the commands that enable and disable assertions use
 package-tree semantics instead of the more traditional package semantics?</B>

  <P>Hierarchical control is useful, as programmers really do use package
  hierarchies to organize their code. For example, package-tree semantics
  allow assertions to be enabled or disabled in all of Swing at one time.
  <P>&nbsp;

  <li><B>Why does <code>setClassAssertionStatus</code> return a
  <code>boolean</code> instead of throwing an exception if it is invoked when
  it's too late to set the assertion status (that is, if the named class has
  already been initialized)?</B>

  <P>No action (other than perhaps a warning message) is necessary or
  desirable if it's too late to set the assertion status. An exception seems
  unduly heavyweight.
  <P>&nbsp;


  <li><B>Why not overload a single method name to take the place of
  <code>setDefaultAssertionStatus</code> and
  <code>setAssertionStatus</code>?</B>

  <p>Clarity in method naming is for the greater good.  Overloading
     tends to cause confusion.
  <P>&nbsp;

  <li>
  <b>Why not tweak the semantics of <tt>desiredAssertionStatus</tt> to make
  it more "programmer friendly" by returning the actual assertion status
  if a class is already initialized?</b>

  <p>It's not clear that there would be any use for the resulting method.
  The method isn't designed for application programmer use, and it seems
  inadvisable to make it slower and more complex than necessary.
  <P>&nbsp;

  <li><B>Why is there no <code>RuntimePermission</code> to prevent applets
  from enabling/disabling assertions?</B>

  <P>While applets have no reason to call any of the <code>ClassLoader</code>
  methods for modifying assertion status, allowing them to do so seems
  harmless. At worst, an applet can mount a weak denial-of-service attack by
  enabling assertions in classes that have yet to be initialized. Moreover,
  applets can only affect the assert status of classes that are to be loaded
  by class loaders that the applets can access. There already exists a
  <code>RuntimePermission</code> to prevent untrusted code from gaining access
  to class loaders (<code>getClassLoader</code>).
  <P>&nbsp;

  <li><B>Why not provide a construct to query the assert status of the
  containing class?</B>

  <P>Such a construct would encourage people to inline complex assertion code,
  which we view as a bad thing.<!-- :

<PRE>    if (assertsEnabled()) {
        ...
    } </PRE> 

<p> -->

Further, it is straightforward to query the assert status atop the current
API, if you feel you must:

<PRE>   boolean assertsEnabled = false;
   assert assertsEnabled = true;  // <B>Intentional side-effect!!!</B>
   // Now assertsEnabled is set to the correct value </PRE>

</li>
<li>
<b>Why does an <tt>assert</tt> statement that executes before its class
is initialized behave as if assertions were enabled in the class?</b></li>

<p><br>Few programmers are aware of the fact that a class's constructors
and methods can run prior to its initialization. When this happens, it
is quite likely that the class's invariants have not yet been established,
which can cause serious and subtle bugs. Any assertion that executes in
this state is likely to fail, alerting the programmer to the problem. Thus,
it is generally helpful to the programmer to execute all assertions encountered
while in this state.
</li>
</OL>

<!-- Body text ends here -->

<!-- ============================================================== -->
<HR noShade SIZE=3>

<TABLE summary="layout" width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD>
      <P><FONT size=-2><a 
      href="../../relnotes/SMICopyright.html">Copyright</a> 
      &copy; 2002 <a href="http://www.sun.com/">Sun Microsystems, Inc.</a> All Rights 
      Reserved.</FONT></TD>
   <IMG SRC="../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH="64" HEIGHT="30">
<BR><FONT size=+1><I>Java Software</I> 
</FONT></TD></TR></TBODY></TABLE>

</BODY>
</HTML>
