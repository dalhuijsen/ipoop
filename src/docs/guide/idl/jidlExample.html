<HTML>

<HEAD>

   <TITLE>Java IDL: The "Hello World" Example</TITLE>

<!-- Changed by: carson 5/2001 for j2se 1.4 -->

   <X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>

</HEAD>

<BODY BGCOLOR="#FFFFFF">



<H1 ALIGN=CENTER>Java IDL: The "Hello World" Example</H1>
<P ALIGN=CENTER>POA model, transient server

<HR>

<P>This document is a high-level overview of how to create a complete CORBA (Common 
Object 
Request Broker Architecture) application using IDL (Interface Definiton Language) to 
define 
interfaces and the Java IDL compiler to generate stubs and skeletons.  For more 
information 
on the development process, and a more detailed tutorial on creating a CORBA 
application 
using IDL, link to <A HREF="GShome.html">Getting Started with Java IDL: The Hello 
World 
Tutorial</A>.  You can also create CORBA application by defining the interfaces in 
the 
Java 
programming language.  For more information and a tutorial on this development 
process, 
link to <A HREF="../rmi-iiop/index.html">Java RMI-IIOP documentation</A>.

<P>New to J2SE 1.4 - the server-side implementation generated by the <tt>idlj</tt> 
compiler
is the <em>Portable Servant Inheritance Model</em>, also known as the POA model.  The 
POA, or 
Portable Object Adapter, is discussed in more detail in  <a href="POA.html">Portable 
Object 
Adapter</a>.  This document presents a sample application created using the default 
behavior 
of 
the <tt>idlj</tt> compiler, which uses a POA server-side model.  

<P>CORBA supports at least two different server-side mappings for implementing an IDL 
interface:
<P>
<UL>
<LI>The Inheritance Model

<P>Using the Inheritance Model, you implement the IDL interface using an 
implementation class
that also extends the compiler-generated skeleton.  

<P>Inheritance models include:
<P>
	<UL>
	<LI>The OMG-standard, <em>POA</em>. Given an interface <tt>My</tt> defined in 
	<tt>My.idl</tt>, the file <tt>MyPOA.java</tt> is generated by the 
<tt>idlj</tt>
	 compiler. You must provide the implementation for <tt>My</tt> and it must 
inherit
	 from <tt>MyPOA</tt>, a stream-based skeleton that extends <a 
href="../../api/org/omg/PortableServer/Servant.html">
<tt>org.omg.PortableServer.Servant</tt>
	 </A>, which serves as the base class for all POA servant implementations.  

	<P>
	<LI><em>ImplBase</em>.  Given an interface <tt>My</tt> defined in 
<tt>My.idl</tt>, 
	the file <tt>_MyImplBase.java</tt> is generated. You must provide the 
implementation
	for <tt>My</tt> and it must inherit from <tt>_MyImplBase</tt>.
	
	<P><strong>NOTE: </strong>ImplBase is deprecated in favor of the POA model, 
but is 
provided to allow 
	compatibility with servers written in J2SE 1.3 and prior.  We do not 
recommend 
	creating new servers using this nonstandard model.
	
	</UL>
<P>
<LI>The Delegation Model

<P>Using the Delegation Model, you implement the IDL interface using two classes:
<P>
<UL>
<LI>An IDL-generated Tie class that inherits from the compiler-generated skeleton, 
but 
delegates all calls to an implementation class.
<LI>A class that implements the IDL-generated operations interface (such as 
<tt>HelloOperations</tt>), which defines the IDL function.<P>
</UL>

<P>The Delegation model is also known as the <em>Tie</em> model, or the Tie 
Delegation model. 
It inherits from either the POA or ImplBase compiler-generated skeleton, so the 
models will be 
described as POA/Tie or ImplBase/Tie models in this document.
</UL>

<P>This tutorial presents the POA Inheritance model for server-side implementation.  
For 
tutorials using the other server-side implementations, see the following documents:


<UL>
<P>

<LI><a href="jidlTieServer.html">Java IDL: The "Hello World" Example with the POA/Tie 
Server-Side 
Model</a>
<P>
The Tie Model is a delegation model.  Use the <tt>idlj</tt> compiler to first 
generate 
server-side bindings.  Then, run 
the <tt>idlj</tt> compiler a second time with the  with the <tt>-fallTie</tt> 
option to generate Tie model server-side bindings. For the interface <tt>Hello</tt>,  
<tt>HelloPOATie.java</tt> is one of the generated files. The
constructor to <tt>HelloPOATie</tt> takes a <tt>delegate</tt> or a <tt>delegate</tt> 
and a 
<tt>poa</tt>. You must provide
the implementation for <tt>delegate</tt> and/or the <tt>poa</tt>, but the delegate 
does not 
have to inherit
from any other class, only the interface <tt>HelloOperations</tt>. For
more information, refer to the <a href="mapping/jidlMapping.html"><em>IDL to Java 
Language 
Mapping Specification</em></a>.

<P>You might want to use the Tie model instead of the typical
Inheritance model if your implementation must inherit from some other
implementation. Java allows any number of interface inheritance, but
there is only one slot for class inheritance. If you use the inheritance
model, that slot is used up . By using the Tie Model, that slot is freed
up for your own use. The drawback is that it introduces a level of
indirection: one extra method call occurs when invoking a method.
<P>
<LI><a href="jidlImplBaseServer.html">Java IDL: The "Hello World" Example with the 
ImplBase 
Server-Side Model</a>
<P>The ImplBase server-side model is an Inheritance Model, as is the POA model.  Use 
the <tt>idlj</tt> compiler with the <tt>-oldImplBase</TT> flag to generate 
server-side 
bindings 
that 
are compatible with older version of Java IDL (prior to J2SE 1.4).  Given 
an 
interface <tt>Hello</tt> defined in <tt>Hello.idl</tt>, the file 
<tt>_HelloImplBase.java</tt> 
is 
generated. 
You must provide the implementation for <tt>Hello</tt> and it must inherit from 
<tt>_HelloImplBase</tt>.
<P><STRONG>Note that using the <tt>-oldImplBase</TT> flag is 
non-standard: these APIs are being deprecated.  You would use this flag ONLY for 
compatibility 
with existing servers written in J2SE 1.3 or earlier.  In that case, you would need 
to modify 
an existing MAKEFILE to add the <tt>-oldImplBase</TT> flag to the <tt>idlj</tt> 
compiler, 
otherwise POA-based server-side mappings will be generated.  </STRONG>
<P>

</UL>





<P>This document contains:
<UL>

   <LI>The <A href="#IDL">IDL</A> for a simple "Hello World" program

   

   <LI>A <A href="#server">server</A> that creates an object and 

   publishes it with the naming service using the default server-side
  implementation (POA)

   

   <LI>An <A HREF="#application">application client</A>  that knows the 
object's name, retrieves a reference for it from the naming service, and invokes the 
object

   
   <LI><A href="#instructions">Instructions</A> for compiling and running 

the example

   </UL>



<P>






<!--************IDL*************-->



<A name="IDL">

<H2>Defining the Interface (<code>Hello.idl</code>)</H2></A>

<P>The first step to creating a CORBA application is to specify all of
your objects and their interfaces using the OMG's Interface
Definition Language (IDL). IDL has a syntax similar to C++ and
can be used to define modules, interfaces, data structures, and
more. The IDL can be mapped to a variety of programming
languages. The IDL mapping for Java is summarized in 
<a href="mapping/jidlMapping.html">IDL to Java Language Mapping Summary</a>.

<P>The following code is written in the OMG IDL, and describes a CORBA
 object whose <TT>sayHello()</TT> operation returns a string and whose 
<TT>shutdown()</TT> 
method
 shuts down the ORB.  
 To learn more about OMG IDL Syntax and Semantics, link to the OMG Web site, 
 and read Chapter 3 of the 
 <a href="http://www.omg.org/docs/formal/99-10-07.pdf">CORBA Specification</a>.</P>

<P>
<EM><STRONG>Hello.idl</STRONG></EM>
<P>

<PRE>
module HelloApp
{
  interface Hello
  {
  string sayHello();
  oneway void shutdown();
  };
};
</PRE>


<A name="interop">
<B>NOTE:</B> When writing code in OMG IDL,
  do not use an interface name as the name of a module. 
  Doing so runs the risk of getting inconsistent results when 
  compiling with tools from different vendors, thereby jeopardizing
  the code's portability.  For example, 
  code containing the same names could be compiled with the IDL to Java 
  compiler from Sun Microsystems and get one result. 
  The same code compiled with another vendor's IDL to Java 
  compiler could produce a different result. 
<p>

To complete the application, you simply provide the server 
(<code>HelloServer.java</code>) 
and client (<code>HelloClient.java</code>)
implementations.



<!--************TRANSIENT SERVER*************-->



<A NAME="server">

<H2>Implementing the Server (<code>HelloServer.java</code>)</H2></A>



<P>The example server consists of two classes, the servant and the

server. The servant, <TT>HelloImpl</TT>, is the implementation of

the <TT>Hello</TT> IDL interface; each <TT>Hello</TT> instance is implemented

by a <TT>HelloImpl</TT> instance. The servant is a subclass of

<TT>HelloPOA</TT>, which 

is generated by the <TT>idlj</TT> compiler from the example IDL.

The servant contains one method for each IDL operation, in this

example, the <TT>sayHello()</TT>  and <tt>shutdown()</tt> methods. Servant methods 
are

just like ordinary Java methods; the extra code to deal with the ORB,

with marshaling arguments and results, and so on, is provided by the

skeleton.</P>





  



<P>The <tt>HelloServer</tt> class has the server's <TT>main()</TT> method, which:

</P>
<UL>

   <LI>Creates and initializes an ORB instance
   
   <LI>Gets a reference to the root POA and activates the <tt>POAManager</tt>

   <LI>Creates a servant instance (the implementation of one CORBA

   <TT>Hello</TT> object) and tells the ORB about it


   <LI>Gets a CORBA object reference for a naming context in which to

   register the new CORBA object
   
   <LI>Gets the root naming context


   <LI>Registers the new object in the naming context under the name "Hello"


   <LI>Waits for invocations of the new object from the client
</UL>

<P>This example provides an example of a transient object server.  For an example of 
the "Hello World" program with a persistent object server, see <a 
href="jidlExample2.html">Example 2: Hello World with Persistent State</a>.  For more 
discussion of CORBA servers, see <a href="jidlServers.html"><em>Developing 
Servers</em></a>.


<P>For more discussion of the code, see the detailed tutorial topic <A 
HREF="tutorial/GSserver.html">Getting Started with Java IDL: Developing a Hello World 
Server</A>. 
<P>
<EM><STRONG>HelloServer.java</STRONG></EM>
<P>

<PRE>
// <STRONG>HelloServer.java</STRONG>
// <A HREF="examplelicense.html">Copyright and License</A> 
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

import java.util.Properties;

class HelloImpl extends HelloPOA {
  private ORB orb;

  public void setORB(ORB orb_val) {
    orb = orb_val; 
  }
    
  // implement sayHello() method
  public String sayHello() {
    return "\nHello world !!\n";
  }
    
  // implement shutdown() method
  public void shutdown() {
    orb.shutdown(false);
  }
}


public class HelloServer {

  public static void main(String args[]) {
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // get reference to rootpoa & activate the POAManager
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();

      // create servant and register it with the ORB
      HelloImpl helloImpl = new HelloImpl();
      helloImpl.setORB(orb); 

      // get object reference from the servant
      org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
      Hello href = HelloHelper.narrow(ref);
	  
      // get the root naming context
      // NameService invokes the name service
      org.omg.CORBA.Object objRef =
          orb.resolve_initial_references("NameService");
      // Use NamingContextExt which is part of the Interoperable
      // Naming Service (INS) specification.
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);

      // bind the Object Reference in Naming
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
      ncRef.rebind(path, href);

      System.out.println("HelloServer ready and waiting ...");

      // wait for invocations from clients
      orb.run();
    } 
	
      catch (Exception e) {
        System.err.println("ERROR: " + e);
        e.printStackTrace(System.out);
      }
	  
      System.out.println("HelloServer Exiting ...");
	
  }
}
&nbsp;</PRE>





<!--************APPLICATION*************-->



<A name="application">

<H2>Implementing the Client Application (<code>HelloClient.java</code>)</H2></A>



<P>The example application client that follows:</P>



<UL>

   <LI>Creates and initializes an ORB

   

   <LI>Obtains a reference to the root naming context

   

   <LI>Looks up "Hello" in the naming context and receives a reference to that CORBA 
object

   

   <LI>Invokes the object's <TT>sayHello()</TT> and <tt>shutdown()</tt> operations 
and prints

   the result

</UL>

<P>For more discussion of the details of the code, link to <A 
HREF="tutorial/GSapp.html">Getting Started with Java IDL: Developing a Client 
Application</A>.
<P>
<EM><STRONG>HelloClient.java</STRONG></EM>
<P>

<PRE>// <A HREF="examplelicense.html">Copyright and License</A> 
&nbsp;
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

public class HelloClient
{
  static Hello helloImpl;

  public static void main(String args[])
    {
      try{
        // create and initialize the ORB
	ORB orb = ORB.init(args, null);

        // get the root naming context
        org.omg.CORBA.Object objRef = 
	    orb.resolve_initial_references("NameService");
        // Use NamingContextExt instead of NamingContext. This is 
        // part of the Interoperable naming Service.  
        NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
 
        // resolve the Object Reference in Naming
        String name = "Hello";
        helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));

        System.out.println("Obtained a handle on server object: " + helloImpl);
        System.out.println(helloImpl.sayHello());
        helloImpl.shutdown();

	} catch (Exception e) {
          System.out.println("ERROR : " + e) ;
	  e.printStackTrace(System.out);
	  }
    }

}
&nbsp;</PRE>




<!--************COMPILING THE EXAMPLES************-->



<A name="instructions">

<H2>Building and Running Hello World</H2></A>

<P>Despite its simple design, the Hello World program lets you learn and
experiment with all the tasks required to develop almost any CORBA program
that uses <A href="jidlGlossary.html#invocation">static invocation</A>.  
Static invocation, which uses a client stub for the invocation and a 
server skeleton for the service being invoked, is used when the interface 
of the object is known at compile time. If the interface is not known at
compile time, <A href="jidlGlossary.html#DII">dynamic invocation</A> must be used. 

<P>This example requires a naming service, which is a CORBA service that allows <A 
href="jidlGlossary.html#CORBA object">CORBA objects</A>
to be named by means of binding a name to an object reference.
The <A HREF="jidlGlossary.html#name binding">name binding</A> may be stored
in the naming service, and a client may supply the name
to obtain the desired object reference.  The two options for Naming Services shipped 
with J2SE v.1.4 are <tt><a href="jidlNaming.html">tnameserv</a></tt>, a transient 
naming service,  and <tt><a href="orbd.html">orbd</a></tt>, which is a daemon process 
containing a Bootstrap Service, a Transient Naming Service, a Persistent Naming 
Service, and a Server Manager. This example uses <tt>orbd</tt>.

<P>When running this example, remember that, when using 
Solaris software, you must become root to start a process on a port under 1024.  For 
this 
reason, we recommend that you use a port number greater than or equal to 1024. The 
<TT>-ORBInitialPort</TT> option is used to override the default port number in this 
example.  The following instructions assume you can use port 1050
for the Java&nbsp;IDL Object Request Broker Daemon, <tt>orbd</tt>. You can substitute 
a 
different
port if necessary.  When running these examples on a Windows machine, 
subtitute a backslash (\) in path names.</P>


<P> To run this client-server application on your development machine: 
<OL>

<LI>Change to the directory that contains the file <TT>Hello.idl</TT>.
<P>
<LI>Run the IDL-to-Java compiler, <TT>idlj</TT>, on the IDL file to
create stubs and skeletons.  This step assumes that you have included
the path to the java/bin directory in your path. <BR>

<PRE>
  idlj -fall  Hello.idl
</PRE>

<P>You must use the <TT>-fall</TT> option with the <TT>idlj</TT> compiler to generate 
both 
client and server-side bindings.  This command line will generate the default 
server-side 
bindings, 
which assumes the POA  Inheritance server-side model. For more information on the 
<TT>idlj</TT> options, link 
to <A HREF = "../rmi-iiop/toJavaPortableUG.html">IDL-to-Java compiler options</A>.  

<P>The <TT>idlj</TT> compiler generates a number of files.  The actual number of 
files 
generated depends on the options
selected when the IDL file is compiled.  The generated files provide standard
functionality, so you can
ignore them until it is time to deploy and run your program.
The files generated by the <TT>idlj</TT> compiler for <TT>Hello.idl</TT>, with the 
<TT>-fall</TT> command 
line option, are: 
<P>
<UL>
<LI><TT>HelloPOA.java</TT>
<P>This abstract class is the stream-based
<A href="jidlGlossary.html#server skeleton">server skeleton</A>, 
providing basic CORBA 
functionality for the server. It extends <a 
href="../../api/org/omg/PortableServer/Servant.html"><tt>org.omg.PortableServer.Serva
nt</tt>
</A>,  
and implements the <tt>InvokeHandler</tt> interface and the <tt>HelloOperations</tt> 
interface.  
The 
server class <TT>HelloImpl</TT> extends <TT>HelloPOA</TT>.  
<P>
<LI><TT>_HelloStub.java</TT>
<P>This class is the 
<A href="jidlGlossary.html#client stub">client stub</A>, 
providing CORBA functionality for the
client. It extends <tt>org.omg.CORBA.portable.ObjectImpl</tt> and implements the 
<TT>Hello.java</TT> 
interface.
<P>
<LI><TT>Hello.java</TT>
<P>This interface contains the Java version of our IDL interface. The 
<TT>Hello.java</TT> 
interface extends
<TT>org.omg.CORBA.Object</TT>, providing standard CORBA object functionality.  It 
also extends 
the 
<tt>HelloOperations</tt> interface and <tt>org.omg.CORBA.portable.IDLEntity</tt>.
<P>
<LI><TT>HelloHelper.java</TT>
<P>This class provides auxiliary functionality, notably the 
<TT>narrow()</TT> method required to cast CORBA 
<A href="jidlGlossary.html#object reference">object references</A> to their 
proper types.The Helper class is 
responsible for reading and writing the data type to CORBA streams, and inserting and 
extracting the data type from <tt>Any</tt>s.  The Holder class delegates to the 
methods in the 
Helper class for reading and writing.
<P>
<LI><TT>HelloHolder.java</TT>
<P>This final class holds a public instance member of type <TT>Hello</TT>.  Whenever
the IDL type is an <tt>out</tt> or an <tt>inout</tt> parameter, the Holder class is 
used.  It 
provides operations for <TT>org.omg.CORBA.portable.OutputStream</TT> and 
<TT>org.omg.CORBA.portable.InputStream</TT> arguments, which CORBA allows, but 
which do not map easily to Java's semantics. The Holder class delegates to the 
methods in the 
Helper class for reading and writing. It implements 
<tt>org.omg.CORBA.portable.Streamable</tt>. 
<P>
<LI><TT>HelloOperations.java</TT>
<P>This interface contains the methods <TT>sayHello()</TT> and <tt>shutdown()</tt>. 
The 
IDL-to-Java 
mapping 
puts all of the operations 
defined on the IDL interface into this file, which is shared by both the stubs and 
skeletons.
</UL>

<P>
<LI>Compile the <TT>.java</TT> files, including the stubs and skeletons
(which are in the directory <TT>HelloApp</TT>).  This step assumes the java/bin 
directory is included in your path.
<PRE>
   javac *.java HelloApp/*.java
</PRE>

<LI>Start <tt>orbd</tt>.  

<P>To start <tt>orbd</tt> from a UNIX command shell, enter:
   <P>   
<PRE>
  orbd -ORBInitialPort 1050&
</PRE>
<P>From an MS-DOS system prompt (Windows), enter:
<PRE>
  start orbd -ORBInitialPort 1050
</PRE>
   
 <P>Note that <TT>1050</TT> is the port on which you want the name server to run.   
The <tt>-ORBInitialPort</tt> argument is a required command-line argument.  Note that when using 
Solaris  software, you must become root to start a process on a port under 1024.  For 
this 
reason, 
we recommend that you use a port number greater than or equal to 1024.

<P> For an example of how to run this 
program on
two machines, see <a href="tutorial/jidl2machines.html">Running the Hello World 
Program on 
2 machines</a>.<P>
 
<LI>Start the Hello server:
<P>To start the Hello server from a UNIX command shell, enter:
   <P>   
<PRE>
  java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost&
</PRE>
<P>From an MS-DOS system prompt (Windows), enter:
<PRE>
  start java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost
</PRE>
<P>For this example, you can omit <TT>-ORBInitialHost localhost</TT> since the 
name server is  running on the same host as the Hello server.   If the name server is 
running 
on a 
different host, use  <TT>-ORBInitialHost</TT> <em>nameserverhost</em> to specify the 
host on 
which 
the IDL name server is running.

<P>Specify the name server (<tt>orbd</tt>) port as done in the previous step, for 
example, 
<TT>-ORBInitialPort  1050</TT>.  <P>

   
<LI>Run the client application:<P>
<PRE>
  java HelloClient -ORBInitialPort 1050 -ORBInitialHost localhost
</PRE>

<P>For this example, you can omit <TT>-ORBInitialHost localhost</TT> since the 
name server is  running on the same host as the Hello client.  If the name server is 
running 
on a 
different host, use  <TT>-ORBInitialHost</TT> <em>nameserverhost</em> to specify the 
host on 
which 
the IDL name server is running.

<P>Specify the name server (<tt>orbd</tt>) port as done in the previous step, for 
example, 
<TT>-ORBInitialPort  1050</TT>.  <P>
<P>
  
</OL>
   
   
   <P>When you have finished this tutorial, be sure to shut down or kill the name 
server 
(<tt>orbd</tt>).  To do this from a DOS prompt, select 
the window 
that is running the server and enter <TT>Ctrl+C</TT> to shut it down.  
To do this from a Unix shell, find the process, and kill it.  The server will 
continue to 
wait for 
invocations until it is explicitly stopped.


<P><STRONG><a href="tutorial/jidl2machines.html">Running the Hello World Application 
on Two 
Machines</a></STRONG> describes one way of distributing the simple application across 
two 
machines - a client and a server.



<CENTER><P><HR>

<TABLE summary="layout" cellpadding=8 cellspacing=4>
<TR>
  <TD ALIGN=CENTER><A href="index.html">Home</A></TD>
</TR></TABLE>


<HR><P><FONT SIZE="-2">

   <A HREF="../../relnotes/SMICopyright.html">Copyright &#169;</A> 1995-2001

   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>

  All Rights Reserved.</FONT></P>

</CENTER>



</BODY>

</HTML>
