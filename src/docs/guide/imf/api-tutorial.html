<!--This file created by Claris Home Page version 2.0-->
<HTML>
<HEAD>
   <TITLE>Input Method Client API Tutorial</TITLE>
   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0">
</HEAD>
<BODY BGCOLOR="#FFFFFF" VLINK="#000077">

<P><TABLE summary="layout" BORDER=0 WIDTH="100%">
   <TR>
      <TD WIDTH=60>
         <P><IMG SRC="../../images/javalogo52x88.gif" ALT="Java"
         WIDTH=52 HEIGHT=88 BORDER=0 ALIGN=bottom>
      </TD><TD>
         <H1><CENTER>Input Method Client API Tutorial</CENTER></H1>
      </TD></TR>
</TABLE><!-- Body text begins here --></P>

<H2>Contents</H2>

<OL>
   <LI><A HREF="#Implementing an Active Client Component">Implementing
   an Active Client Component</A>
   
   <UL>
      <LI><A HREF="#Handling Input Method Events">Handling Input
      Method Events</A>
      
      <LI><A HREF="#Handling Input Method Highlight Attributes">Handling
      Input Method Highlight Attributes</A>
      
      <LI><A HREF="#Handling Input Method Requests">Handling Input
      Method Requests</A>
      
      <LI><A HREF="#Ending Input Operations">Ending Input
      Operations</A>
   </UL>
   
   <LI><A HREF="#Enhancing an Active Client Component">Enhancing an
   Active Client Component</A>
   
   <UL>
      <LI><A HREF="#Handling Additional Text Attributes">Handling
      Additional Text Attributes</A>
      
      <LI><A HREF="#Creating Private Input Contexts">Creating Private
      Input Contexts</A>
      
      <LI><A HREF="#Selecting Input Methods">Selecting Input
      Methods</A>
      
      <LI><A HREF="#Setting an Expected Character Subset">Setting an
      Expected Character Subset</A>
      
      <LI><A HREF="#Using Engine-Specific Functionality">Using
      Engine-Specific Functionality</A>
   </UL>
   
   <LI><A HREF="#Implementing a Non-Client">Implementing a
   Non-Client</A>
   
   <LI><A HREF="#Sample Code">Sample Code</A>
</OL>

<P>
<HR>
</P>

<H2><A NAME="Implementing an Active Client Component"></A>1.
Implementing an Active Client Component</H2>

<P>The input method client API makes it possible for client
components to implement integrated text input user interfaces such as
on-the-spot input. The API defines events and methods that facilitate
the communication between a client component and an input method. It
also lets the client component request an input method for a
particular language.</P>

<P>Since the API doesn't make any assumptions about how and where the
text is drawn, it can also be used to implement other input styles
such as over-the-spot editing. In this style, the composed text is
drawn over surrounding text and covers it instead of being integrated
and formatted with it.</P>

<P>Any client component class can become an active client of the
input method client API and thus support an integrated text input
user interface by performing the following steps:</P>

<UL>
   <LI>Implement the <CODE>InputMethodListener</CODE> interface to
   handle incoming <CODE>InputMethodEvents</CODE> generated by the
   current input method, and register the listener.
   
   <LI>Implement the <CODE>InputMethodRequests</CODE> interface and
   override <CODE>getInputMethodRequests</CODE> to return the request
   handler.
   
   <LI>Store <CODE>InputMethodHighlight</CODE> attributes along with
   composed text and pass them on to the drawing routines.
   
   <LI>End input operations when the user initiates an operation that
   requires all text to be committed.
</UL>

<P>Optionally, the client component can also use the following
functionality:</P>

<UL>
   <LI>Store other text attributes that are created by input methods,
   and return them when text is requested.
   
   <LI>Create a private input context (instead of sharing one with
   other components in the same window).
   
   <LI>Select input methods, for example, based on the language of
   the text being edited.
   
   <LI>Set an expected character subset.
</UL>

<P>Client components don't need to deal with setting up input
contexts, activating or deactivating contexts, or dispatching events
to input methods, since all this is handled automatically by AWT.
</P>

<H3><A NAME="Handling Input Method Events"></A>Handling Input Method
Events</H3>

<P>The input method framework provides an event class,
<CODE><A HREF="../../api/java/awt/event/InputMethodEvent.html">InputMethodEvent</A></CODE>,
to support the communication between input methods and text
components. The class has two separate event kinds: text changed and
caret changed. An event listener interface,
<CODE><A HREF="../../api/java/awt/event/InputMethodListener.html">InputMethodListener</A></CODE>,
supports these two events. An active client component must implement
the <CODE>InputMethodListener</CODE> interface, register the
listener, and handle both kinds of events.</P>

<P><CODE>InputMethodEvent</CODE> instances are sent to the client
component when there is a change to the user's input text, its
highlighting, or to the caret location within the composed text. The
event sent for caret-only changes is a simplified version of the one
for text changes (it just doesn't have text information), so the
following discussion assumes the text-changed event.</P>

<P>An event reporting a text change has a reference to an instance of
<CODE><A HREF="../../api/java/text/AttributedCharacterIterator.html">AttributedCharacterIterator</A></CODE>
that represents either composed text or committed text or both
together. The event's committed character count value specifies how
many characters in the iterator's range are committed text; all
remaining characters are composed text. Committed text always
precedes composed text. If the component has no previous composed
text, the committed and composed text replace any selected text or
are inserted at the current insertion position of the component's
text. If there is previous composed text, the entire previous
composed text is replaced with the new committed and composed text.
The insertion point moves to the end of the committed text. The
client component is responsible for redrawing the updated text.</P>

<P>The event also contains information about the current caret
location within the composed text (null if no caret is to be
displayed), and about the part of the composed text that is most
important to keep in view (null if the input method doesn't have a
recommendation).</P>

<H3><A NAME="Handling Input Method Highlight Attributes"></A>Handling
Input Method Highlight Attributes</H3>

<P>The text component generally draws the composed text as part of
the text being edited, using its regular text layout and drawing
functionality. However, it needs to add certain highlight style
attributes to the composed text to indicate the current state of the
composition. The framework defines these style attributes as abstract
styles (for example, "unconverted unselected text" or "converted
selected text"), and maps them internally to platform-dependent
concrete styles (for example, 2-pixel gray underline).</P>

<P>Highlight attributes are represented by the
<CODE><A HREF="../../api/java/awt/im/InputMethodHighlight.html">InputMethodHighlight</A></CODE>
class. Instances of this class are used as attribute values of the
AttributedCharacterIterator instances representing composed text.
Text components must store these attributes with the composed text
and pass them on to the drawing routines when drawing composed text.
They can use either the
<CODE><A HREF="../../api/java/awt/Graphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A></CODE>
methods that accept <CODE>AttributedCharacterIterator</CODE>, or
create a
<CODE><A HREF="../../api/java/awt/font/TextLayout.html">TextLayout</A></CODE>
from the iterator and use its draw method. These drawing methods
interact with the input method framework to map abstract to concrete
highlight styles. Text components using these methods therefore
generally do not need to be concerned with the internal details of
the input method highlights. If a text component uses some other
mechanism to render the text, it should check the input method
highlight for concrete style information, and, if none is provided,
use
<CODE><A HREF="../../api/java/awt/Toolkit.html#mapInputMethodHighlight(java.awt.im.InputMethodHighlight)">Toolkit.mapInputMethodHighlight</A></CODE>
to map to a concrete style.</P>

<P>Some input methods may treat highlights as "annotations".
Annotations are attributes that apply to a specified range of text,
but not to subranges or the concatenation of ranges. They are
represented by wrapping the <CODE>InputMethodHighlight</CODE>
instance into an
<CODE><A HREF="../../api/java/text/Annotation.html">Annotation</A></CODE>
instance. Input methods may use annotation highlights to separate
text segments that will be converted as separate units. On some
platforms, these highlights are rendered so as to make the segments
visible, for example, by using underlines with short breaks between
the segments. Text components have to be able to handle input method
highlights whether they are wrapped in <CODE>Annotation</CODE>
instances or not. If a text component implements line wrapping,
special care needs to be taken when the range to which a highlight
annotation applies crosses a line boundary: The normal behavior
(implemented, for example, in
<CODE><A HREF="../../api/java/text/AttributedString.html">AttributedString</A></CODE>)
would be to discard the attribute because it doesn't apply to
subranges. But, since in this case there's only a visual break and
not a logical break, the highlight needs to be preserved - it has to
be treated as if it applied to the subranges that are rendered on
separate lines. One way to do this is by implementing the
<CODE>AttributedCharacterIterator</CODE> in a way that returns
highlight annotations even for subranges of the intended range.</P>

<H3><A NAME="Handling Input Method Requests"></A>Handling Input
Method Requests</H3>

<P>An input method needs to access component information to perform
input operations. For example, an input method needs to know the
location where a list of possible choices can be shown.</P>

<P>An active client component therefore must implement the
<CODE><A HREF="../../api/java/awt/im/InputMethodRequests.html">InputMethodRequests</A></CODE>
interface, and override
<CODE><A HREF="../../api/java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A></CODE>
to return the request handler. The interface includes methods to:
</P>

<UL>
   <LI>Perform conversions between screen coordinates and offsets
   within the composed text.
   
   <LI>Obtain specified text of the component.
   
   <LI>Cancel the latest committed text.
   
   <LI>Obtain the insertion position within the component's committed
   text.
</UL>

<H3><A NAME="Ending Input Operations"></A>Ending Input Operations
</H3>

<P>Input methods typically recognize some user actions that end input
operations, for example, an operation that commits all uncommitted
text. However, there are also user actions that start operations for
which input operations should be ended, but that an input method
cannot recognize. Saving the document containing the text is one such
example. In these cases, the component has to explicitly call the
input context's
<CODE><A HREF="../../api/java/awt/im/InputContext.html#endComposition()">endComposition</A></CODE>
method.</P>

<P>
<HR>
</P>

<H2><A NAME="Enhancing an Active Client Component"></A>2. Enhancing
an Active Client Component</H2>

<H3><A NAME="Handling Additional Text Attributes"></A>Handling
Additional Text Attributes</H3>

<P>In addition to the input method highlight information, input
methods may also attach other attributes to the text they send to a
text component. These attributes may be useful information for the
component. They may also improve the input method's performance if
returned by the <CODE>InputMethodRequest</CODE> methods. For the
latter reason, it is recommended that text components keep this
attribute information around while the text is being edited, and
return it with any text requested.</P>

<P>The
<CODE><A HREF="../../api/java/text/AttributedCharacterIterator.Attribute.html">AttributedCharacterIterator.Attribute</A></CODE>
class defines the following common attributes:</P>

<UL>
   <LI><CODE>LANGUAGE</CODE> - the language of the text, specified as
   a <CODE>Locale</CODE> object.
   
   <LI><CODE>READING</CODE> - a phonetic representation
   (<EM>yomi</EM> in Japanese), specified as a <CODE>String</CODE>
   object.
   
   <LI><CODE>INPUT_METHOD_SEGMENT</CODE> - segmentation information
   used by input methods.
</UL>

<P>Input methods written in the Java programming language may define
additional attributes.</P>

<H3><A NAME="Creating Private Input Contexts"></A>Creating Private
Input Contexts</H3>

<P>By default, one <CODE>InputContext</CODE> instance is created per
Window instance, and this input context is shared by all components
within the window's containment hierarchy. This reduces the number of
instances created overall, and lets input methods combine information
about all the text entered in this window (input methods often use
information about previously entered text to improve their conversion
accuracy). It means, however, that only one input operation is
possible at any one time within a window, and that the text needs to
be committed when moving the focus from one text component to
another. If this is not desired, text components can create their own
input context instances and override
<CODE><A HREF="../../api/java/awt/Component.html#getInputContext()">getInputContext</A></CODE>
to return them. A component that doesn't have its own input context
uses the one used by its parent.</P>

<H3><A NAME="Selecting Input Methods"></A>Selecting Input Methods
</H3>

<P>Text components can use the input context's
<CODE><A HREF="../../api/java/awt/im/InputContext.html#selectInputMethod(java.util.Locale)">selectInputMethod</A></CODE>
operation to select an input method for a given language or locale.
This may be helpful, for example, if the user clicks in text that is
written in that language, since it's likely that she wants to
continue in the same language. Or, the text component may know that
the application only allows text in a certain language to be entered.
</P>

<H3><A NAME="Setting an Expected Character Subset"></A>Setting an
Expected Character Subset</H3>

<P>Text components can use the input context's
<CODE><A HREF="../../api/java/awt/im/InputContext.html#setCharacterSubsets(java.lang.Character.Subset[])">setCharacterSubsets</A></CODE>
operation to tell input methods which characters can be meaningfully
entered. For example, a database application may know that certain
fields should only receive input in hiragana (one of the syllabic
subscripts used in Japanese), another one only Latin characters, a
third one any kind of characters. Passing on this information to
input methods may allow the input methods to limit the range of
characters that can be entered, or to switch to a different input
mode that particularly supports the specified character subsets.</P>

<H3><A NAME="Using Engine-Specific Functionality"></A>Using
Engine-Specific Functionality</H3>

<P>Some input methods may provide functionality to client components
that can not be made available through the input method framework
API. This is possible through <EM>input method control objects</EM>.
The input method developer must publish an interface for these
objects. Client components that want to take advantage of the
additional functionality can then call
<CODE><A HREF="../../api/java/awt/im/InputContext.html#getInputMethodControlObject()">InputContext.getInputMethodControlObject</A></CODE>,
check whether the returned object is an instance of a known control
object class, and if it is, call its methods.</P>

<P>
<HR>
</P>

<H2><A NAME="Implementing a Non-Client"></A>3. Implementing a
Non-Client</H2>

<P>By default, all components that process key events are clients of
the input method framework, that is, input method support is enabled
for them. In some cases, components may not want to have their input
processed by input methods. For example, games may want to interpret
keyboard events directly. These components should call
<CODE><A HREF="../../api/java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A>(false)</CODE>,
so that events do not get forwarded to input methods.</P>

<P>
<HR>
</P>

<H2><A NAME="Sample Code"></A>4. Sample Code</H2>

<P>This sample code shows how to implement the different kinds of
input method clients that are possible with the input method
framework: an active client, a passive client, a non-client, and a
peered text component.</P>

<UL>
   <LI><B><A HREF="api-sample/IMFDemo.html">Applet</A> </B>- run this
   applet in a Java 2 enabled browser, and you can experiment with
   the different client components.
   
   <LI><B>Javadoc</B>
   
   <UL>
      <LI><A HREF="api-sample/LWTextComponent.html">LWTextComponent</A>
      - explains the structure of a lightweight text editing
      component that can be extended to an active client.
      
      <LI><A HREF="api-sample/ActiveClient.html">ActiveClient</A> -
      explains the structure of an active client component.
   </UL>
   
   <LI><B>Source Code</B>
   
   <UL>
      <LI><A HREF="api-sample/IMFDemo.java">IMFDemo.java</A> - the
      applet/application that contains the different client
      components.
      

      <LI><A HREF="api-sample/LWTextComponent.java">LWTextComponent.java</A>
      - a lightweight text editing component that doesn't know about
      input methods, but can be extended to an active client.
      
      <LI><A HREF="api-sample/ActiveClient.java">ActiveClient.java</A>
      - extends LWTextComponent to become an active client component.
      
      <LI><A HREF="api-sample/PeeredTextArea.java">PeeredTextArea.java</A>
      - a peered text component.
   </UL>
</UL>

<P><!-- Body text ends here --><!-- ============================================================== -->
<HR SIZE="3" NOSHADE>
<TABLE summary="layout" BORDER=0 WIDTH="100%">
   <TR>
      <TD VALIGN=top>
         <P><FONT
         SIZE="-2"><A HREF="../../relnotes/SMICopyright.html">Copyright
         &copy;</A></FONT><FONT SIZE="-2"> 1995-99 </FONT><FONT
         SIZE="-2"><A HREF="http://www.sun.com/">Sun Microsystems,
         Inc.</A></FONT><FONT SIZE="-2"> All Rights Reserved.</FONT>
         </P>
         
         <P><FONT SIZE="-1">Please send comments to: </FONT><FONT
         SIZE="-1"><A HREF="mailto:java-intl@java.sun.com">java-intl@java.sun.com</A></FONT><FONT
         SIZE="-1"> </FONT>
      </TD><TD VALIGN=top align=RIGHT>
         <P ALIGN=RIGHT><IMG SRC="../../images/sunlogo64x30.gif"
         ALT="Sun" WIDTH=64 HEIGHT=30 BORDER=0 ALIGN=bottom><BR>
         
         <I><FONT SIZE="+1">Java Software</FONT></I><FONT SIZE="+1">
         </FONT>
      </TD></TR>
</TABLE></P>
</BODY>
</HTML>
