<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>Java Security Architecture:  - 
</title>
</head>
<body bgcolor="#ffffff">
 
<table summary="layout" width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href=security-specTOC.fm.html>CONTENTS</a> | <a href="security-spec.doc2.html">PREV</a>
 | <a href="security-spec.doc4.html">NEXT</a> <!-- | <a href="security-spec.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>Java Security Architecture</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="19802"><i>	3	</i> Permissions and Security Policy
</a></h2>


<br>
<h3>
<a name="17001"><!-- --></a>
<i>	3.1	 </i> The Permission Classes 
</h3>

<blockquote>
<a name="19229"><!-- --></a>
The permission classes represent access to system resources. The java.security.Permission class is an abstract class and is subclassed, as appropriate, to represent specific accesses. <p>
<a name="28891"><!-- --></a>
As an example of a permission, the following  code can be used to produce a permission to read the file named &#34;abc&#34; in the /tmp directory:<p>
</blockquote><blockquote><pre>    perm = new java.io.FilePermission("/tmp/abc", "read");
</pre></blockquote><blockquote>
<a name="23134"><!-- --></a>
New permissions are subclassed either from the Permission class or one of its subclasses, such as java.security.BasicPermission. Subclassed permissions (other than BasicPermission) generally belong to their own packages. Thus, FilePermission is found in the java.io package.<p>
<a name="17186"><!-- --></a>
A crucial abstract method that needs to be implemented for each new class of permission is the <code>implies</code> method. Basically, &#34;a implies b&#34; means that if one is granted permission &#34;a&#34;, one is naturally granted permission &#34;b&#34;. This is important when making access control decisions.<p>
<a name="19232"><!-- --></a>
Associated with the abstract class java.security.Permission are the abstract class named java.security.PermissionCollection and the final class java.security.Permissions.<p>
<a name="28899"><!-- --></a>
Class java.security.PermissionCollection represents a collection (i.e., a set that allows duplicates) of Permission objects for a single category (such as file permissions), for ease of grouping. In cases where permissions can be added to the PermissionCollection object in any order, such as for file permissions, it is crucial that the PermissionCollection object ensure that the correct semantics are followed when the <code>implies</code> function is called.<p>
<a name="18949"><!-- --></a>
Class java.security.Permissions represents a collection of collections of Permission objects, or in other words, a super collection of heterogeneous permissions.<p>
<a name="19896"><!-- --></a>
Applications are free to add new categories of permissions that the system supports.  How to add such application-specific permissions is discussed later in this document.<p>
<a name="19897"><!-- --></a>
Now we describe the syntax and semantics of all built-in permissions.<p>
</blockquote>
<br>
<a name="19902"><!-- --></a>
<h4><i>	3.1.1	  java.security.Permission
</i></h4>

<blockquote>
<a name="19924"><!-- --></a>
This abstract class is the ancestor of all permissions.  It defines the essential functionalities required for all permissions.  <p>
<a name="19953"><!-- --></a>
Each permission instance is typically generated by passing one or more string parameters to the constructor.  In a common case with two parameters, the first parameter is usually &#34;the name of the target&#34; (such as the name of a file for which the permission is aimed), and the second parameter is the action (such as &#34;read&#34; action on a file).  Generally, a set of actions can be specified together as a comma-separated composite string.<p>
</blockquote>
<br>
<a name="19905"><!-- --></a>
<h4><i>	3.1.2	  java.security.PermissionCollection
</i></h4>

<blockquote>
<a name="19925"><!-- --></a>
This class holds a homogeneous collection of permissions.  In other words, each instance of the class holds only permissions of the same type.<p>
</blockquote>
<br>
<a name="19911"><!-- --></a>
<h4><i>	3.1.3	  java.security.Permissions
</i></h4>

<blockquote>
<a name="19926"><!-- --></a>
This class is designed to hold a heterogeneous collection of permissions.  Basically, it is a collection of java.security.PermissionCollection objects.<p>
</blockquote>
<br>
<a name="22515"><!-- --></a>
<h4><i>	3.1.4	  java.security.UnresolvedPermission
</i></h4>

<blockquote>
<a name="22517"><!-- --></a>
Recall that the internal state of a security policy is normally expressed by the permission objects that are associated with each code source.  Given the dynamic nature of Java technology, however, it is possible that when the policy is initialized the actual code that implements a particular permission class has not yet been loaded and defined in the Java application environment. For example, a referenced permission class may be in a JAR file that will later be loaded.<p>
<a name="29080"><!-- --></a>
The UnresolvedPermission class is used to hold such &#34;unresolved&#34; permissions. Similarly, the class java.security.UnresolvedPermissionCollection stores a collection of UnresolvedPermission permissions.<p>
<a name="24363"><!-- --></a>
During access control checking on a permission of a type that was previously unresolved, but whose class has since been loaded, the unresolved permission is &#34;resolved&#34; and the appropriate access control decision is made. That is, a new object of the appropriate class type is instantiated, if possible, based on the information in the UnresolvedPermission. This new object replaces the UnresolvedPermission, which is removed.<p>
<a name="22542"><!-- --></a>
If the permission is still unresolvable at this time, the permission is considered invalid, as if it is never granted in a security policy.<p>
</blockquote>
<br>
<a name="19913"><!-- --></a>
<h4><i>	3.1.5	  java.io.FilePermission
</i></h4>

<blockquote>
<a name="19994"><!-- --></a>
The targets for this class can be specified in the following ways, where directory and file names are strings that cannot contain white spaces.<p>
</blockquote><blockquote><pre>file
directory (same as directory/)
directory/file
directory/* (all files in this directory)
* (all files in the current directory)
directory/- (all files in the file system under this directory)
- (all files in the file system under the current directory)
"&lt;&lt;ALL FILES&gt;&gt;" (all files in the file system)
</pre></blockquote><blockquote>
<a name="19990"><!-- --></a>
Note that &#34;&lt;&lt;ALL FILES&gt;&gt;&#34; is a special string denoting all files in the system.  On a Unix system, this includes all files under the root directory.  On an MS-DOS system, this includes all files on all drives.<p>
<a name="23161"><!-- --></a>
The actions are: <b>read</b>, <b>write</b>, <b>delete</b>, and <b>execute</b>. Therefore, the following are valid code samples for creating file permissions:<p>
</blockquote><blockquote><pre>import java.io.FilePermission;

FilePermission p = new FilePermission("myfile", "read,write");
FilePermission p = new FilePermission("/home/gong/", "read");
FilePermission p = new FilePermission("/tmp/mytmp", "read,delete");
FilePermission p = new FilePermission("/bin/*", "execute");
FilePermission p = new FilePermission("*", "read");
FilePermission p = new FilePermission("/-", "read,execute");
FilePermission p = new FilePermission("-", "read,execute");
FilePermission p = new FilePermission("&lt;&lt;ALL FILES&gt;&gt;", "read");
</pre></blockquote><blockquote>
<a name="19988"><!-- --></a>
The <code>implies</code> method in this class correctly interprets the file system.  For example, FilePermission(&#34;/-&#34;, &#34;read,execute&#34;) implies FilePermission(&#34;/home/gong/public_html/index.html&#34;, &#34;read&#34;), and FilePermission(&#34;bin/*&#34;, &#34;execute&#34;) implies FilePermission(&#34;bin/emacs19.31&#34;, &#34;execute&#34;).<p>
<a name="24371"><!-- --></a>
Note: Most of these strings are given in platform-dependent format.  For example, to represent read access to the file named "foo" in the "temp" directory on the C drive of a Windows system, you would use<p>
</blockquote><blockquote><pre>FilePermission p = new FilePermission("c:\\temp\\foo", "read");
</pre></blockquote><blockquote>
<a name="25819"><!-- --></a>
The double backslashes are necessary to represent a single backslash because the strings are processed by a tokenizer (java.io.StreamTokenizer), which allows &#34;\&#34; to be used as an escape string (e.g., &#34;\n&#34; to indicate a new line) and which thus requires two backslashes to indicate a single backslash. After the tokenizer has processed the above FilePermission target string, converting double backslashes to single backslashes, the end result is the actual path<p>
</blockquote><blockquote><pre>"c:\temp\foo"
</pre></blockquote><blockquote>
<a name="24395"><!-- --></a>
It is necessary that the strings be given in platform-dependent format until there is a universal file description language.  Note also that the use of meta symbols such as &#34;*&#34; and &#34;-&#34; prevents the use of specific file names.  We think this is a small limitation that can be tolerated for the moment. Finally, note that &#34;/-&#34; and &#34;&lt;&lt;ALL FILES&gt;&gt;&#34; are the same target on Unix systems in that they both refer to the entire file system. (They can refer to multiple file systems if they are all available).  The two targets are potentially different on other operating systems, such as MS Windows and MacOS.<p>
<a name="24336"><!-- --></a>
Also note that a target name that specifies just a directory, with a &#34;read&#34; action, as in<p>
</blockquote><blockquote><pre>FilePermission p = new FilePermission("/home/gong/", "read");
</pre></blockquote><blockquote>
<a name="24338"><!-- --></a>
means you are only giving permission to list the files in that directory, not read any of them. To allow read access to files, you must specify either an explicit file name, or an &#34;*&#34; or &#34;-&#34;, as in<p>
</blockquote><blockquote><pre>FilePermission p = new FilePermission("/home/gong/myfile", "read");
FilePermission p = new FilePermission("/home/gong/*", "read");
FilePermission p = new FilePermission("/home/gong/-", "read");
</pre></blockquote><blockquote>
<a name="27675"><!-- --></a>
And finally, note that code always automatically has permission to read files from its same (URL) location, and subdirectories of that location; it does not need explicit permission to do so.<p>
</blockquote>
<br>
<a name="19915"><!-- --></a>
<h4><i>	3.1.6	  java.net.SocketPermission
</i></h4>

<blockquote>
<a name="19989"><!-- --></a>
This class represents access to a network via sockets. The target for this class can be given as &#34;hostname:port_range&#34;, where hostname can be given in the following ways:<p>
</blockquote><blockquote><pre>hostname (a single host)
IP address (a single host)
localhost (the local machine)
"" (equivalent to "localhost")
hostname.domain (a single host within the domain)
hostname.subdomain.domain
*.domain (all hosts in the domain)
*.subdomain.domain
* (all hosts)
</pre></blockquote><blockquote>
<a name="26297"><!-- --></a>
That is, the host is expressed as a DNS name, as a numerical IP address, as &#34;localhost&#34; (for the local machine) or as &#34;&#34; (which is equivalent to specifying &#34;localhost&#34;).<p>
<a name="26313"><!-- --></a>
The wildcard "*" may be included once in a DNS name host specification. If it is included, it must be in the leftmost position, as in "*.sun.com".<p>
<a name="26312"><!-- --></a>
The port_range can be given as follows:<p>
</blockquote><blockquote><pre>N (a single port)
N- (all ports numbered N and above)
-N (all ports numbered N and below)
N1-N2 (all ports between N1 and N2, inclusive)
</pre></blockquote><blockquote>
<a name="20027"><!-- --></a>
Here N, N1, and N2 are non-negative integers ranging from 0 to 65535 (2^16-1).<p>
<a name="20036"><!-- --></a>
The actions on sockets are <b>accept</b>, <b>connect</b>, <b>listen</b>, and <b>resolve</b> (which is basically DNS lookup).  Note that implicitly, the action &#34;resolve&#34; is implied by &#34;accept&#34;, &#34;connect&#34;, and &#34;listen&#34; -- i.e., those who can listen or accept incoming connections from or initiate out-going connections to a host should be able to look up the name of the remote host.<p>
<a name="20042"><!-- --></a>
Below are some examples of socket permissions.<p>
</blockquote><blockquote><pre>import java.net.SocketPermission;

SocketPermission p = new SocketPermission("java.sun.com","accept");
p = new SocketPermission("204.160.241.99","accept");
p = new SocketPermission("*.com","connect");
p = new SocketPermission("*.sun.com:80","accept");
p = new SocketPermission("*.sun.com:-1023","accept");
p = new SocketPermission("*.sun.com:1024-","connect");
p = new SocketPermission("java.sun.com:8000-9000",
         "connect,accept");
p = new SocketPermission("localhost:1024-",
          "accept,connect,listen");
</pre></blockquote><blockquote>
<a name="20092"><!-- --></a>
Note that SocketPermission(&#34;java.sun.com:80,8080&#34;,&#34;accept&#34;) and SocketPermission(&#34;java.sun.com,javasun.sun.com&#34;,&#34;accept&#34;) are not valid socket permissions.<p>
<a name="21604"><!-- --></a>
Moreover, because <b>listen</b> is an action that applies only to ports on the local host, whereas <b>accept</b> is an action that applies to ports on both the local and remote host, both actions are necessary.<p>
</blockquote>
<br>
<a name="20057"><!-- --></a>
<h4><i>	3.1.7	  java.security.BasicPermission
</i></h4>

<blockquote>
<a name="23199"><!-- --></a>
The BasicPermission class extends the Permission class. It can be used as the base class for permissions that want to follow the same naming convention as BasicPermission (see below).<p>
<a name="23200"><!-- --></a>
The name for a BasicPermission is the name of the given permission (for example, &#34;exitVM&#34;, &#34;setFactory&#34;, &#34;queuePrintJob&#34;, etc). The naming convention follows the  hierarchical property naming convention. An asterisk may appear at the end of the name, following a &#34;.&#34;, or by itself, to signify a wildcard match. For example: &#34;java.*&#34; or &#34;*&#34; is valid, &#34;*java&#34; or &#34;a*b&#34; is not valid.<p>
<a name="23201"><!-- --></a>
The action string (inherited from Permission) is unused.Thus, BasicPermission is commonly used as the base class for "named" permissions (ones that contain a name but no actions list; you either have the named permission or you don't.) Subclasses may implement actions on top of BasicPermission, if desired.<p>
<a name="27099"><!-- --></a>
Some of the BasicPermission subclasses are java.lang.RuntimePermission, java.security.SecurityPermission, java.util.PropertyPermission, and java.net.NetPermission.<p>
</blockquote>
<br>
<a name="20107"><!-- --></a>
<h4><i>	3.1.8	  java.util.PropertyPermission
</i></h4>

<blockquote>
<a name="20118"><!-- --></a>
The targets for this class are basically the names of Java properties as set in various property files. Examples are the &#34;java.home&#34; and &#34;os.name&#34; properties. Targets can be specified as &#34;*&#34; (any property), &#34;a.*&#34; (any property whose name has a prefix &#34;a.&#34;), &#34;a.b.*&#34;, and so on.  Note that the wildcard can occur only once and can only be at the rightmost position.<p>
<a name="24233"><!-- --></a>
This is one of the BasicPermission subclasses that implements actions on top of BasicPermission. The actions are read and write. Their meaning is defined as follows: &#34;read&#34; permission allows the <code>getProperty</code> method in java.lang.System to be called to get the property value, and &#34;write&#34; permission allows the <code>setProperty</code> method to be called to set the property value. <p>
</blockquote>
<br>
<a name="20113"><!-- --></a>
<h4><i>	3.1.9	  java.lang.RuntimePermission
</i></h4>

<blockquote>
<a name="20122"><!-- --></a>
The target for a RuntimePermission can be represented by any string, and there is no action associated with the targets.  For example, RuntimePermission(&#34;exitVM&#34;) denotes the permission to exit the Java Virtual Machine.<p>
<a name="20310"><!-- --></a>
The target names are:<p>
</blockquote><blockquote><pre>createClassLoader
getClassLoader
setContextClassLoader
setSecurityManager
createSecurityManager
exitVM
setFactory
setIO
modifyThread
stopThread
modifyThreadGroup
getProtectionDomain
readFileDescriptor
writeFileDescriptor
loadLibrary.{library name}
accessClassInPackage.{package name}
defineClassInPackage.{package name}
accessDeclaredMembers.{class name}
queuePrintJob
</pre></blockquote>
<br>
<a name="20327"><!-- --></a>
<h4><i>	3.1.10	  java.awt.AWTPermission
</i></h4>

<blockquote>
<a name="20351"><!-- --></a>
This is in the same spirit as the RuntimePermission; it&#39;s a permission without actions. The targets for this class are:<p>
</blockquote><blockquote><pre>accessClipboard
accessEventQueue
listenToAllAWTEvents
showWindowWithoutWarningBanner
</pre></blockquote>
<br>
<a name="20353"><!-- --></a>
<h4><i>	3.1.11	  java.net.NetPermission
</i></h4>

<blockquote>
<a name="20120"><!-- --></a>
This class contains the following targets and no actions:<p>
</blockquote><blockquote><pre>requestPasswordAuthentication
setDefaultAuthenticator
specifyStreamHandler
</pre></blockquote>
<br>
<a name="26158"><!-- --></a>
<h4><i>	3.1.12	  java.lang.reflect.ReflectPermission
</i></h4>

<blockquote>
<a name="26161"><!-- --></a>
This is the Permission class for reflective operations.  A ReflectPermission is a named permission (like RuntimePermission) and has no actions.  The only name currently defined is <p>
</blockquote><blockquote><pre>suppressAccessChecks
</pre></blockquote><blockquote>
<a name="26186"><!-- --></a>
which allows suppressing the standard Java programming language access checks -- for public, default (package) access, protected, and private members -- performed by reflected objects at their point of use.<p>
</blockquote>
<br>
<a name="26159"><!-- --></a>
<h4><i>	3.1.13	  java.io.SerializablePermission
</i></h4>

<blockquote>
<a name="26194"><!-- --></a>
This class contains the following targets and no actions:<p>
</blockquote><blockquote><pre>enableSubclassImplementation
enableSubstitution
</pre></blockquote>
<br>
<a name="26196"><!-- --></a>
<h4><i>	3.1.14	  java.security.SecurityPermission
</i></h4>

<blockquote>
<a name="26201"><!-- --></a>
SecurityPermissions control access to security-related objects, such as Security, Policy, Provider, Signer, and Identity objects. This class contains the following targets and no actions:<p>
</blockquote><blockquote><pre>getPolicy
setPolicy
getProperty.{key}
setProperty.{key}
insertProvider.{provider name}
removeProvider.{provider name}
setSystemScope
setIdentityPublicKey
setIdentityInfo
printIdentity
addIdentityCertificate
removeIdentityCertificate
clearProviderProperties.{provider name}
putProviderProperty.{provider name}
removeProviderProperty.{provider name}
getSignerPrivateKey
setSignerKeyPair
</pre></blockquote>
<br>
<a name="26221"><!-- --></a>
<h4><i>	3.1.15	  java.security.AllPermission
</i></h4>

<blockquote>
<a name="22641"><!-- --></a>
This permission implies all permissions.  It is introduced to simplify the work of system administrators who might need to perform multiple tasks that require all (or numerous) permissions.  It would be inconvenient to require the security policy to iterate through all permissions.  Note that AllPermission also implies new permissions that are defined in the future.<p>
<a name="22644"><!-- --></a>
Clearly much caution is necessary when considering granting this permission.<p>
</blockquote>
<br>

<a name="AuthPermission"><!-- --></a>
<h4><i> 3.1.16    javax.security.auth.AuthPermsision
</i></h4>
<blockquote>
<a name="AuthPermission description"><!-- --></a>
AuthPermission handles authentication permissions and authentication-related
object such as Subject, SubjectDomainCombiner, LoginContext,
and Configuration.  This class contains the following targets and no actions:
<p>
<pre>
doAs
doAsPrivileged
getSubject
getSubjectFromDomainCombiner
setReadOnly
modifyPrincipals
modifyPublicCredentials
modifyPrivateCredentials
refreshCredential
destroyCredential
createLoginContext.{name}
getLoginConfiguration
setLoginConfiguration
refreshLoginConfiguration
</pre>
</blockquote>
<br>

<a name="22640"><!-- --></a>
<h4><i>	3.1.17	  Discussion of Permission Implications
</i></h4>

<blockquote>
<a name="22636"><!-- --></a>
Recall that permissions are often compared against each other, and to facilitate such comparisons, we require that each permission class defines an <code>implies </code>method  that represents how the particular permission class relates to other permission classes.  For example, java.io.FilePermission(&#34;/tmp/*&#34;, &#34;read&#34;) implies java.io.FilePermission(&#34;/tmp/a.txt&#34;, &#34;read&#34;) but does not imply any java.net.NetPermission.<p>
<a name="22639"><!-- --></a>
There is another layer of implication that may not be immediately obvious to some readers.  Suppose that one applet has been granted the permission to write to the entire file system.  This presumbly allows the applet to replace the system binary, including the JVM runtime environment.  This effectively means that the applet has been granted all permissions.<p>
<a name="22642"><!-- --></a>
Another example is that if an applet is granted the runtime permission to create class loaders, it is effectively granted many more permissions, as a class loader can perform sensitive operations.<p>
<a name="22643"><!-- --></a>
Other permissions that are &#34;dangerous&#34; to give out include those that allow the setting of system properties, runtime permissions for defining packages and for loading native code libraries (because the Java security architecture is not designed to and does not prevent malicious behavior at the level of native code), and of course the AllPermission.<p>
<a name="29284"><!-- --></a>
For more information about permissions, including tables enumerating the risks of assigning specific permissions as well as a table of all the Java 2 SDK  built-in methods that require permissions, see <code>http://java.sun.com/j2se/sdk/1.2/docs/guide/security/permissions.html</code>.<p>
</blockquote>
<br>
<a name="20211"><!-- --></a>
<h4><i>	3.1.18	  How To Create New Types of Permissions
</i></h4>

<blockquote>
<a name="20183"><!-- --></a>
It is essential that no one except Sun Microsystems should extend the permissions that are built into the Java 2 SDK, either by adding new functionality or by introducing additional target keywords into a class such as java.lang.RuntimePermission.  This maintains consistency.<p>
<a name="21125"><!-- --></a>
To create a new permission, the following steps are recommended, as shown by an example. Suppose an application developer from company ABC wants to create a customized permission to &#34;watch TV&#34;.<p>
<a name="21131"><!-- --></a>
First, create a new class com.abc.Permission that extends the abstract class java.security.Permission (or one of its subclasses), and another new class com.abc.TVPermission that extends the com.abc.Permission. Make sure that the <code>implies</code> method, among others, is correctly implemented. (Of course, com.abc.TVPermission can directly extend java.security.Permission; the intermediate com.abc.Permission is not required.)<p>
</blockquote><blockquote><pre>public class com.abc.Permission extends java.security.Permission

public class com.abc.TVPermission extends com.abc.Permission
</pre></blockquote><blockquote>
<a name="20190"><!-- --></a>
The following figure shows the subclass relationship. <p>
<a name="22238"><!-- --></a>
<p><center><img alt="Flow chart showing the logic flows from Permission to the subclass com.abc.Permission and then to com.abc.TVPermission" src="security-spec.doc.anc8.gif"></center><p>
<a name="20195"><!-- --></a>
<p>
<a name="20219"><!-- --></a>
Second, include these new classes with the application package. <p>
<a name="29053"><!-- --></a>
Each user that wants to allow this new type of permission for specific code does so by adding an entry in a policy file. (Details of the policy file syntax are given in a later section.) An example of a policy file entry granting code from http://java.sun.com/ permission to watch channel 5 would be:<p>
</blockquote><blockquote><pre>grant codeBase&#160; "http://java.sun.com/" {
    permission com.abc.TVPermission "channel-5", "watch";
    }
</pre></blockquote><blockquote>
<a name="20199"><!-- --></a>
In the application&#39;s resource management code, when checking to see if a permission should be granted, call AccessController&#39;s <code>checkPermission</code> method using a com.abc.TVPermission object as the parameter.<p>
</blockquote><blockquote><pre>   com.abc.TVPermission tvperm = new
        com.abc.TVPermission("channel-5", "watch");
   AccessController.checkPermission(tvperm);
</pre></blockquote><blockquote>
<a name="25739"><!-- --></a>
Note that, when adding a new permission, one should create a 	new (permission) class and not add a new method to the 	security manager. (In the past, in order to enable checking of a new type of access, you had to add a new method to the SecurityManager class.)<p>
<a name="23227"><!-- --></a>
If  more elaborate TVPermissions such as &#34;channel-1:13&#34; or &#34;channel-*&#34; are allowed, then it may be necessary to implement a TVPermissionCollection object that knows how to deal with the semantics of these pseudo names.<p>
<a name="24463"><!-- --></a>
New code should always invoke a permission check by calling the <code>checkPermission</code> method of the AccessController class in order to exercise the built-in access control algorithm. There is no essential need to examine whether there is a ClassLoader or a SecurityManager. On the other hand, if the algorithm should be left to the installed security manager class, then the method <code>SecurityManager.checkPermission</code> should be invoked instead.<p>
</blockquote>
<br>
<h3>
<a name="25999"><!-- --></a>
<i>	3.2	 </i> java.security.CodeSource
</h3>

<blockquote>
<a name="27604"><!-- --></a>
This class extends the concept of a codebase within HTML to encapsulate not only the code location (URL) but also the certificate(s) containing public keys that should be used to verify signed code originating from that location. Note that this is not the equivalent of the CodeBase tag in HTML files.  Each certificate is represented as a java.security.cert.Certificate, and each URL as a java.net.URL.<p>
</blockquote>
<br>
<h3>
<a name="20128"><!-- --></a>
<i>	3.3	 </i> java.security.Policy
</h3>

<blockquote>
<a name="23559"><!-- --></a>
The system security policy for a Java application environment, specifying which permissions are available for code from various sources, is represented by a Policy object. More specifically, it is represented by a Policy subclass providing an implementation of the abstract methods in the Policy class. <p>
<a name="23620"><!-- --></a>
In order for an applet (or an application running under a SecurityManager) to be allowed to perform secured actions, such as reading or writing a file, the applet (or application) must be granted permission for that particular action. The only exception is that code always automatically has permission to read files from its same CodeSource, and subdirectories of that CodeSource; it does not need explicit permission to do so.<p>
<a name="23520"><!-- --></a>
There could be multiple instances of the Policy object, although only one is &#34;in effect&#34; at any time.  The currently-installed Policy object can be obtained by calling the <code>getPolicy</code> method, and it can be changed by a call to the  <code>setPolicy</code> method (by code with permission to reset the Policy).<p>
<a name="23433"><!-- --></a>
The source location for the policy information utilized by the Policy object is up to the Policy implementation. The policy configuration may be stored, for example, as a flat ASCII file, as a serialized binary file of the Policy class, or as a database. There is a Policy reference implementation that obtains its information from static policy configuration files. <p>
</blockquote>
<br>
<a name="20131"><!-- --></a>
<h4><i>	3.3.1	  Policy File Format
</i></h4>

<blockquote>
<a name="23601"><!-- --></a>
In the Policy reference implementation, the policy can be specified within one 
or more policy configuration files. The configuration files indicate what 
permissions are allowed for code from specified code sources. Each configuration 
file must be encoded in UTF-8.<p>
<a name="24120"><!-- --></a>
A policy configuration file essentially contains a list of entries. It may contain a &#34;keystore&#34; entry, and contains zero or more &#34;grant&#34; entries.<p>
<a name="23697"><!-- --></a>
A keystore is a database of private keys and their associated digital certificates such as X.509 certificate chains authenticating the corresponding public keys. The keytool utility is used to create and administer keystores. The keystore specified in a policy configuration file is used to look up the public keys of the signers specified in the grant entries of the file. A keystore entry must appear in a policy configuration file if any grant entries specify signer aliases, or if any grant entries specify a principal alias (see below).<p>
<a name="23698"><!-- --></a>
At this time, there can be only one keystore entry in the policy file (others after the first one are ignored), and it can appear anywhere outside the file&#39;s grant entries . It has the following syntax:<p>
</blockquote><blockquote><pre>keystore "some_keystore_url", "keystore_type";
</pre></blockquote><blockquote>
<a name="23919"><!-- --></a>
Here, &#34;some_keystore_url&#34; specifies the URL location of the keystore, and &#34;keystore_type&#34; specifies the keystore type. The latter is optional. If not specified, the type is assumed to be that specified by the &#34;keystore.type&#34; property in the security properties file.<p>
<a name="27653"><!-- --></a>
The URL is relative to the policy file location. Thus if the policy file is specified in the security properties file as:<p>
</blockquote><blockquote><pre>policy.url.1=http://foo.bar.com/blah/some.policy
</pre></blockquote><blockquote>
<a name="23922"><!-- --></a>
and that policy file has an entry:<p>
</blockquote><blockquote><pre>keystore ".keystore";
</pre></blockquote><blockquote>
<a name="23924"><!-- --></a>
then the keystore will be loaded from:<p>
</blockquote><blockquote><pre>http://foo.bar.com/blah/.keystore
</pre></blockquote><blockquote>
<a name="23689"><!-- --></a>
The URL can also be absolute.<p>
<a name="27656"><!-- --></a>
A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. The default type supported by Sun Microsystems is a proprietary keystore type named "JKS". <p>
<a name="24132"><!-- --></a>
Each grant entry in a policy file essentially consists of a CodeSource and its permissions. Actually, a CodeSource consists of a URL and a set of certificates, while a policy file entry includes a URL and a list of signer names. The system creates the corresponding CodeSource after consulting the keystore to determine the certificate(s) of the specified signers.<p>
<a name="20263"><!-- --></a>
Each grant entry in the policy file is of the following format, where the leading &#34;grant&#34; is a reserved word that signifies the beginning of a new entry and optional items appear in brackets.  Within each entry, a leading &#34;permission&#34;  is another reserved word that marks the beginning of a new permission in the entry. Each grant entry grants a set of permissions to a specified code source and principals.<p>
</blockquote><blockquote>
<pre>
grant [SignedBy "signer_names"] [, CodeBase "URL"]
      [, Principal [principal_class_name] "principal_name"]
      [, Principal [principal_class_name] "principal_name"] ... {
    permission permission_class_name [ "target_name" ] 
               [, "action"] [, SignedBy "signer_names"];
    permission ...
};
</pre></blockquote><blockquote>
<a name="21173"><!-- --></a>
White spaces are allowed immediately before or after any comma.  The name of the permission class must be a fully qualified class name, such as java.io.FilePermission, and cannot be abbreviated (for example, to FilePermission).<p>
<a name="20259"><!-- --></a>
Note that the action field is optional in that it can be omitted if the permission class does not require it. If it is present, then it must come immediately after the target field.  <p>
<a name="29148"><!-- --></a>
The exact meaning of a CodeBase URL value depends on the characters at the end. A CodeBase with a trailing "/" matches all class files (not JAR files) in the specified directory. A CodeBase with a trailing "/*" matches all files (both class and JAR files) contained in that directory. A CodeBase with a trailing "/-" matches all files (both class and JAR files) in the directory and recursively all files in subdirectories contained in that directory.<p>
<a name="29146"><!-- --></a>
The CodeBase field (URL) is optional in that, if it is omitted, it signifies &#34;any code base&#34;.<p>
<a name="20250"><!-- --></a>
The first signer name field is a string alias that is mapped, via a separate mechanism, to a set of public keys (within certificates in the keystore) that are associated with the signers.  These keys are used to verify that certain signed classes are really signed by these signers.<p>
<a name="20298"><!-- --></a>
This signer field can be a comma-separated string containing names of multiple signers, an example of which is &#34;Adam,Eve,Charles&#34;, which means signed by Adam and Eve and Charles (i.e., the relationship is AND, not OR).<p>
<a name="20299"><!-- --></a>
This field is optional in that, if it is omitted, it signifies &#34;any signer&#34;, or in other words, &#34;It doesn&#39;t matter whether the code is signed or not&#34;.<p>
<a name="22285"><!-- --></a>
The second signer field, inside a Permission entry, represents the alias to the keystore entry containing the public key corresponding to the private key used to sign the bytecodes that implemented the said permission class. This permission entry is effective (i.e., access control permission will be granted based on this entry) only if the bytecode implementation is verified to be correctly signed by the said alias.<p>
<a name="principal description"><!-- --></a>
A principal value specifies a class_name/principal_name pair which
must be present within the executing threads principal set. The
principal set is associated with the executing code by way of a
Subject. The principal field is optional in that, if it is omitted,
it signifies "any principals".

<p><a name=keystoreAliasReplace><b>Note on KeyStore Alias Replacement: </b></a>
<p> If the principal class_name/principal_name pair is specified
as a single quoted string, it is treated as a keystore alias.
The keystore is consulted and queried (via the alias)
for an X509 Certificate.  If one is found,
the principal_class is automatically treated as
<code>javax.security.auth.x500.X500Principal</code>,
and the principal_name is automatically treated as the
subject distinguished name from the certificate.
If an X509 Certificate mapping is not found,
the entire grant entry is ignored.
<p>
<a name="21134"><!-- --></a>
The order between the CodeBase, SignedBy, and Principal fields
does not matter.<p>
<a name="21178"><!-- --></a>
An informal BNF grammer for the Policy file format is given below, where non-capitalized terms are terminals:<p>
</blockquote><blockquote><pre>PolicyFile -&gt; PolicyEntry | PolicyEntry; PolicyFile
PolicyEntry -&gt; grant {PermissionEntry}; |
           grant SignerEntry {PermissionEntry} |
           grant CodebaseEntry {PermissionEntry} |
           grant PrincipalEntry {PermissionEntry} |
           grant SignerEntry, CodebaseEntry {PermissionEntry} |
           grant CodebaseEntry, SignerEntry {PermissionEntry} |
           grant SignerEntry, PrincipalEntry {PermissionEntry} |
           grant PrincipalEntry, SignerEntry {PermissionEntry} |
           grant CodebaseEntry, PrincipalEntry {PermissionEntry} |
           grant PrincipalEntry, CodebaseEntry {PermissionEntry} |
           grant SignerEntry, CodebaseEntry, PrincipalEntry {PermissionEntry} |
           grant CodebaseEntry, SignerEntry, PrincipalEntry {PermissionEntry} |
           grant SignerEntry, PrincipalEntry, CodebaseEntry {PermissionEntry} |
           grant CodebaseEntry, PrincipalEntry, SignerEntry {PermissionEntry} |
           grant PrincipalEntry, CodebaseEntry, SignerEntry {PermissionEntry} |
           grant PrincipalEntry, SignerEntry, CodebaseEntry {PermissionEntry} |
           keystore "url"
SignerEntry -&gt; signedby (a comma-separated list of strings)
CodebaseEntry -&gt; codebase (a string representation of a URL)
PrincipalEntry -&gt; OnePrincipal | OnePrincipal, PrincipalEntry
OnePrincipal -&gt; principal [ principal_class_name ] "principal_name" (a principal)
PermissionEntry -&gt; OnePermission | OnePermission PermissionEntry
OnePermission -&gt; permission permission_class_name
                 [ "target_name" ] [, "action_list"]
                 [, SignerEntry];

</pre></blockquote><blockquote>
<a name="25673"><!-- --></a>
Now we give some examples.  The following policy grants permission a.b.Foo to code signed by Roland:<p>
</blockquote><blockquote><pre>grant signedBy "Roland" {
    permission a.b.Foo;
};
</pre></blockquote><blockquote>
<a name="21211"><!-- --></a>
The following grants a FilePermission to all code (regardless of the signer and/or codeBase):<p>
</blockquote><blockquote><pre>grant {
   permission java.io.FilePermission ".tmp", "read";
};
</pre></blockquote><blockquote>
<a name="21218"><!-- --></a>
The following grants two permissions to code that is signed by both Li and Roland:<p>
</blockquote><blockquote><pre>grant signedBy "Roland,Li" {
  permission java.io.FilePermission "/tmp/*", "read";
  permission java.util.PropertyPermission "user.*";
};
</pre></blockquote><blockquote>
<a name="21226"><!-- --></a>
The following grants two permissions to code that is signed by Li and that comes from http://java.sun.com:<p>
</blockquote><blockquote><pre>grant codeBase "http://java.sun.com/*", signedBy "Li" {
    permission java.io.FilePermission "/tmp/*", "read";
    permission java.io.SocketPermission "*", "connect";
};
</pre></blockquote><blockquote>
<a name="22293"><!-- --></a>
The following grants two permissions to code that is signed by both Li and Roland, and only if the bytecodes implementing com.abc.TVPermission are genuinely signed by Li.<p>
</blockquote><blockquote><pre>grant signedBy "Roland,Li" {
  permission java.io.FilePermission "/tmp/*", "read";
  permission com.abc.TVPermission "channel-5", "watch", 
     signedBy "Li";
};
</pre></blockquote><blockquote>
<a name="22296"><!-- --></a>
The reason for including the second signer field is to prevent spoofing when a permission class does not reside with the Java runtime installation.  For example, a copy of the com.abc.TVPermission class can be downloaded as part of a remote JAR archive, and the user policy might include an entry that refers to it. Because the archive is not long-lived, the second time the com.abc.TVPermission class is downloaded, posssibly from a different web site, it is crucial that the second copy is authentic, as the presence of the permission entry in the user policy might reflect the user&#39;s confidence or belief in the first copy of the class bytecode.<p>
<a name="22304"><!-- --></a>
The reason we chose to use digital signatures to ensure authenticity, rather than storing (a hash value of) the first copy of the bytecodes and using it to compare with the second copy, is because the author of the permission class can legitimately update the class file to reflect a new design or implementation.<p>
<a name="25676"><!-- --></a>
Please note: The strings for a file path must be specified in a platform-dependent format; this is necessary until there is a universal file description language. The above examples have shown strings appropriate on Solaris systems. On Windows systems, when you directly specify a file path in a string, you need to include two backslashes for each actual single backslash in the path, as in<p>
</blockquote><blockquote><pre>grant signedBy "Roland" {
  permission java.io.FilePermission "C:\\users\\Cathy\\*", "read";
};
</pre></blockquote><blockquote>
<a name="25679"><!-- --></a>
This is because the strings are processed by a tokenizer (java.io.StreamTokenizer), which allows &#34;\&#34; to be used as an escape string (e.g., &#34;\n&#34; to indicate a new line) and which thus requires two backslashes to indicate a single backslash. After the tokenizer has processed the above FilePermission target string, converting double backslashes to single backslashes, the end result is the actual path<p>
</blockquote><blockquote><pre>"C:\users\Cathy\*"
</pre></blockquote>

<a name="principal grant example"><!-- --></a>
<blockquote>
Finally, here are some principal-based grant entries: <p>
<pre>
grant principal javax.security.auth.x500.X500Principal "cn=Alice" {
  permission java.io.FilePermission "/home/Alice", "read, write";
};
</pre>
This permits any code executing as the X500Principal, "cn=Alice",
permission to read and write to "/home/Alice".

<p>The following example shows a grant statement with both
codesource and principal information.
<pre>
  grant codebase "http://www.games.com",
        signedBy "Duke",
        principal javax.security.auth.x500.X500Principal "cn=Alice" {
    permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
This allows code downloaded from "www.games.com", signed by "Duke",
and executed by "cn=Alice", permission to read and write into
the "/tmp/games" directory.

<p>The following example shows a grant statement with
KeyStore alias replacement:
<pre>
  keystore "http://foo.bar.com/blah/.keystore";

  grant principal "alice" {
    permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
"alice" will be replaced by
<blockquote>
javax.security.auth.x500.X500Principal "cn=Alice"
</blockquote>
assuming the X.509 certificate associated with the keystore alias,
<i>alice</i>, has a subject distinguished name of "cn=Alice".
This allows code executed by the X500Principal "cn=Alice"
permission to read and write into the "/tmp/games" directory.

</blockquote>

<br>
<a name="25970"><!-- --></a>
<h4><i>	3.3.2	  Property Expansion in Policy Files
</i></h4>

<blockquote>
<a name="25971"><!-- --></a>
Property expansion is possible in policy files and in the security properties file.  <p>
<a name="24003"><!-- --></a>
Property expansion is similar to expanding variables in a shell. That is, when a string like<p>
<a name="23943"><!-- --></a>
"${some.property}"<p>
<a name="23944"><!-- --></a>
appears in a policy file, or in the security properties file, it will be expanded to the value of the specified system property. For example,<p>
</blockquote><blockquote><pre>permission java.io.FilePermission "${user.home}", "read";
</pre></blockquote><blockquote>
<a name="23948"><!-- --></a>
will expand &#34;${user.home}&#34; to use the value of the &#34;user.home&#34; system property. If that property&#39;s value is &#34;/home/cathy&#34;, then the above is equivalent to<p>
</blockquote><blockquote><pre>permission java.io.FilePermission "/home/cathy", "read";
</pre></blockquote><blockquote>
<a name="24022"><!-- --></a>
In order to assist in platform-independent policy files, you can also use the special notation of "${/}", which is a shortcut for "${file.separator}". This allows permission designations such as <p>
</blockquote><blockquote><pre>permission java.io.FilePermission "${user.home}${/}*", "read";
</pre></blockquote><blockquote>
<a name="23952"><!-- --></a>
If user.home is /home/cathy, and you are on Solaris, the above gets converted to:<p>
</blockquote><blockquote><pre>permission java.io.FilePermission "/home/cathy/*", "read";
</pre></blockquote><blockquote>
<a name="23955"><!-- --></a>
If on the other hand user.home is C:\users\cathy and you are on a Windows system, the above gets converted to:<p>
</blockquote><blockquote><pre>permission java.io.FilePermission "C:\users\cathy\*", "read";
</pre></blockquote><blockquote>
<a name="23958"><!-- --></a>
Also, as a special case, if you expand a property in a codebase, such as<p>
</blockquote><blockquote><pre>grant codeBase "file:/${java.home}/lib/ext/"
</pre></blockquote><blockquote>
<a name="23962"><!-- --></a>
then any file.separator characters will be automatically converted to /'s, which is desirable since codebases are URLs. Thus on a Windows system, even if java.home is set to C:\j2sdk1.2, the above would get converted to<p>
</blockquote><blockquote><pre>grant codeBase "file:/C:/j2sdk1.2/lib/ext/"
</pre></blockquote><blockquote>
<a name="23965"><!-- --></a>
Thus you don't need to use ${/} in codebase strings (and you shouldn't).<p>
<a name="23967"><!-- --></a>
Property expansion takes place anywhere a double quoted string is allowed in the policy file. This includes the signedby, codebase, target names, and actions fields.<p>
<a name="25580"><!-- --></a>
Whether or not property expansion is allowed is controlled by the value of the  &#34;policy.expandProperties&#34; property in the security properties file. If the value of this property is true (the default), expansion is allowed.<p>
<a name="25584"><!-- --></a>
Please note: You can&#39;t use nested properties; they will not work. For example, <p>
</blockquote><blockquote><pre>"${user.${foo}}"
</pre></blockquote><blockquote>
<a name="25601"><!-- --></a>
doesn&#39;t work, even if the &#34;foo&#34; property is set to &#34;home&#34;. The reason is the property parser doesn&#39;t recognize nested properties; it simply looks for the first &#34;${&#34;, and then keeps looking until it finds the first &#34;}&#34; and tries to interpret the result &#34;${user.$foo}&#34; as a property, but fails if there is no such property.<p>
<a name="25616"><!-- --></a>
Also note: If a property can't be expanded in a grant entry, permission entry, or keystore entry, that entry is ignored. For example, if the system property "foo" is not defined and you have:<p>
</blockquote><blockquote><pre>grant codeBase "${foo}" {
  permission ...;
  permission ...;
};
</pre></blockquote><blockquote>
<a name="25624"><!-- --></a>
then all the permissions in this grant entry are ignored. If you have<p>
</blockquote><blockquote><pre>grant {
  permission Foo "${foo}";
  permission Bar;
};
</pre></blockquote><blockquote>
<a name="25629"><!-- --></a>
then only the &#34;permission Foo...&#34; entry is ignored. And finally, if you have<p>
</blockquote><blockquote><pre>keystore "${foo}";
</pre></blockquote><blockquote>
<a name="25632"><!-- --></a>
then the keystore entry is ignored.<p>
<a name="25478"><!-- --></a>
One final note: On Windows systems, when you directly specify a file path in a string, you need to include two backslashes for each actual single backslash in the path, as in<p>
</blockquote><blockquote><pre>"C:\\users\\cathy\\foo.bat"
</pre></blockquote><blockquote>
<a name="25480"><!-- --></a>
This is because the strings are processed by a tokenizer (java.io.StreamTokenizer), which allows &#34;\&#34; to be used as an escape string (e.g., &#34;\n&#34; to indicate a new line) and which thus requires two backslashes to indicate a single backslash. After the tokenizer has processed the above string, converting double backslashes to single backslashes, the end result is <p>
</blockquote><blockquote><pre>"C:\users\cathy\foo.bat"
</pre></blockquote><blockquote>
<a name="25529"><!-- --></a>
Expansion of a property in a string takes place <em>after</em> the tokenizer has processed the string. Thus if you have the string<p>
</blockquote><blockquote><pre>"${user.home}\\foo.bat"
</pre></blockquote><blockquote>
<a name="25503"><!-- --></a>
then first the tokenizer processes the string, converting the double backslashes to a single backslash, and the result is<p>
</blockquote><blockquote><pre>"${user.home}\foo.bat"
</pre></blockquote><blockquote>
<a name="25541"><!-- --></a>
Then the ${user.home} property is expanded and the end result is<p>
</blockquote><blockquote><pre>"C:\users\cathy\foo.bat"
</pre></blockquote><blockquote>
<a name="25511"><!-- --></a>
assuming the user.home value is &#34;C:\users\cathy&#34;. Of course, for platform independence, it would be better if the string was initially specified without any explicit slashes, i.e., using the ${/} property instead, as in<p>
</blockquote><blockquote><pre>"${user.home}${/}foo.bat"
</pre></blockquote>
<br>
<a name="20264"><!-- --></a>

<h4><i>	3.3.3	  General Expansion in Policy Files
</i></h4>

<blockquote>
<a name="20265"><!-- --></a>
Generalized forms of expansion are also supported in policy files.
For example, permission names may contain a string of the form:
<blockquote>
    ${{protocol:protocol_data}}
</blockquote>
If such a string occurs in a permission name,
then the value in <i>protocol</i> determines the exact type
of expansion that should occur, and <i>protocol_data</i> is used
to help perform the expansion.  <i>protocol_data</i> may be empty,
in which case the above string should simply take the form:
<blockquote>
    ${{protocol}}
</blockquote>
<p>
There are two protocols supported in the default
policy file implementation:
<ol>
<li>${{self}}
	<blockquote>
	<p> The protocol, <b>self</b>, denotes a replacement
	of the entire string, ${{self}}, with one or more
	principal class/name pairs.  The exact replacement
	performed depends upon the contents of the
	grant clause to which the permission belongs.

	<p> If the grant clause does not contain any principal information,
	the permission will be ignored (permissions containing
	${{self}} in their target names are only valid in the context
	of a principal-based grant clause).  For example, BarPermission
	will always be ignored in the following grant clause:

	<pre>
	    grant codebase "www.foo.com", signedby "duke" {
                permission BarPermission "... ${{self}} ...";
            };
        </pre>

	If the grant clause contains principal information, ${{self}}
	will be replaced with that same principal information.
	For example, ${{self}} in BarPermission will be replaced by
	<b>javax.security.auth.x500.X500Principal "cn=Duke"</b>
	in the following grant clause:

	<pre>
	    grant principal javax.security.auth.x500.X500Principal "cn=Duke" {
                permission BarPermission "... ${{self}} ...";
            };
	</pre>

	If there is a comma-separated list of principals in the grant
	clause, then ${{self}} will be replaced by the same
	comma-separated list or principals.
	In the case where both the principal class and name are
	wildcarded in the grant clause, ${{self}} is replaced
	with all the principals associated with the <code>Subject</code>
	in the current <code>AccessControlContext</code>.

	<p> The following example describes a scenario involving both
	<b>self</b> and
	<a href=#keystoreAliasReplace>KeyStore alias replacement</a>
	together:
	<pre>
            keystore "http://foo.bar.com/blah/.keystore";

            grant principal "duke" {
                permission BarPermission "... ${{self}} ...";
            };
	</pre>

	In the above example, "duke" will first be expanded into
	<blockquote>
	<b>javax.security.auth.x500.X500Principal "cn=Duke"</b>
	</blockquote>
	assuming the X.509 certificate associated with the
	KeyStore alias, "duke", has a subject distinguished name
	of "cn=Duke".  Next, ${{self}} will be
	replaced with the same principal information that just
	got expanded in the grant clause:
	<blockquote>
	<b>javax.security.auth.x500.X500Principal "cn=Duke"</b>.
	</blockquote>

	</blockquote>

<li>${{alias:<i>alias_name</i>}}
	<blockquote>
	<p> The protocol, <b>alias</b>, denotes a
	</code>java.security.KeyStore</code> alias substitution.
	The <code>KeyStore</code> used is the one specified
	in the <a href=#20131>KeyStore entry</a>.
	<i>alias_name</i> represents an alias into the <code>KeyStore</code>.
	${{alias:<i>alias_name</i>}} is replaced with
	<b>javax.security.auth.x500.X500Principal "DN"</b>,
	where <i>DN</i> represents the subject distinguished name
	of the certificate belonging to <i>alias_name</i>.
	For example:

	<pre>
            keystore "http://foo.bar.com/blah/.keystore";

            grant codebase "www.foo.com" {
                permission BarPermission "... ${{alias:duke}} ...";
            };
	</pre>

	In the above example the X.509 certificate associated with the alias,
	<i>duke</i>, is retrieved from the <code>KeyStore</code>,
	<i>foo.bar.com/blah/.keystore</i>.  Assuming duke's certificate
	specifies "o=dukeOrg, cn=duke" as the subject distinguished name,
	then ${{alias:duke}} is replaced with
	<b>javax.security.auth.x500.X500Principal "o=dukeOrg, cn=duke"</b>.

	<p> The permission entry is ignored under the following
	error conditions:
	<ul>
	<li> The keystore entry is unspecified
	<li> The <i>alias_name</i> is not provided
	<li> The certificate for <i>alias_name</i> can not be retrieved
	<li> The certificate retrieved is not an X.509 certificate
	</ul>
	</blockquote>
</ol>
</blockquote>

<h4><i>	3.3.4	  Assigning Permissions
</i></h4>

<blockquote>
<a name="20233"><!-- --></a>
When a principal executes a class that originated from a particular CodeSource, the security mechanism consults the policy object to determine what permissions to grant. This is done by invoking the <code>getPermissions</code> or
<code>implies</code> method on the Policy object that is installed in the VM.<p>
<a name="20161"><!-- --></a>
Clearly, a given code source in a ProtectionDomain can match the code source given in multiple entries in the policy, for example because the wildcard &#34;*&#34; is allowed.<p>
<a name="20162"><!-- --></a>
The following algorithm is used to locate the appropriate set of permissions in the policy.<p>
</blockquote><blockquote><pre>1. match the public keys, if code is signed.
2. if a key is not recognized in the policy, ignore the key
   if every key is ignored, treat the code as unsigned.
3. if the keys are matched, or no signer was specified {
       try to match all URLs in the policy for the keys
   }
4. if the keys are matched (or no signer was specified),
   and the URLs are matched (or no codebase was specified) {
       try to match all principals in the policy with
       the principals associated with the current executing thread.
5. if either key, URL, or principals are not matched, use built-in default
       permission, which is the original sandbox permission.
</pre></blockquote><blockquote>
<a name="29102"><!-- --></a>
The exact meaning of a policy entry codeBase URL value depends on the characters at the end. A codeBase with a trailing "/" matches all class files (not JAR files) in the specified directory. A codeBase with a trailing "/*" matches all files (both class and JAR files) contained in that directory. A codeBase with a trailing "/-" matches all files (both class and JAR files) in the directory and recursively all files in subdirectories contained in that directory.<p>
<a name="29117"><!-- --></a>
As an example, given &#34;http://java.sun.com/-&#34; in the policy, then any code base that is on this web site matches the policy entry.  Matching code bases include &#34;http://java.sun.com/j2se/sdk/&#34; and &#34;http://java.sun.com/people/gong/appl.jar&#34;.<p>
<a name="20772"><!-- --></a>
If multiple entries are matched, then all the permissions given in those entries are granted.  In other words, permission assignment is additive.  For example, if code signed with key A gets permission X and code signed by key B gets permission Y and no particular codebase is specified, then code signed by both A and B gets permissions X and Y. Similarly, if code with codeBase &#34;http://java.sun.com/-&#34; is given permission X, and &#34;http://java.sun.com/people/*&#34; is given permission Y, and no particular signers are specified, then an applet from &#34;http://java.sun.com/people/applet.jar&#34; gets both X and Y.<p>
<a name="20770"><!-- --></a>
Note that URL matching here is purely syntactic.  For example, a policy can give an entry that specifies a URL &#34;ftp://ftp.sun.com&#34;.  Such an  entry is useful only when one can obtain Java code directly from ftp for execution.<p>
<a name="23755"><!-- --></a>
To specify URLs for the local file system, a file URL can be used.  For example, to specify files in the /home/cathy/temp directory in a Solaris system, you'd use<p>
</blockquote><blockquote><pre>"file:/home/cathy/temp/*"
</pre></blockquote><blockquote>
<a name="23757"><!-- --></a>
To specify files in the "temp" directory on the C drive in a Windows system, use<p>
</blockquote><blockquote><pre>"file:/c:/temp/*"
</pre></blockquote><blockquote>
<a name="23759"><!-- --></a>
Note: code base URLs always use slashes (no backlashes), regardless of the platform they apply to.<p>
<a name="23753"><!-- --></a>
You can also use an absolute path name such as<p>
</blockquote><blockquote><pre>"/home/gong/bin/MyWonderfulJava"
</pre></blockquote>
<br>
<a name="23883"><!-- --></a>
<h4><i>	3.3.5	  Default System and User Policy Files 
</i></h4>

<blockquote>
<a name="27128"><!-- --></a>
In the Policy reference implementation, the policy can be specified within one or more policy configuration files. The configuration files specify what permissions are allowed for code from specified code sources.<p>
<a name="27131"><!-- --></a>
A policy file can be composed via a simple text editor, or via a graphical PolicyTool utility that is described later.<p>
<a name="27133"><!-- --></a>
There is by default a single system-wide policy file, and a single user policy file.<p>
<a name="27135"><!-- --></a>
The system policy file is by default located at <p>
</blockquote><blockquote><pre>{java.home}/lib/security/java.policy  (Solaris)
{java.home}\lib\security\java.policy  (Windows)
</pre></blockquote><blockquote>
<a name="27138"><!-- --></a>
Here, <em>java.home</em> is a system property specifying the directory into which the Java 2 SDK was installed.<p>
<a name="27140"><!-- --></a>
The user policy file is by default located at <p>
</blockquote><blockquote><pre>{user.home}/.java.policy  (Solaris)
{user.home}\.java.policy  (Windows)
</pre></blockquote><blockquote>
<a name="27143"><!-- --></a>
Here, <em>user.home</em> is a system property specifying the user's home directory.<p>
<a name="27144"><!-- --></a>
When the Policy is initialized, the system policy is loaded in first, and then the user policy is added to it. If neither policy is present, a built-in policy is used.  This built-in policy is the same as the original sandbox policy.<p>
<a name="27148"><!-- --></a>
Policy file locations are specified in the security properties file, which is located at<p>
</blockquote><blockquote><pre>{java.home}/lib/security/java.security  (Solaris)
{java.home}\lib/security\java.security  (Windows)
</pre></blockquote><blockquote>
<a name="27152"><!-- --></a>
The policy file locations are specified as the values of properties whose names are of the form<p>
</blockquote><blockquote><pre>policy.url.<em>n
</em></pre></blockquote><blockquote>
<a name="27155"><!-- --></a>
Here, <em>n</em> is a number. You specify each such property value in a line of the following form:<p>
</blockquote><blockquote><pre>policy.url.n=<em>URL
</em></pre></blockquote><blockquote>
<a name="28997"><!-- --></a>
Here, <em>URL</em> is a URL specification. For example, the default system and user policy files are defined in the security properties file as<p>
</blockquote><blockquote><pre>policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy
</pre></blockquote><blockquote>
<a name="27159"><!-- --></a>
You can actually specify a number of URLs, including ones of the form "http://", and all the designated policy files will get loaded. You can also comment out or change the second one to disable reading the default user policy file.<p>
<a name="27163"><!-- --></a>
The algorithm starts at policy.url.1, and keeps incrementing until it does not find a URL. Thus if you have policy.url.1 and policy.url.3, policy.url.3 will never be read.<p>
<a name="27166"><!-- --></a>
It is also possible to specify an additional or a different policy file when invoking execution of an application. This can be done via the "-Djava.security.policy" command-line argument, which sets the value of the <em>java.security.policy</em> property. For example, if you use<p>
</blockquote><blockquote><pre>java -Djava.security.manager -Djava.security.policy=<em>pURL</em> SomeApp
</pre></blockquote><blockquote>
<a name="27170"><!-- --></a>
Here, <em>pURL</em> is a URL specifying the location of a policy file, then the specified policy file will be loaded in addition to all the policy files that are specified in the security properties file. (The &#34;-Djava.security.manager&#34; argument ensures that the default security manager is installed, and thus the application is subject to policy checks, as described in "Security Management for Applets and Applications". It is not required if the application <em>SomeApp</em> installs a security manager.)<p>
<a name="29013"><!-- --></a>
If you use the following, with a double equals, then just the specified policy file will be used; all others will be ignored.<p>
</blockquote><blockquote><pre>java -Djava.security.manager -Djava.security.policy==<em>pURL</em> SomeApp
</pre></blockquote><blockquote>
<a name="27430"><!-- --></a>
If you want to pass a policy file to the appletviewer, again use a &#34;-Djava.security.policy&#34; argument as follows:<p>
</blockquote><blockquote><pre>appletviewer -J-Djava.security.policy=pURL  myApplet
</pre></blockquote><blockquote>
<a name="27509"><!-- --></a>
Please note: The &#34;-Djava.security.policy&#34; policy file value will be ignored (for both java and appletviewer commands) if the "policy.allowSystemProperty" property in the security properties file is set to false. The default is true.<p>
</blockquote>
<br>
<a name="27428"><!-- --></a>
<h4><i>	3.3.6	  Customizing Policy Evaluation
</i></h4>

<blockquote>
<a name="20394"><!-- --></a>
The current design of the Policy class is not as comprehensive as it could be. We have given the issues much thought and are progressing cautiously, partly to ensure that we define method calls that are appropriate for the most common cases.  <em>For the meantime</em>, an alternative policy class can be given to replace the default policy class, as long as the former is a subclass of the abstract Policy class and implements the <code>getPermissions</code> method (and other methods as necessary).<p>
<a name="23576"><!-- --></a>
The Policy reference implementation can be changed by resetting the value of the &#34;policy.provider&#34; security property (in the security properties file) to the fully qualified name of the desired Policy implementation class. The  security properties file is located in the file named<p>
</blockquote><blockquote><pre>{java.home}/lib/security/java.security (Solaris)
{java.home}\lib\security\java.security (Windows)
</pre></blockquote><blockquote>
<a name="24098"><!-- --></a>
Here, {java.home} refers to the directory where the runtime environment is 
installed -- either the <tt>jre</tt> directory inside the Java 2 SDK, or the 
top-level directory of the Java 2 Runtime Environment.<p>
<a name="21107"><!-- --></a>
The property policy.provider specifies the name of the policy class, and the default is the following:<p>
</blockquote><blockquote><pre>policy.provider=sun.security.provider.PolicyFile
</pre></blockquote><blockquote>
<a name="21109"><!-- --></a>
To customize, you can change the property value to specify another class, as in<p>
</blockquote><blockquote><pre>policy.provider=com.mycom.MyPolicy
</pre></blockquote><blockquote>
<a name="21112"><!-- --></a>
Note that the MyPolicy class must be a subclass of java.security.Policy. It is perhaps worth emphasizing that such an override of the policy class is a temporary solution and a more comprehensive policy API will probably make this unnecessary.<p>
</blockquote>
<br>
<h3>
<a name="28292"><!-- --></a>
<i>	3.4	 </i> java.security.GeneralSecurityException
</h3>

<blockquote>
<a name="28293"><!-- --></a>
This is a new exception class that is a subclass of java.lang.Exception.  The intention is that there should be two types of exceptions associated with security and the security packages.<p>
</blockquote>
<blockquote>
<ul><li>
<a name="28294"><!-- --></a>
java.lang.SecurityException and its subclasses should be runtime exceptions (unchecked, not declared) that are likely to cause the execution of a program to stop.
</li>
</ul>
</blockquote>
<blockquote>
<a name="28295"><!-- --></a>
Such an exception is thrown only when some sort of security violation is detected.  For example, such an exception is thrown when some code attempts to access a file, but it does not have permission for the access.  Application developers may catch these exceptions, if they want.<p>
</blockquote>
<blockquote>
<ul><li>
<a name="28296"><!-- --></a>
java.security.GeneralSecurityException, which is a subclass of java.lang.Exception (must be declared or caught) that is thrown in all other cases from within the security packages.
</li>
</ul>
</blockquote>
<blockquote>
<a name="28297"><!-- --></a>
Such an exception is security related but non-vital.  For example, passing in an invalid key is probably not a security violation and should be caught and dealt with by a developer.<p>
<a name="28298"><!-- --></a>
There are currently still two exceptions within the java.security package that are subclasses from RuntimeException.  We at this moment cannot change these due to backward compatibility requirements.  We will revisit this issue in the future.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href=security-specTOC.fm.html>CONTENTS</a> | <a href="security-spec.doc2.html">PREV</a>
 | <a href="security-spec.doc4.html">NEXT</a> <!-- | <a href="security-spec.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
<font size="-1"><i><A HREF="../../../relnotes/SMICopyright.html">Copyright</a> &#169 1997-2002 Sun Microsystems, Inc. All Rights Reserved.</i></font>





</body>
</html>
