<HTML>
<HEAD>
   <META NAME="Author" CONTENT="Zhenghua Li">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.02 [en] (X11; U; SunOS 5.6 sun4u) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#990066" ALINK="#FF0000">

<H1>
<B>JAR File Specification</B></H1>

<H2>
<B>Contents</B></H2>

<UL>
<LI>
<A HREF="#Intro">Introduction</A></LI>

<LI>
<A HREF="#The META-INF directory">The META-INF&nbsp;directory</A></LI>

<LI>
<A HREF="#Name-Value pairs and Sections">Name-Value pairs and Sections</A></LI>

<LI>
<A HREF="#JAR Manifest">JAR Manifest</A></LI>

<UL>
<LI>
<A HREF="#Manifest-Overview">Overview</A></LI>

<LI>
<A HREF="#Manifest Specification">Manifest Specification</A></LI>

<LI>
<A HREF="#Main Attributes">Main Attributes</A></LI>

<LI>
<A HREF="#Per-Entry Attributes">Per-Entry Attributes</A></LI>
</UL>

<LI>
<A HREF="#Signed JAR File">Signed JAR file</A></LI>

<UL>
<LI>
<A HREF="#SignedJar-Overview">Overview</A></LI>

<LI>
<A HREF="#Signature File">Signature File</A></LI>

<UL>
<LI>
<A HREF="#Signature Validation">Signature validation</A></LI>

<LI>
<A HREF="#The Magic Attribute">The Magic Attribute</A></LI>
</UL>

<LI>
<A HREF="#Digital Signatures">Digital Signatures</A></LI>
</UL>

<LI>
<A HREF="#Notes on Manifest and Signature Files">Notes on Manifest and
Signature Files</A></LI>

<LI>
<A HREF="#JAR Index">JAR Index</A></LI>

<UL>
<LI>
<A HREF="#Overview">Overview</A></LI>

<LI>
<A HREF="#Index File Specification">Index File Specification</A></LI>

<LI>
<A HREF="#Backward Compatibility">Backward Compatibility</A></LI>
</UL>

<LI>
<A HREF="#Service Provider">Service Provider</A></LI>

<UL>
<LI>
<A HREF="#Overview">Overview</A></LI>

<LI>
<A HREF="#Provider Configuration File">Provider Configuration File</A></LI>

<LI>
<A HREF="#Example">Example</A></LI>
</UL>

<LI>
<A HREF="#API Details">API&nbsp;Details</A></LI>

<LI>
<A HREF="#See Also">See Also</A></LI>
</UL>

<H2>
<A NAME="Intro"></A><B>Introduction</B></H2>
JAR file is a file format based on the popular ZIP file format and is used
for aggregating many files into one. A&nbsp; JAR file is essentially a
zip file that contains an optional META-INF directory. A JAR file can be
created by the command-line <A HREF="../../tooldocs/windows/jar.html">jar</A>
tool, or by using the&nbsp; <TT><A HREF="../../api/java/util/jar/package-summary.html">java.util.jar</A></TT>
API in the Java platform. There is no restriction on the name of a
JAR file, it can be any legal file name on a particular platform.

<P>In many cases, JAR files are not just simple archives of java classes
files and/or resources. They are used as building blocks for applications
and extensions. The META-INF directory, if it exists, is used to store
package and extension configuration data, including security, versioning,
extension and services.
<H2>
<A NAME="The META-INF directory"></A>The META-INF directory</H2>
The following files/directories in the META-INF directory are recognized
and interpreted by the Java 2 Platform to configure applications,
extensions, class loaders and services:
<UL>
<LI>
<TT>MANIFEST.MF</TT></LI>
</UL>
The manifest file that is used to define extension and package related
data.
<UL>
<LI>
<TT>INDEX.LIST</TT></LI>
</UL>
This file is generated by the new "<TT>-i"</TT> option of the jar tool,
which contains location information for packages defined in an application
or extension.&nbsp; It is part of the JarIndex implementation and used
by class loaders to speed up their class loading process.
<UL>
<LI>
<TT>x.SF</TT></LI>
</UL>
The signature file for the JAR file.&nbsp; 'x' stands for the base file
name.
<UL>
<LI>
<TT>x.DSA</TT></LI>
</UL>
The signature block file associated with the signature file with the same
base file name. This file stores the digital signature of the corresponding
signature file.
<UL>
<LI>
<TT>services/</TT></LI>
</UL>
This directory stores all the service provider configuration files.
<H1>
<A NAME="Name-Value pairs and Sections"></A>Name-Value pairs and Sections</H1>
Before we go to the details of the contents of the individual configuration
files, some format convention needs to be defined. In most cases, information
contained within the manifest file and signature files is represented as
so-called "name: value" pairs inspired by the RFC822 standard.&nbsp; We
also call these pairs headers or attributes.

<P>Groups of name-value pairs are known as a "section". Sections are separated
from other sections by empty lines.

<P>Binary data of any form is represented as base64. Continuations are
required for binary data which causes line length to exceed 72 bytes. Examples
of binary data are digests and signatures.

<P>Implementations shall support header values of up to 65535 bytes.

<P>All the specifications in this document use the same grammar in which
terminal symbols are shown in fixed width font and non-terminal symbols
are shown in italic type face.
<H3>
<A NAME="Section-Specification"></A>Specification:</H3>
&nbsp; <I>section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*header +newline</I>
<BR><I>&nbsp; nonempty-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +header +newline</I>
<BR><I>&nbsp; newline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I><TT>CR LF | LF | CR</TT> (<I>not followed by </I><TT>LF</TT>)
<BR>&nbsp; <I>header:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name </I><TT>:</TT><I> value</I>
<BR><I>&nbsp; name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum *headerchar</I>
<BR><I>&nbsp; value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I>SPACE *<I>otherchar newline *continuation</I>
<BR>&nbsp; <I>continuation:</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SPACE <I>*otherchar newline</I>
<BR>&nbsp; <I>alphanum</I>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<TT>A-Z</TT>} | {<TT>a-z</TT>} | {<TT>0-9</TT>}
<BR>&nbsp; <I>headerchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum</I> | <TT>-</TT> | <TT>_</TT>
<BR>&nbsp; <I>otherchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any UTF-8 character except </I><TT>NUL, CR </TT><I>and</I> <TT>LF</TT>

<P><I>; Also: To prevent mangling of files sent via straight e-mail, no</I>
<BR><I>; header will start with the four letters "From".</I>
<BR>&nbsp;

<P>Non-terminal symbols defined in the above specification will be referenced
in the following specifications.
<H1>
<A NAME="JAR Manifest"></A>JAR Manifest</H1>

<H3>
<A NAME="Manifest-Overview"></A>Overview</H3>
A JAR file manifest consists of a main section followed by a list of sections
for individual JAR file entries, each separated by a newline. Both the
main section and individual sections follow the section syntax specified
above. They each have their own specific restrictions and rules.

<P>The main section contains security and configuration information about
the JAR file itself, as well as the application or extension that this
JAR file is a part of. It also defines main attributes that apply to every
individual manifest entry.&nbsp; No attribute in this section can have
its name equal to&nbsp; "<TT>Name</TT>". This section is terminated by
an empty line.

<P>The individual sections define various attributes for packages or files
contained in this JAR file. Not all files in the JAR file need to be listed
in the manifest as entries, but all files which are to be signed must be
listed. The manifest file itself must not be listed.&nbsp; Each section
must start with an attribute with the name as "<TT>Name</TT>", and the
value must be a relative path to the file, or an absolute URL referencing
data outside the archive.

<P>If there are multiple individual sections for the same file entry, the
attributes in these sections are merged. If a certain attribute have different
values in different sections, the last one is recognized.

<P>Attributes which are not understood are ignored. Such attributes may
include implementation specific information used by applications.
<H3>
<A NAME="Manifest Specification"></A>Manifest Specification:</H3>
&nbsp; <I>manifest-file:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
main-section newline *individual-section</I>
<BR><I>&nbsp; main-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info newline *main-attribute</I>
<BR><I>&nbsp; version-info:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I><TT>Manifest-Version : </TT><I>version-number</I>
<BR>&nbsp; <I>version-number :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{</I><TT>.</TT><I>digit+}*</I>
<BR>&nbsp; <I>main-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate main attribute) newline</I>
<BR><I>&nbsp; individual-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I><TT>Name : </TT><I>value</I> <I>newline *perentry-attribute</I>
<BR><I>&nbsp; perentry-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate perentry attribute) newline</I>
<BR><I>&nbsp; newline :&nbsp;</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>CR LF | LF | CR</TT> (<I>not followed by</I> <TT>LF</TT>)
<BR>&nbsp;&nbsp; <I>digit:</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>{0-9}&nbsp;</TT>

<P>In the above specification, attributes that can appear in the main section
are referred to as main attributes, whereas attributes that can appear
in individual sections are referred to as per-entry attributes. Certain
attributes can appear both in the main section and the individual sections,
in which case the per-entry attribute value overrides the main attribute
value for the specified entry. The two types of attributes are defined
as follows.
<BR>&nbsp;
<H3>
<A NAME="Main Attributes"></A>Main Attributes</H3>
Main attributes are the attributes that are present in the main section
of the manifest. They fall into the following different groups:
<UL>
<LI>
general main attributes</LI>
</UL>

<UL>
<UL>
<LI>
Manifest-Version:</LI>
</UL>

<UL>Defines the manifest file version. The value is a legitimate version
number, as described in the above spec.
<BR>&nbsp;
<LI>
Created-By:</LI>

<BR>Defines the version and the vendor of the java implementation on top
of which this manifest file is generated. This attribute is generated by
the <TT>jar</TT> tool.
<BR>&nbsp;
<LI>
Signature-Version:</LI>

<BR>Defines the signature version of the jar file. The value should be
a valid <I>version-number</I> string.
<BR>&nbsp;
<LI>
Class-Path :</LI>

<BR>The value of this attribute specifies the relative URLs of the extensions
or libraries that this application or extension needs. URLs are separated
by one or more spaces. The application or extension class loader uses the
value of this attribute to construct its internal search path.
<BR>&nbsp;</UL>

<LI>
attribute defined for stand-alone applications</LI>
This attribute is used by stand-alone applications that are bundled into
executable jar files which can be invoked by the java runtime directly
by running "<TT>java -jar x.jar</TT>".
<UL>
<LI>
Main-Class :</LI>

<BR>The value of this attribute defines the relative path of the main application
class which the launcher will load at startup time. The value must 
<em>not</em> have the <tt>.class</tt> extension appended to the class 
name.</UL>
</UL>

<UL>
<LI>
attributes defined for applets</LI>
These attributes is used by an applet which is bundled into JAR&nbsp;files
to define requirements, version and location information for the extensions
which this applet depends on. (see&nbsp; <A HREF="../extensions/versioning.html">Extension Versioning</A> ).&nbsp;
<UL>
<LI>
Extension-List:</LI>

<BR>This attribute indicates the extensions that are needed by the applet.
Each extension listed in this attribute will have a set of additional attributes
that the applet uses to specify which version and vendor of the extension
it requires.
<BR>&nbsp;
<LI>
&lt;extension>-Extension-Name :</LI>

<BR>This attribute is the unique name of the extension. The Java Plug-in
will compare the value of this attribute with the Extension-Name attribute
in the manifests of installed extensions to determine if the extension
is installed.
<BR>&nbsp;
<LI>
&lt;extension>-Specification-Version</LI>

<BR>This attribute specifies the minimum extension specification version
that is required by the applet. The Java Plug-in will compare the value
of this attribute with the Specification-Version attribute of the installed
extension to determine if the extension is up to date.
<BR>&nbsp;
<LI>
&lt;extension>-Implementation-Version</LI>

<BR>This attritute specifies the minimum extension implementation version
number that is required by the applet. The Java Plug-in will compare the
value of this attribute with the Implementation-Version attribute of the
installed extension to see if a more recent implementation needs to be
downloaded.
<BR>&nbsp;
<LI>
&lt;extension>-Implementation-Vendor-Id</LI>

<BR>This attribute can be used to identify the vendor of an extension implementation
if the applet requires an implementation from a specific vendor. The Java
Plug-in will compare the value of this attribute with the Implementation-Vendor-Id
attribute of the installed extension.
<BR>&nbsp;
<LI>
&lt;extension>-Implementation-URL</LI>

<BR>This attribute specifies a URL that can be used to obtain the most
recent version of the extension if the required version is not already
installed.
<BR>&nbsp;</UL>

<LI>
attribute defined for extension identification</LI>
This attribute is used by extensions to define their unique identity.
<UL>
<LI>
Extension-Name:</LI>
This attribute specifies a name for the extension contained in the Jar
file. The name should be a unique identifier such as the name of the main
package comprising the extension.</UL>
&nbsp;
<LI>
attributes defined for extension and&nbsp; package <A HREF="../versioning/index.html">versioning</A>&nbsp;
and <A HREF="../extensions/spec.html#sealing">sealing</A>
information</LI>
These attributes define features of the extension which the JAR file is
a part of. The value of these attributes apply to all the packages in the
JAR&nbsp;file, but can be overridden by per-entry attributes.&nbsp;
<UL>
<LI>
Implementation-Title :</LI>
The value is a string that defines the title of the extension implementation.&nbsp;
<LI>
Implementation-Version :</LI>

<BR>The value is a string that defines the version of the extension implementation.
<BR>&nbsp;
<LI>
Implementation-Vendor :</LI>

<BR>The value is a string that defines the organization that maintains
the extension implementation.
<BR>&nbsp;
<LI>
Implementation-Vendor-Id :</LI>

<BR>The value is a string id that uniquely defines the organization that
maintains the&nbsp; extension implementation.
<BR>&nbsp;
<LI>
Implementation-URL :</LI>

<BR>This attribute defines the URL from which the extension implementation
can be downloaded from.
<BR>&nbsp;
<LI>
&nbsp;Specification-Title :</LI>

<BR>The value is a string that defines the title of the extension specification.
<BR>&nbsp;
<LI>
Specification-Version :</LI>

<BR>The value is a string that defines the version of the extension specification.
<BR>&nbsp;
<LI>
Specification-Vendor :</LI>

<BR>The value is a string that defines the organization that maintains
the extension specification.</UL>
</UL>

<UL>
<UL>
<LI>
Sealed :</LI>

<BR>This attribute defines whether this JAR file is sealed or not. The
value can be either "true" or "false", case is ignored. If it is set to
"true", then all the packages in the JAR file are defaulted to be sealed,
unless they are defined otherwise individually.</UL>
</UL>

<H3>
<A NAME="Per-Entry Attributes"></A>Per-Entry Attributes</H3>
Per-entry attributes apply only to the individual JAR file entry to which
the manifest entry is associated with.&nbsp; If the same attribute also
appeared in the main section, then the value of the per-entry attribute
overwrites the main attribute's value. For example, if JAR file a.jar has
the following manifest content:
<UL><TT>Manifest-Version: 1.0</TT>
<BR><TT>Created-By: 1.2 (Sun Microsystems Inc.)</TT>
<BR><TT>Sealed: true</TT>

<P><TT>Name: foo/bar/</TT>
<BR><TT>Sealed: false</TT></UL>
It means that all the packages archived in a.jar are sealed, except that
package foo.bar is not.

<P>The per-entry attributes fall into the following groups:
<UL>
<LI>
attributes defined for file contents:</LI>

<UL>
<LI>
Content-Type :</LI>

<BR>This attribute can be used to specify the MIME type and subtype of
data for a specific file entry in the JAR&nbsp;file. The value should be
a string in the form of <I>type/subtype. </I>For example "image/bmp" is
an image type with a subtype of bmp (representing bitmap). This would indicate
the file entry as an image with the data stored as a bitmap. RFC <A HREF="ftp://www.ietf.org/rfc/rfc1521.txt">1521</A>
and <A HREF="ftp://www.ietf.org/rfc/rfc1522.txt">1522 </A>discuss and
define the MIME types definition.</UL>
</UL>

<UL>
<LI>
attributes defined for package versioning and sealing information:</LI>


<P>These are the same set of attributes defined above as main attributes
that defines the extension package versioning and sealing information.
When used as per-entry attributes, these attributes overwrites the main
attributes but only apply to the individual file specified by the manifest
entry.
<BR>&nbsp;
<LI>
attribute defined for beans objects:</LI>

<UL>
<LI>
Java-Bean:</LI>

<BR>Defines whether the specific jar file entry is a Java <A HREF="http://java.sun.com/products/javabeans/docs/spec.html">Beans</A>
object or not. The value should be either "true" or "false", case is ignored.
<BR>&nbsp;</UL>

<LI>
attributes defined for signing:</LI>

<BR>These attributes are used for signing and verifying purposes. More
details here.
<UL>
<LI>
x-Digest-y:</LI>

<BR>The name of this attribute specifies the name of the digest algorithm
used to compute the digest value for the corresponding jar file entry.
The value of this attribute stores the actual digest value. The prefix
'x' specifies the algorithm name and the optional suffix 'y'&nbsp; indicates
to which language the digest value should be verified against.
<LI>
Magic:</LI>

<BR>This is an optional attribute that can be used by applications to indicate
how verifier should compute the digest value contained in the manifest
entry.&nbsp; The value of this attribute is a set of comma separated context
specific strings. Detailed description is here.</UL>
</UL>

<H1>
<A NAME="Signed JAR File"></A>Signed JAR File</H1>

<H3>
<A NAME="SignedJar-Overview"></A>Overview</H3>
A JAR file can be signed by using the command line&nbsp; <A HREF="../security/SecurityToolsSummary.html">jarsigner</A>&nbsp;
tool or directly through the java.security API. Every file entry will be
signed if the JAR file is signed by jarsigner tool. Subsets of a JAR file
can be signed by using the java.security API. A signed JAR file is exactly
the same as the original JAR file, except that its manifest is updated
and two additional files are added to the META-INF directory, a signature
file and a signature block file.&nbsp; When <TT>jarsigner</TT> is not used,
the signing program has to construct both the signature file and the signature
block file.

<P>For every file entry that is signed in the signed JAR file, an individual
manifest entry is created for it, if it does not exist in the manifest
before. Each manifest entry lists one or more digest attribute and an optional
Magic attribute.
<H3>
<A NAME="Signature File"></A>Signature File</H3>
Each signer is represented by a signature file with extension <TT>.SF</TT>.
The major part of the file is similar to the manifest file. It consists
of a main section which includes information supplied by the signer but
not specific to any particular jar file entry, followed by a list of individual
entries whose name must also be present in the manifest file. Each individual
entry must contain at least the digest of the corresponding entry in the
manifest file.

<P>Paths or URL's appearing in the manifest file but not in the signature
file are not used in calculation.
<H3>
<A NAME="Signature Validation"></A>Signature Validation</H3>
The signature is first verified when the manifest is first parsed. This
verification can be remembered, for efficiency. This only validates the
signature directions themselves, not the actual archive files.

<P>To validate a file, a digest value in the signature file is compared
against a digest calculated against the corresponding entry in the manifest
file. Then, a digest value in the manifest file is compared against a digest
calculated against the actual data referenced in the "<TT>Name:</TT>" attribute,
which specifies either a relative file path or URL.

<P>Example manifest file:
<BR>&nbsp;
<UL>&nbsp; <TT>Manifest-Version: 1.0&nbsp;</TT>
<BR><TT>&nbsp;Created-By: 1.3 (Sun Microsystems, Inc)</TT><TT></TT>

<P><TT>&nbsp;Name: common/class1.class</TT>
<BR><TT>&nbsp;MD5-Digest: (base64 representation of MD5 digest)</TT>

<P><TT>&nbsp;Name: common/class2.class</TT>
<BR><TT>&nbsp;MD5-Digest: (base64 representation of MD5 digest)</TT>
<BR><TT>&nbsp;SHA-Digest: (base64 representation of SHA digest)</TT></UL>
The corresponding signature file would be:
<BR>&nbsp;
<UL>&nbsp; <TT>Signature-Version: 1.0</TT><TT></TT>

<P><TT>&nbsp;Name: common/class1.class</TT>
<BR><TT>&nbsp;MD5-Digest: (base64 representation of MD5 digest)</TT><TT></TT>

<P><TT>&nbsp;Name: common/class2.class</TT>
<BR><TT>&nbsp;MD5-Digest: (base64 representation of MD5 digest)</TT>
<BR>&nbsp;</UL>

<H3>
<A NAME="The Magic Attribute"></A>The Magic Attribute</H3>
Another requirement to validate the signature on a given manifest entry
is that the verifier understand the value or values of the Magic key-pair
value in that entry's manifest entry.

<P>The Magic attribute is optional but it is required that a parser understand
the value of an entry's Magic key if it is verifying that entry's signature.

<P>The value or values of the Magic attribute are a set of comma-separated
context-specific strings. The spaces before and after the commas are ignored.
Case is ignored. The exact meaning of the magic attributes is application
specific. These values indicate how to compute the hash value contained
in the manifest entry, and are therefore crucial to the proper verification
of the signature. The keywords may be used for dynamic or embedded content,
multiple hashes for multilingual documents, etc.

<P>Here are two examples of the potential use of Magic attribute in the
manifest file:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>Name: http://www.scripts.com/index#script1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest: (base64
representation of SHA hash)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magic: JavaScript, Dynamic</TT><TT></TT>

<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name: http://www.tourist.com/guide.html</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest: (base64
representation of SHA hash)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest-French: (base64
representation of SHA hash)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHA-Digest-German: (base64
representation of SHA hash)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magic: Multilingual</TT>

<P>In the first example, these Magic values may indicate that the result
of an http query is the script embedded in the document, as opposed to
the document itself, and also that the script is generated dynamically.
These two pieces of information indicate how to compute the hash value
against which to compare the manifest's digest value, thus comparing a
valid signature.

<P>In the second example, the Magic value indicates that the document retrieved
may have been content-negotiated for a specific language, and that the
digest to verify against is dependent on which language the document retrieved
is written in.
<H2>
<A NAME="Digital Signatures"></A>Digital Signatures</H2>
A digital signature is a signed version of the <TT>.SF </TT>signature file.
These are binary files not intended to be interpreted by humans.

<P>Digital signature files have the same filename as the .SF file but different
extension. The extension varies depending on the type of digital signature.

<P>&nbsp; <TT>.RSA&nbsp;</TT>&nbsp;&nbsp;&nbsp;&nbsp; (PKCS7 signature,
MD5 + RSA)
<BR>&nbsp; <TT>.DSA&nbsp;</TT>&nbsp;&nbsp;&nbsp;&nbsp; (PKCS7 signature,
DSA)
<BR>&nbsp; <TT>.PGP&nbsp;</TT>&nbsp;&nbsp;&nbsp;&nbsp; (Pretty Good Privacy
Signature)

<P>For those formats that do not support external signed data, the file
shall consist of a signed copy of the .SF file. Thus some data may be duplicated
and a verifier ought to compare the two files.

<P>Formats that support external data either reference the <TT>.SF</TT>
file, or perform calculations on it with implicit reference.

<P>Each <TT>.SF</TT> file may have multiple digital signatures, but those
signatures ought to be generated by the same legal entity.

<P>File name extensions may be 1 to 3 <I>alphanum</I> characters. Extensions
unrecognized are ignored.
<H1>
<A NAME="Notes on Manifest and Signature Files"></A>Notes on Manifest and
Signature Files</H1>
Following is a list of additional restrictions and rules that apply to
manifest and signature files.
<UL>
<LI>
Before parsing:</LI>

<BR>If the last character of the file is an EOF character (code 26), the
EOF is treated as whitespace. Two newlines are appended (one for editors
that don't put a newline at the end of the last line, and one so that the
grammar doesn't have to special-case the last entry, which may not have
a blank line after it).</UL>

<UL>
<LI>
Attributes:</LI>

<BR>In all cases for all sections, attributes which are not understood
are ignored.

<P>Attribute names are case insensitive. Programs which generate manifest
and signature files should use the cases shown in this specification however.

<P>Attribute names cannot be repeated within a section.</UL>

<UL>
<LI>
Versions:</LI>

<BR>Manifest-Version and Signature-Version must be first, and in exactly
that case (so that they can be recognized easily as magic strings). Other
than that, the order of attributes within a main section is not significant.
<BR>&nbsp;
<LI>
Ordering:</LI>

<BR>The order of individual manifest entries is not significant.

<P>The order of individual signature entries is not significant, except
that the digests that get signed are in that order.</UL>

<UL>
<LI>
Line length:</LI>

<BR>No line may be longer than 72 bytes (not characters), in its UTF8-encoded
form. If a value would make the initial line longer than this, it should
be continued on extra lines (each starting with a single SPACE).
<BR>&nbsp;
<LI>
Errors:</LI>

<BR>If a file cannot be parsed according to this spec, a warning should
be output, and none of the signatures should be trusted.
<BR>&nbsp;
<LI>
Limitations:</LI>

<BR>Because header names cannot be continued, the maximum length of a header
name is 70 bytes (there must be a colon and a SPACE after the name).

<P>NUL, CR, and LF can't be embedded in header values, and NUL, CR, LF
and ":" can't be embedded in header names.

<P>Implementations should support 65535-byte (not character) header values,
and 65535 headers per file. They might run out of memory, but there should
not be hard-coded limits below these values.</UL>

<UL>
<LI>
Signers:</LI>

<BR>It is technically possible that different entities may use different
signing algorithms to share a single signature file. This violates the
standard, and the extra signature may be ignored.</UL>

<UL>
<LI>
Algorithms:</LI>

<BR>No digest algorithm or signature algorithm is mandated by this standard.
However, at least one of MD5 and SHA&nbsp;digest algorithm must be supported.</UL>

<H2>
<A NAME="JAR Index"></A>JAR Index</H2>

<H3>
<A NAME="Overview"></A>Overview</H3>
Since 1.3, JarIndex is introduced to optimize the class searching process
of class loaders for network applications, especially applets. Originally,
an applet class loader uses a simple linear search algorithm to search
each element on its internal search path, which is constructed from the
"ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads
and opens each element in its search path, until the class or resource
is found. If the class loader tries to find a nonexistent resource, then
all the jar files within the application or applet will have to be downloaded.
For large network applications and applets this could result in slow startup,
sluggish response and wasted network bandwidth. The JarIndex mechanism
collects the contents of all the jar files defined in an applet and stores
the information in an index file in the first jar file on the applet's
class path. After the first jar file is downloaded, the applet class loader
will use the collected content information for efficient downloading of
jar files.

<P>The existing <TT>jar</TT> tool is enhanced to be able to examine a list
of jar files and generate directory information as to which classes and
resources reside in which jar file. This directory information is stored
in a simple text file named <TT>INDEX.LIST </TT>in the <TT>META-INF </TT>directory
of the root jar file. When the classloader loads the root jar file,&nbsp;
it reads the <TT>INDEX.LIST</TT> file and uses it to construct a hash table
of mappings from file and package names to lists of jar file names. In
order to find a class or a resource, the class loader queries the hashtable
to find the proper jar file and then downloads it if necessary.

<P>Once the class loader finds a <TT>INDEX.LIST</TT> file in a particular
jar file, it always trusts the information listed in it. If a mapping is
found for a particular class, but the class loader fails to find it by
following the link, an InvalidJarIndexException is thrown. When this occurs,
the application developer should rerun the<TT> jar</TT> tool on the extension
to get the right information into the index file.

<P>To prevent adding too much space overhead to the application and to
speed up the construction of the in-memory hash table, the INDEX.LIST file
is kept as small as possible. For classes with non-null package names,
mappings are recorded at the package level. Normally one package name is
mapped to one jar file, but if a particular package spans more than one
jar file, then the mapped value of this package will be a list of jar files.
For resource files with non-empty directory prefixes, mappings are also
recorded at the directory level.&nbsp; Only for classes with null package
name, and resource files which reside in the root directory, will the mapping
be recorded at the individual file level.
<H3>
<A NAME="Index File Specification"></A>Index File Specification</H3>
The<TT> INDEX.LIST </TT>file contains one or more sections each separated
by a single blank line. Each section defines the content of a particular
jar file, with a header defining the jar file path name, followed by a
list of package or file names, one per line.&nbsp; All the jar file paths
are relative to the code base of the root jar file. These path names are
resolved in the same way as the current extension mechanism does for bundled
extensions.

<P>The UTF-8 encoding is used to support non ASCII characters in file or
package names in the index file.
<BR>&nbsp;
<H4>
Specification</H4>
&nbsp;&nbsp;&nbsp; <I>index file :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info blankline section*</I>
<BR><I>&nbsp;&nbsp;&nbsp; version-info :&nbsp;</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>JarIndex-Version: </TT><I>version-number</I>
<BR><I>&nbsp;&nbsp;&nbsp; version-number :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{.digit+}*</I>
<BR><I>&nbsp;&nbsp;&nbsp; section :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
body blankline</I>
<BR><I>&nbsp;&nbsp;&nbsp; body :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
header name*</I>
<BR><I>&nbsp;&nbsp;&nbsp; header :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+</I><TT>.jar</TT> <I>newline</I>
<BR><I>&nbsp;&nbsp;&nbsp; name :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+ newline</I>
<BR><I>&nbsp;&nbsp;&nbsp; char :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any valid Unicode character except</I> <TT>NULL, CR </TT><I>and</I><TT>
LF</TT>
<BR>&nbsp;&nbsp;&nbsp; <I>blankline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
newline newline</I>
<BR><I>&nbsp;&nbsp;&nbsp; newline :&nbsp;</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>CR LF | LF | CR</TT> (<I>not followed by </I><TT>LF</TT>)
<BR>&nbsp;&nbsp;&nbsp; <I>digit:&nbsp;</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<TT>0-9</TT>}
<BR>&nbsp;
<BR>The <TT>INDEX.LIST</TT> file is generated by running <TT>jar -i.</TT>
See the <A HREF="../../tooldocs/windows/jar.html">jar</A>
man page for more details.
<H3>
<A NAME="Backward Compatibility"></A>Backward Compatibility</H3>
The new class loading scheme is totally backward compatible with applications
developed on top of the current extension mechanism.&nbsp; When the class
loader loads the first jar file and an <TT>INDEX.LIST </TT>file is found
in the <TT>META-INF </TT>directory, it would construct the index hash table
and use the new loading scheme for the extension. Otherwise, the class
loader will simply use the original linear search algorithm.
<H2>
<A NAME="Service Provider"></A>Service Provider</H2>

<H3>
<A NAME="Overview"></A>Overview</H3>
Files in the <TT>META-INF/services</TT> directory are service provider
configuration files. A service is a well-known set of interfaces and (usually
abstract) classes. A service provider is a specific implementation of a
service. The classes in a provider typically implement the interfaces and
subclass the classes defined in the service itself. Service providers may
be installed in an implementation of the Java platform in the form of extensions,
that is, jar files placed into any of the usual extension directories.
Providers may also be made available by adding them to the applet or application
class path or by some other platform-specific means.

<P>A service is represented by an abstract class. A provider of a given
service contains one or more concrete classes that extend this service
class with data and code specific to the provider. This provider class
will typically not be the entire provider itself but rather a proxy that
contains enough information to decide whether the provider is able to satisfy
a particular request together with code that can create the actual provider
on demand. The details of provider classes tend to be highly service-specific;
no single class or interface could possibly unify them, so no such class
has been defined. The only requirement enforced here is that provider classes
must have a zero-argument constructor so that they may be instantiated
during lookup.
<BR>&nbsp;
<H3>
<A NAME="Provider Configuration File"></A>Provider-Configuration File</H3>
A service provider identifies itself by placing a provider-configuration
file in the resource directory <TT>META-INF/services</TT>. The file's name
should consist of the fully-qualified name of the abstract service class.
The file should contain a newline-separated list of unique concrete provider-class
names. Space and tab characters, as well as blank lines, are ignored. The
comment character is '#' (0x23); on each line all characters following
the first comment character are ignored. The file must be encoded in UTF-8.
<BR>&nbsp;
<H3>
<A NAME="Example"></A>Example</H3>
Suppose we have a service class named java.io.spi.CharCodec. It has two
abstract methods:

<P>&nbsp;&nbsp;&nbsp; <TT>public abstract CharEncoder getEncoder(String
encodingName);</TT>
<BR><TT>&nbsp; public abstract CharDecoder getDecoder(String encodingName);</TT>

<P>Each method returns an appropriate object or null if it cannot translate
the given encoding. Typical CharCodec providers will support more than
one encoding.

<P>If sun.io.StandardCodec is a provider of the CharCodec service then
its jar file would contain the file <TT>META-INF/services/java.io.spi.CharCodec</TT>.
This file would contain the single line:

<P>&nbsp;&nbsp; <TT>sun.io.StandardCodec&nbsp;&nbsp;&nbsp; # Standard codecs
for the platform</TT>

<P>To locate an encoder for a given encoding name, the internal I/O code
would do something like this:

<P>&nbsp;&nbsp; <TT>CharEncoder getEncoder(String encodingName) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator ps = Service.providers(CharCodec.class);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ps.hasNext()) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharCodec
cc = (CharCodec)ps.next();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharEncoder
ce = cc.getEncoder(encodingName);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(ce != null)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return ce;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;</TT>
<BR><TT>&nbsp;&nbsp; }</TT>
<BR>&nbsp;

<P>The provider-lookup mechanism always executes in the security context
of the caller. Trusted system code should typically invoke the methods
in this class from within a privileged security context.

<P>&nbsp;
<H2>
<A NAME="API Details"></A>API Details</H2>
Package <A HREF="../../api/java/util/jar/package-summary.html">java.util.jar</A>
<H2>
<A NAME="See Also"></A>See Also</H2>
Package <A HREF="../../api/java/security/package-summary.html">java.security</A>
<BR>Package <A HREF="../../api/java/util/zip/package-summary.html">java.util.zip</A>
<!-- Body text ends here -->
<!-- ============================================================== -->
<HR SIZE=3 NOSHADE>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>

<TD>
<P><FONT SIZE="-2">
   <A HREF="../../relnotes/SMICopyright.html">Copyright &#169;</A> 1999
   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>
    All Rights Reserved.</FONT></P>


</TD>

<TD ALIGN=RIGHT>
   <IMG SRC="../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 0>
   <BR>
   <FONT SIZE="+1">
   <i>Java Software</i>
   </FONT>
</TD>

</TR>
</TABLE>


</BODY>
</HTML>
